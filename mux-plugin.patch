Index: ilp-plugin-btp-grpc/src/main/proto/btp2_1.proto
===================================================================
--- ilp-plugin-btp-grpc/src/main/proto/btp2_1.proto	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
+++ ilp-plugin-btp-grpc/src/main/proto/btp2_1.proto	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
@@ -1,84 +0,0 @@
-syntax = "proto3";
-
-option java_multiple_files = false;
-option java_package = "org.interledger.btp21";
-option java_outer_classname = "HelloWorldProto";
-option objc_class_prefix = "BTP21";
-
-package interledger;
-
-import public "google/protobuf/timestamp.proto";
-
-service Btp21 {
-    // Sends a Message to the Bilateral Peer
-    rpc SendMessage (stream BilateralMessage) returns (stream BilateralResponse) {
-    }
-
-    // Send Proof of Payment or other Settlement info to the Bilateral Peer.
-    rpc SendTransfer(stream BilateralTransfer) returns (stream BilateralResponse) {
-    }
-}
-
-message SubProtocolData {
-    string protocolName = 1;
-    int32 contentType = 2;
-    bytes data = 3;
-}
-
-// Message is used for sending information to the peer. It contains no packet-specific data, only protocol data. ILP
-// packets are attached under the protocol name `ilp` with content-type `application/octet-stream`.
-message BilateralMessage {
-    SubProtocolData protocolData = 1;
-}
-
-// Transfer is used to send proof of payment, payment channel claims, or other settlement information to the other side
-// of a org.interledger.bilateral connection. The amount should indicate the additional value of this settlement state (compared to the
-// previous settlement state), in a unit that was agreed out-of-band.
-message BilateralTransfer {
-    int64 amount = 1;
-    SubProtocolData protocolData = 2;
-}
-
-// The response message containing the greetings
-message BilateralResponse {
-    SubProtocolData protocolData = 2;
-}
-
-// A response-type message, returned when an error occurs on the BTP level.
-message BilateralError {
-
-    enum Codes {
-        T00 = 0; // UnreachableError
-        F00 = 1; // NotAcceptedError
-        F01 = 2; // InvalidFieldsError
-        F03 = 3; // TransferNotFoundError
-        F04 = 4; // InvalidFulfillmentError
-        F05 = 5; // DuplicateIdError
-        F06 = 6; // AlreadyRolledBackError
-        F07 = 7; // AlreadyFulfilledError
-        F08 = 8; // InsufficientBalanceError
-    }
-
-    // Standardized error code
-    Codes code = 1;
-    // Time of emission
-    google.protobuf.Timestamp triggeredAt = 2;
-    // Additional error data
-    string errorMessage = 3;
-
-    SubProtocolData protocolData = 4;
-
-    enum Errors {
-        UNREACHABLE_ERROR = 0;
-        NOT_ACCEPTED_ERROR = 1;
-        INVALID_FIELDS_ERROR = 2;
-        TRANSFER_NOT_FOUND_ERROR = 3;
-        INVALID_FULFILLMENT_ERROR = 4;
-        DUPLICATE_ID_ERROR = 5;
-        ALREADY_ROLLED_BACK_ERROR = 6;
-        ALREADY_FULFILLED_ERROR = 7;
-        INSUFFICIENT_BALANCE_ERROR = 8;
-    }
-
-}
-
Index: ilp-plugin-btp-grpc/pom.xml
===================================================================
--- ilp-plugin-btp-grpc/pom.xml	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
+++ ilp-plugin-btp-grpc/pom.xml	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
@@ -1,57 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project xmlns="http://maven.apache.org/POM/4.0.0"
-  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
-  <parent>
-    <artifactId>ilp-plugin</artifactId>
-    <groupId>org.interledger</groupId>
-    <version>2.0.0-SNAPSHOT</version>
-  </parent>
-  <modelVersion>4.0.0</modelVersion>
-
-  <artifactId>ilp-plugin-btp-grpc</artifactId>
-
-  <name>ILP Plugin BTP 2.1 over gRPC</name>
-  <description>Java implementation of a BTP Plugin Interface over gRPC</description>
-
-  <dependencies>
-    <dependency>
-      <groupId>io.grpc</groupId>
-      <artifactId>grpc-netty-shaded</artifactId>
-    </dependency>
-    <dependency>
-      <groupId>io.grpc</groupId>
-      <artifactId>grpc-protobuf</artifactId>
-    </dependency>
-    <dependency>
-      <groupId>io.grpc</groupId>
-      <artifactId>grpc-stub</artifactId>
-    </dependency>
-  </dependencies>
-
-  <build>
-    <plugins>
-      <plugin>
-        <groupId>org.xolstice.maven.plugins</groupId>
-        <artifactId>protobuf-maven-plugin</artifactId>
-        <version>${protobuf.maven.plugin.version}</version>
-        <configuration>
-          <protocArtifact>com.google.protobuf:protoc:${protoc.version}:exe:${os.detected.classifier}
-          </protocArtifact>
-          <pluginId>grpc-java</pluginId>
-          <pluginArtifact>
-            io.grpc:protoc-gen-grpc-java:${protoc.gen.grpc.java.version}:exe:${os.detected.classifier}
-          </pluginArtifact>
-        </configuration>
-        <executions>
-          <execution>
-            <goals>
-              <goal>compile</goal>
-              <goal>compile-custom</goal>
-            </goals>
-          </execution>
-        </executions>
-      </plugin>
-    </plugins>
-  </build>
-</project>
\ No newline at end of file
Index: ilp-plugin-grpc/src/main/proto/grinterledger.proto
===================================================================
--- ilp-plugin-grpc/src/main/proto/grinterledger.proto	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
+++ ilp-plugin-grpc/src/main/proto/grinterledger.proto	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
@@ -1,38 +0,0 @@
-syntax = "proto3";
-
-option java_multiple_files = false;
-option java_package = "org.interledger.grpc.bpp";
-option java_outer_classname = "GrinterledgerBppProto";
-option objc_class_prefix = "GBPP";
-
-package interledger;
-
-import public "google/protobuf/empty.proto";
-
-// Grinterledger BPP: The gRPC Interledger Bilateral Push Protocol is a synchronous RPC service (i.e., non-streaming)
-// that allows nodes to send and receive org.interledger.bilateral messages, possibly relating to multiple accounts,
-// using the same gRPC transport. In this setup, each node operates a single gRPC client and a single gRPC server.
-// Incoming requests come in from the remote on the gRPC server, and outgoing requests go out to the remote using the
-// gRPC client.
-
-// Note that any custom information for these request must be supplied in meta-data using gRPC headers, since there is
-// no direct support for sub-protocols in this protocol.
-service GrinterledgerBpp {
-
-    rpc TestConnection (google.protobuf.Empty) returns (google.protobuf.Empty) {
-    }
-
-    // Send an ILP Prepare packet.
-    rpc Send (GrinterledgerBppPrepare) returns (GrinterledgerBppResponse) {
-    }
-}
-
-// An envelope for an Interledger Prepare Packet.
-message GrinterledgerBppPrepare {
-    bytes preparePacketBytes = 1;
-}
-
-// An envelope for an Interledger Packet (fulfill, or reject).
-message GrinterledgerBppResponse {
-    bytes responsePacketBytes = 1;
-}
\ No newline at end of file
Index: ilp-plugin-grpc/src/test/java/org/interledger/plugin/mux/grpc/bpp/GrinterledgerBppClientTest.java
===================================================================
--- ilp-plugin-grpc/src/test/java/org/interledger/plugin/mux/grpc/bpp/GrinterledgerBppClientTest.java	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
+++ ilp-plugin-grpc/src/test/java/org/interledger/plugin/mux/grpc/bpp/GrinterledgerBppClientTest.java	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
@@ -1,243 +0,0 @@
-package org.interledger.plugin.mux.grpc.bpp;
-
-import static junit.framework.TestCase.fail;
-import static org.hamcrest.CoreMatchers.is;
-import static org.hamcrest.MatcherAssert.assertThat;
-import static org.interledger.TestArtifacts.CODEC_CONTEXT;
-import static org.interledger.TestArtifacts.FULFILLMENT;
-import static org.interledger.TestArtifacts.FULFILL_PACKET;
-import static org.interledger.TestArtifacts.PREPARE_PACKET;
-import static org.interledger.TestArtifacts.REJECT_PACKET;
-import static org.interledger.plugin.mux.grpc.GrpcIOStreamUtils.toByteString;
-import static org.mockito.AdditionalAnswers.delegatesTo;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
-import org.interledger.core.InterledgerFulfillPacket;
-import org.interledger.core.InterledgerRejectPacket;
-import org.interledger.core.InterledgerResponsePacket;
-import org.interledger.core.InterledgerResponsePacketHandler;
-import org.interledger.grpc.bpp.GrinterledgerBppGrpc;
-import org.interledger.grpc.bpp.GrinterledgerBppProto.GrinterledgerBppPrepare;
-import org.interledger.grpc.bpp.GrinterledgerBppProto.GrinterledgerBppResponse;
-
-import com.google.protobuf.ByteString;
-import io.grpc.Context;
-import io.grpc.ManagedChannel;
-import io.grpc.Status;
-import io.grpc.inprocess.InProcessChannelBuilder;
-import io.grpc.inprocess.InProcessServerBuilder;
-import io.grpc.stub.StreamObserver;
-import io.grpc.testing.GrpcCleanupRule;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import org.mockito.ArgumentCaptor;
-import org.mockito.ArgumentMatchers;
-
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.util.Optional;
-
-/**
- * A unit test that validates the {@link GrinterledgerBppClient}.
- */
-@RunWith(JUnit4.class)
-public class GrinterledgerBppClientTest {
-//
-//  /**
-//   * This rule manages automatic graceful shutdown for the registered servers and channels at the end of test.
-//   */
-//  @Rule
-//  public final GrpcCleanupRule grpcCleanup = new GrpcCleanupRule();
-//  private ExpectedResult expectedResult;
-//
-//  private GrinterledgerBppGrpc.GrinterledgerBppImplBase serviceImpl;
-//  private GrinterledgerBppClient client;
-//
-//  @Before
-//  public void setUp() throws Exception {
-//
-//    this.serviceImpl =
-//        mock(GrinterledgerBppGrpc.GrinterledgerBppImplBase.class,
-//            delegatesTo(new GrinterledgerBppGrpc.GrinterledgerBppImplBase() {
-//              @Override
-//              public void send(GrinterledgerBppPrepare request,
-//                  StreamObserver<GrinterledgerBppResponse> responseObserver) {
-//
-//                if (Context.current().isCancelled()) {
-//                  responseObserver
-//                      .onError(Status.CANCELLED.withDescription("Cancelled by client").asRuntimeException());
-//                  return;
-//                }
-//
-//                try {
-//
-//                  switch (expectedResult) {
-//                    case FULFILL: {
-//                      final ByteString packetAsByteString = toByteString(CODEC_CONTEXT, FULFILL_PACKET);
-//                      final GrinterledgerBppResponse sendDataResponse = GrinterledgerBppResponse.newBuilder()
-//                          .setResponsePacketBytes(packetAsByteString)
-//                          .build();
-//                      // Send the response...
-//                      responseObserver.onNext(sendDataResponse);
-//                      responseObserver.onCompleted();
-//                      break;
-//                    }
-//                    case REJECT: {
-//                      final ByteString packetAsByteString = toByteString(CODEC_CONTEXT, REJECT_PACKET);
-//                      final GrinterledgerBppResponse sendDataResponse = GrinterledgerBppResponse.newBuilder()
-//                          .setResponsePacketBytes(packetAsByteString)
-//                          .build();
-//                      // Send the response...
-//                      responseObserver.onNext(sendDataResponse);
-//                      responseObserver.onCompleted();
-//                      break;
-//                    }
-//                    case EXPIRE:
-//                    default: {
-//                      responseObserver.onCompleted();
-//                      break;
-//                    }
-//                  }
-//
-//                } catch (Exception e) {
-//                  responseObserver.onError(e);
-//                }
-//              }
-//            }));
-//
-//    // Generate a unique in-process server name.
-//    String serverName = InProcessServerBuilder.generateName();
-//
-//    // Create a server, add service, start, and register for automatic graceful shutdown.
-//    grpcCleanup.register(InProcessServerBuilder
-//        .forName(serverName).directExecutor().addService(serviceImpl).build().start());
-//
-//    // Create a client channel and register for automatic graceful shutdown.
-//    ManagedChannel channel = grpcCleanup.register(
-//        InProcessChannelBuilder.forName(serverName).directExecutor().build());
-//
-//    // Create a IlpPluginClient using the in-process channel;
-//    client = new GrinterledgerBppClient(CODEC_CONTEXT, channel);
-//  }
-//
-//  /**
-//   * To test the client, call from the client against the fake server, and verify a fulfill response.
-//   */
-//  @Test
-//  public void client_sendAndFulfill() throws IOException {
-//    this.expectedResult = ExpectedResult.FULFILL;
-//    final ArgumentCaptor<GrinterledgerBppPrepare> requestCaptor = ArgumentCaptor
-//        .forClass(GrinterledgerBppPrepare.class);
-//
-//    ByteArrayOutputStream expectedPrepareBytesOutputStream = new ByteArrayOutputStream();
-//    CODEC_CONTEXT.write(PREPARE_PACKET, expectedPrepareBytesOutputStream);
-//    final byte[] expectedBytes = expectedPrepareBytesOutputStream.toByteArray();
-//
-//    final Optional<InterledgerResponsePacket> response = client.send(PREPARE_PACKET).join();
-//
-//    verify(serviceImpl).send(requestCaptor.capture(), ArgumentMatchers.any());
-//    assertThat(requestCaptor.getValue().getPreparePacketBytes().toByteArray(), is(expectedBytes));
-//
-//    new InterledgerResponsePacketHandler() {
-//
-//      @Override
-//      protected void handleFulfillPacket(InterledgerFulfillPacket interledgerFulfillPacket) {
-//        assertThat(interledgerFulfillPacket.getFulfillment(), is(FULFILLMENT));
-//      }
-//
-//      @Override
-//      protected void handleRejectPacket(InterledgerRejectPacket interledgerRejectPacket) {
-//        fail("Request should not reject!");
-//      }
-//
-//      @Override
-//      protected void handleExpiredPacket() {
-//        fail("Request should not expired!");
-//      }
-//    }.handle(response);
-//  }
-//
-//  /**
-//   * To test the client, call from the client against the fake server, and verify a rejection response.
-//   */
-//  @Test
-//  public void client_sendAndReject() throws IOException {
-//    this.expectedResult = ExpectedResult.REJECT;
-//    final ArgumentCaptor<GrinterledgerBppPrepare> requestCaptor = ArgumentCaptor
-//        .forClass(GrinterledgerBppPrepare.class);
-//
-//    ByteArrayOutputStream expectedPrepareBytesOutputStream = new ByteArrayOutputStream();
-//    CODEC_CONTEXT.write(PREPARE_PACKET, expectedPrepareBytesOutputStream);
-//    final byte[] expectedBytes = expectedPrepareBytesOutputStream.toByteArray();
-//
-//    final Optional<InterledgerResponsePacket> response = client.send(PREPARE_PACKET).join();
-//
-//    verify(serviceImpl).send(requestCaptor.capture(), ArgumentMatchers.any());
-//    assertThat(requestCaptor.getValue().getPreparePacketBytes().toByteArray(), is(expectedBytes));
-//
-//    new InterledgerResponsePacketHandler() {
-//
-//      @Override
-//      protected void handleFulfillPacket(InterledgerFulfillPacket interledgerFulfillPacket) {
-//        fail("Request should not fulfill!");
-//      }
-//
-//      @Override
-//      protected void handleRejectPacket(InterledgerRejectPacket interledgerRejectPacket) {
-//        assertThat(interledgerRejectPacket, is(REJECT_PACKET));
-//      }
-//
-//      @Override
-//      protected void handleExpiredPacket() {
-//        fail("Request should not expired!");
-//      }
-//    }.handle(response);
-//  }
-//
-//  /**
-//   * To test the client, call from the client against the fake server, and verify a rejection response.
-//   */
-//  @Test
-//  public void client_sendAndTimeout() throws IOException {
-//    this.expectedResult = ExpectedResult.EXPIRE;
-//    final ArgumentCaptor<GrinterledgerBppPrepare> requestCaptor = ArgumentCaptor
-//        .forClass(GrinterledgerBppPrepare.class);
-//
-//    ByteArrayOutputStream expectedPrepareBytesOutputStream = new ByteArrayOutputStream();
-//    CODEC_CONTEXT.write(PREPARE_PACKET, expectedPrepareBytesOutputStream);
-//    final byte[] expectedBytes = expectedPrepareBytesOutputStream.toByteArray();
-//
-//    final Optional<InterledgerResponsePacket> response = client.send(PREPARE_PACKET).join();
-//
-//    verify(serviceImpl).send(requestCaptor.capture(), ArgumentMatchers.any());
-//    assertThat(requestCaptor.getValue().getPreparePacketBytes().toByteArray(), is(expectedBytes));
-//
-//    new InterledgerResponsePacketHandler() {
-//
-//      @Override
-//      protected void handleFulfillPacket(InterledgerFulfillPacket interledgerFulfillPacket) {
-//        fail("Request should not fulfill!");
-//      }
-//
-//      @Override
-//      protected void handleRejectPacket(InterledgerRejectPacket interledgerRejectPacket) {
-//        fail("Request should not reject!");
-//      }
-//
-//      @Override
-//      protected void handleExpiredPacket() {
-//        // No-op
-//      }
-//    }.handle(response);
-//  }
-//
-//  private enum ExpectedResult {
-//    FULFILL,
-//    REJECT,
-//    EXPIRE
-//  }
-}
\ No newline at end of file
Index: ilp-plugin-btp-springws/src/main/java/org/interledger/plugin/lpiv2/btp2/spring/ServerWebsocketBtpPlugin.java
===================================================================
--- ilp-plugin-btp-springws/src/main/java/org/interledger/plugin/lpiv2/btp2/spring/ServerWebsocketBtpPlugin.java	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
+++ ilp-plugin-btp-springws/src/main/java/org/interledger/plugin/lpiv2/btp2/spring/ServerWebsocketBtpPlugin.java	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
@@ -1,97 +0,0 @@
-package org.interledger.plugin.lpiv2.btp2.spring;
-
-import org.interledger.encoding.asn.framework.CodecContext;
-import org.interledger.plugin.lpiv2.PluginType;
-import org.interledger.plugin.lpiv2.btp2.BtpServerPluginSettings;
-import org.interledger.plugin.lpiv2.btp2.spring.converters.BinaryMessageToBtpPacketConverter;
-import org.interledger.plugin.lpiv2.btp2.spring.converters.BtpPacketToBinaryMessageConverter;
-import org.interledger.plugin.lpiv2.btp2.subprotocols.BtpSubProtocolHandlerRegistry;
-
-import org.springframework.web.socket.WebSocketSession;
-
-import java.io.IOException;
-import java.util.Objects;
-import java.util.Optional;
-import java.util.concurrent.CompletableFuture;
-
-/**
- * An extension of {@link AbstractWebsocketBtpPlugin} for when the plugin is operating the Websocket server, accepting
- * mux from a remote BTP Plugin.
- */
-public class ServerWebsocketBtpPlugin { //extends AbstractWebsocketBtpPlugin<BtpServerPluginSettings> {
-//
-//  public static final String PLUGIN_TYPE_STRING = "BTP_SERVER";
-//  public static final PluginType PLUGIN_TYPE = PluginType.of(PLUGIN_TYPE_STRING);
-//
-//  /**
-//   * Required-args Constructor.
-//   */
-//  public ServerWebsocketBtpPlugin(
-//      final BtpServerPluginSettings pluginSettings,
-//      final CodecContext ilpCodecContext,
-//      final CodecContext btpCodecContext,
-//      final BtpSubProtocolHandlerRegistry btpSubProtocolHandlerRegistry,
-//      final BinaryMessageToBtpPacketConverter binaryMessageToBtpPacketConverter,
-//      final BtpPacketToBinaryMessageConverter btpPacketToBinaryMessageConverter,
-//      final WebSocketSession webSocketSession
-//  ) {
-//    super(
-//        pluginSettings, ilpCodecContext, btpCodecContext, btpSubProtocolHandlerRegistry,
-//        binaryMessageToBtpPacketConverter, btpPacketToBinaryMessageConverter, webSocketSession
-//    );
-//  }
-//
-//  /**
-//   * Required-args Constructor.
-//   */
-//  public ServerWebsocketBtpPlugin(
-//      final BtpServerPluginSettings pluginSettings,
-//      final CodecContext ilpCodecContext,
-//      final CodecContext btpCodecContext,
-//      final BtpSubProtocolHandlerRegistry btpSubProtocolHandlerRegistry,
-//      final BinaryMessageToBtpPacketConverter binaryMessageToBtpPacketConverter,
-//      final BtpPacketToBinaryMessageConverter btpPacketToBinaryMessageConverter
-//  ) {
-//    super(
-//        pluginSettings, ilpCodecContext, btpCodecContext, btpSubProtocolHandlerRegistry,
-//        binaryMessageToBtpPacketConverter, btpPacketToBinaryMessageConverter
-//    );
-//  }
-//
-//  /**
-//   * This method will be called for all plugins. This is a listening-only variant (i.e., no external connection needs to
-//   * be made), so this is a no-op.
-//   */
-//  @Override
-//  public CompletableFuture<Void> doConnectSenderMux() {
-//    // This is a no-op. The BtpSession is associated
-//    return CompletableFuture.completedFuture(null);
-//  }
-//
-//  @Override
-//  public CompletableFuture<Void> doDisconnect() {
-//    return CompletableFuture.runAsync(() -> {
-//      // Close the webSocketSession...
-//      this.webSocketSession.ifPresent(session -> {
-//        try {
-//          session.close();
-//        } catch (IOException e) {
-//          throw new RuntimeException(e);
-//        }
-//      });
-//
-//      this.webSocketSession = Optional.empty();
-//    });
-//  }
-//
-//  /////////////////
-//  // Helper Methods
-//  /////////////////
-//
-//  /**
-//   * Method for setter-based dependency injection.
-//   */
-//  public void setWebSocketSession(final Optional<WebSocketSession> webSocketSession) {
-//    this.webSocketSession = Objects.requireNonNull(webSocketSession);
-//  }
-}
Index: ilp-plugin-connections/src/main/java/org/interledger/plugin/connections/ConnectableConnection.java
===================================================================
--- ilp-plugin-connections/src/main/java/org/interledger/plugin/connections/ConnectableConnection.java	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
+++ ilp-plugin-connections/src/main/java/org/interledger/plugin/connections/ConnectableConnection.java	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
@@ -1,34 +0,0 @@
-package org.interledger.plugin.connections;
-
-import org.interledger.plugin.Connectable;
-import org.interledger.plugin.connections.events.bilateral.BilateralConnectionEventListener;
-
-import java.util.UUID;
-
-/**
- * Defines how to connect and disconnect.
- */
-public interface ConnectableConnection extends Connectable {
-
-  /**
-   * Add a plugin event listener.
-   *
-   * Care should be taken when adding multiple handlers to ensure that they perform distinct operations, otherwise
-   * duplicate functionality might be unintentionally introduced.
-   *
-   * @param eventListenerId A unique identifier for the event listener.
-   * @param eventListener   A {@link BilateralConnectionEventListener} that can handle various types of events emitted
-   *                        by this ledger plugin.
-   *
-   * @return A {@link UUID} representing the unique identifier of the handler, as seen by this ledger plugin.
-   */
-  void addPluginEventListener(final UUID eventListenerId, final BilateralConnectionEventListener eventListener);
-
-  /**
-   * Removes an event listener.
-   *
-   * @param eventListenerId A {@link UUID} representing the unique identifier of the handler, as seen by this ledger
-   *                        plugin.
-   */
-  void removePluginEventListener(final UUID eventListenerId);
-}
Index: ilp-plugin-core/src/main/java/org/interledger/plugin/BilateralPinger.java
===================================================================
--- ilp-plugin-core/src/main/java/org/interledger/plugin/BilateralPinger.java	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
+++ ilp-plugin-core/src/main/java/org/interledger/plugin/BilateralPinger.java	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
@@ -1,47 +0,0 @@
-package org.interledger.plugin;
-
-import org.interledger.core.InterledgerAddress;
-import org.interledger.core.InterledgerCondition;
-import org.interledger.core.InterledgerPreparePacket;
-import org.interledger.core.InterledgerResponsePacket;
-
-import java.math.BigInteger;
-import java.time.Instant;
-import java.util.Base64;
-import java.util.Objects;
-import java.util.Optional;
-import java.util.concurrent.CompletableFuture;
-
-/**
- * Defines how a {@link BilateralSender} (i.e., a single Interledger account) can establish connectivity to another
- * Interledger account. This mechanism works by assembling various payment types in order to establish unidirectional
- * payment liquidity.
- */
-public interface BilateralPinger extends BilateralSender {
-
-  // TODO: PingWithEcho.
-
-  InterledgerCondition PING_PROTOCOL_CONDITION =
-      InterledgerCondition.of(Base64.getDecoder().decode("Zmh6rfhivXdsj8GLjp+OIAiXFIVu4jOzkCpZHQ1fKSU="));
-
-  /**
-   * Send a 0-value payment to the destination and expect an ILP fulfillment, which demonstrates this sender has
-   * send-data connectivity to the indicated destination address.
-   *
-   * @param destinationAddress
-   */
-  default CompletableFuture<Optional<InterledgerResponsePacket>> ping(final InterledgerAddress destinationAddress) {
-    Objects.requireNonNull(destinationAddress);
-
-    final InterledgerPreparePacket pingPacket = InterledgerPreparePacket.builder()
-        .executionCondition(PING_PROTOCOL_CONDITION)
-        // TODO: Make this timeout configurable!
-        .expiresAt(Instant.now().plusSeconds(30))
-        .amount(BigInteger.ZERO)
-        .destination(destinationAddress)
-        .build();
-
-    return this.safeGetDataSender().sendData(pingPacket);
-  }
-
-}
Index: ilp-plugin-connections/src/main/java/org/interledger/plugin/connections/mux/BilateralSenderMux.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ilp-plugin-connections/src/main/java/org/interledger/plugin/connections/mux/BilateralSenderMux.java	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
+++ ilp-plugin-connections/src/main/java/org/interledger/plugin/connections/mux/BilateralSenderMux.java	(date 1546449541000)
@@ -15,7 +15,10 @@
  *
  * <p>Because a MUX is meant to be utilized by a {@link BilateralConnection}, a MUX must always listen for events from
  * a  {@link BilateralConnection} by implementing {@link BilateralConnectionEventListener}.</p>
+ *
+ * @deprecated Will be replaced by BilateralConnection.
  */
+@Deprecated
 public interface BilateralSenderMux extends ConnectableSender {
 
   // TODO: Introduce SenderMuxSettings? Connection settings will be performed on a Sender/Receiver basis -- e.g.,
@@ -33,9 +36,9 @@
    */
   Optional<BilateralSender> getBilateralSender(InterledgerAddress sourceAccountAddress);
 
-  void registerBilateralSender(InterledgerAddress accountAddress, BilateralSender sender);
+  //void registerBilateralSender(InterledgerAddress accountAddress, BilateralSender sender);
 
-  void unregisterBilateralSender(InterledgerAddress accountAddress);
+  //void unregisterBilateralSender(InterledgerAddress accountAddress);
 
   default CompletableFuture<Void> disconnectSender(final InterledgerAddress accountAddress) {
     Objects.requireNonNull(accountAddress);
Index: ilp-plugin-btp/src/main/java/org/interledger/plugin/lpiv2/btp2/subprotocols/auth/BtpAuthenticationException.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ilp-plugin-btp/src/main/java/org/interledger/plugin/lpiv2/btp2/subprotocols/auth/BtpAuthenticationException.java	(date 1545853718000)
+++ ilp-plugin-btp/src/main/java/org/interledger/plugin/lpiv2/btp2/subprotocols/auth/BtpAuthenticationException.java	(date 1545853718000)
@@ -0,0 +1,41 @@
+package org.interledger.plugin.lpiv2.btp2.subprotocols.auth;
+
+import org.interledger.btp.BtpErrorCode;
+import org.interledger.btp.BtpRuntimeException;
+
+public class BtpAuthenticationException extends BtpRuntimeException {
+
+  /**
+   * Constructs a new runtime exception with {@code null} as its detail message.  The cause is not initialized, and may
+   * subsequently be initialized by a call to {@link #initCause}.
+   */
+  public BtpAuthenticationException() {
+    this("Invalid BTP authentication credentials");
+  }
+
+  /**
+   * Constructs a new runtime exception with the specified detail message. The cause is not initialized, and may
+   * subsequently be initialized by a call to {@link #initCause}.
+   *
+   * @param message the detail message. The detail message is saved for later retrieval by the {@link #getMessage()}
+   *                method.
+   */
+  public BtpAuthenticationException(String message) {
+    super(BtpErrorCode.F00_NotAcceptedError, message);
+  }
+
+  /**
+   * Constructs a new runtime exception with the specified detail message and cause.  <p>Note that the detail message
+   * associated with {@code cause} is <i>not</i> automatically incorporated in this runtime exception's detail message.
+   *
+   * @param message the detail message (which is saved for later retrieval by the {@link #getMessage()} method).
+   * @param cause   the cause (which is saved for later retrieval by the {@link #getCause()} method).  (A <tt>null</tt>
+   *                value is permitted, and indicates that the cause is nonexistent or unknown.)
+   *
+   * @since 1.4
+   */
+  public BtpAuthenticationException(String message, Throwable cause) {
+    super(BtpErrorCode.F00_NotAcceptedError, message, cause);
+  }
+
+}
Index: ilp-plugin-grpc/src/main/java/org/interledger/plugin/lpiv2/grpc/AbstractGrpcPlugin.java
===================================================================
--- ilp-plugin-grpc/src/main/java/org/interledger/plugin/lpiv2/grpc/AbstractGrpcPlugin.java	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
+++ ilp-plugin-bpp-grpc/src/main/java/org/interledger/plugin/lpiv2/bpp/grpc/AbstractGrpcPlugin.java	(date 1545319046000)
@@ -1,4 +1,4 @@
-package org.interledger.plugin.lpiv2.grpc;
+package org.interledger.plugin.lpiv2.bpp.grpc;
 
 import org.interledger.encoding.asn.framework.CodecContext;
 import org.interledger.plugin.lpiv2.AbstractPlugin;
Index: ilp-plugin-connections/src/main/java/org/interledger/plugin/connections/BilateralConnection.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ilp-plugin-connections/src/main/java/org/interledger/plugin/connections/BilateralConnection.java	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
+++ ilp-plugin-connections/src/main/java/org/interledger/plugin/connections/BilateralConnection.java	(date 1546453498000)
@@ -1,14 +1,15 @@
 package org.interledger.plugin.connections;
 
 import org.interledger.core.InterledgerAddress;
-import org.interledger.plugin.connections.mux.BilateralReceiverMux;
-import org.interledger.plugin.connections.mux.BilateralSenderMux;
-
-import java.io.Closeable;
-import java.util.concurrent.CompletableFuture;
+import org.interledger.plugin.Connectable;
+import org.interledger.plugin.connections.settings.BilateralConnectionSettings;
+import org.interledger.plugin.lpiv2.Plugin;
 
 /**
- * <p>A Bilateral Connection is a network connection between two ILP nodes, allowing multiple Plugins to multiplex
+ * <p>A relationship between two bilateral peers that supports one or more Account relationships over a single
+ * network connection.</p>
+ *
+ * <p>Sometimes, these account relationships are multiplexed, and in other scenarios there is only a single account
  * over a single connection.</p>
  *
  * <p>In a multiplexed scenario, traffic will flow bidirectionally over the following components:</p>
@@ -18,9 +19,9 @@
  * │ Client  │                │       │                                │       │                │   Bob   │
  * │Plugin 1 │◁ ─Account 1─ ─▷│       │                                │       │◁─ ─Account 1─ ▷│Plugin 1 │
  * │         │                │       ├───────────┐        ┌───────────┤       │                │         │
- * └─────────┘                │Client │           │        │           │Client │                └─────────┘
- *                            │Plugin │ WebSocket │        │ WebSocket │Plugin │
- * ┌─────────┐                │ Conn  │  Client   │◁─HTTP─▷│  Server   │  Conn │                ┌─────────┐
+ * └─────────┘                │Client │           │        │           │Server │                └─────────┘
+ *                            │ Conn  │ WebSocket │        │ WebSocket │ Conn  │
+ * ┌─────────┐                │       │  Client   │◁─HTTP─▷│  Server   │       │                ┌─────────┐
  * │         │                │       │           │        │           │       │                │         │
  * │ Client  │                │       ├───────────┘        └───────────┤       │                │ Client  │
  * │Plugin 2 │◁ ─Account 2─ ─▷│       │                                │       │◁─ ─Account 2─ ▷│Plugin 2 │
@@ -32,15 +33,17 @@
  * <p>While the above illustrates a potential server-to-server configuration, the following diagram represents a more
  * typical client-server configuration:</p>
  *
+ * // TODO: Fix the diagram below to always show a Connection.
+ *
  * <pre>
  *                                                                     ┌───────┐                ┌─────────┐
  *                                                                     │       │                │         │
  *                                                                     │       │                │Plugin 1 │
  *                                                                     │       │◁─ ─Account 1─ ▷│         │
  * ┌─────────┐                        ┌───────────┐        ┌───────────┤       │                │         │
- * │         │                        │           │        │           │Client │                └─────────┘
- * │ Client  │                        │ WebSocket │        │ WebSocket │Plugin │
- * │Plugin 1 │◁ ─ ─ ─Account 1─ ─ ─ ─▷│  Client   │◁─HTTP─▷│  Server   │ Conn  │                ┌─────────┐
+ * │         │                        │           │        │           │Server │                └─────────┘
+ * │ Client  │                        │ WebSocket │        │ WebSocket │ Conn  │
+ * │Plugin 1 │◁ ─ ─ ─Account 1─ ─ ─ ─▷│  Client   │◁─HTTP─▷│  Server   │       │                ┌─────────┐
  * │         │                        │           │        │           │       │                │         │
  * └─────────┘                        └───────────┘        └───────────┤       │                │Plugin N │
  *                                                                     │       │◁─ ─Account N─ ▷│         │
@@ -68,86 +71,68 @@
  * <p>To reiterate, a Connector bridges two accounts, but multiple accounts can communicate over a single
  * connection.</p>
  *
- * @param <RM> A {@link BilateralReceiverMux} that is capable of de-multiplexing incoming packets.
- * @param <SM> A {@link BilateralSenderMux} that is capable of multiplexing outgoing packets.
+ * @param <CS> A {@link BilateralConnectionSettings} that defines all connection-level settings.
  *
  * @see "https://github.com/interledger/rfcs/tree/master/0023-bilateral-transfer-protocol"
  */
-public interface BilateralConnection<SM extends BilateralSenderMux, RM extends BilateralReceiverMux> extends
-    //BilateralReceiverMuxEventListener, BilateralSenderMuxEventListener,
-    Closeable {
+public interface BilateralConnection<CS extends BilateralConnectionSettings> extends Connectable {
+  //SM extends BilateralSenderMux, RM extends BilateralReceiverMux> extends Closeable {
 
   /**
-   * Accessor for the {@link InterledgerAddress} of the operator of this mux.
+   * Accessor for this connection's settings.
    *
-   * @return An instance of {@link InterledgerAddress}.
+   * @return An instance of {@link CS}.
    */
-  InterledgerAddress getOperatorAddress();
-
-//  /**
-//   * The {@link InterledgerAddress} of the remote node that this bilateral connection is connecting to.
-//   *
-//   * @return An instance of {@link InterledgerAddress}.
-//   */
-//  InterledgerAddress getRemoteAddress();
+  CS getConnectionSettings();
 
-  // TODO: Javadoc.
-  SM getBilateralSenderMux();
+  //PluginFactory getPluginFactory();
 
-  RM getBilateralReceiverMux();
-
-//  /**
-//   * Add a bilateral connection event listener to this connection..
-//   *
-//   * Care should be taken when adding multiple handlers to ensure that they perform distinct operations, otherwise
-//   * duplicate functionality might be unintentionally introduced.
-//   *
-//   * @param eventListenerId A {@link UUID} that uniquely identifies the listener to be added.
-//   * @param eventListener   A {@link BilateralConnectionEventListener} that can handle various types of events emitted
-//   *                        by this bilateral connection.
-//   *
-//   * @return A {@link UUID} representing the unique identifier of the listener, as seen by this connection.
-//   */
-//  void addConnectionEventListener(UUID eventListenerId, BilateralConnectionEventListener eventListener);
-//
-//  /**
-//   * Removes the event listener from the collection of listeners registered with this connection.
-//   *
-//   * @param eventListenerId A {@link UUID} representing the unique identifier of the listener to remove.
-//   */
-//  void removeConnectionEventListener(UUID eventListenerId);
+  /**
+   * Obtain the {@link Plugin} for the specified {@code accountAddress}.
+   *
+   * @param accountAddress The {@link InterledgerAddress} of the account to retrieve a plugin for.
+   *
+   * @return An instance of {@link Plugin}.
+   */
+  Plugin<?> getPlugin(InterledgerAddress accountAddress);
 
 //  /**
-//   * The role that the connection is playing with regard to the remote.
+//   * Accessor for the bilateral-sender associated with the indicated {@code sourceAccountAddress}.
+//   *
+//   * @param sourceAccountAddress The {@link InterledgerAddress} of the account this call is operating on behalf of
+//   *                             (i.e., the account address of the plugin that emitted this call).
+//   *
+//   * @return An optionally-present {@link BilateralSender}.
 //   */
-//  enum ConnectionRole {
-//    /**
-//     * This connection is a client connecting to a single remote server.
-//     */
-//    CLIENT,
+//  Optional<BilateralSender> getBilateralSender(InterledgerAddress sourceAccountAddress);
 //
-//    /**
-//     * This connection is a server, allowing many incoming mux from potentially distinct remote clients.
-//     */
-//    SERVER
-//  }
+//  /**
+//   * Accessor for the bilateral-sender associated with the indicated {@code sourceAccountAddress}.
+//   *
+//   * @param sourceAccountAddress The {@link InterledgerAddress} of the account this call is operating on behalf of
+//   *                             (i.e., the account address of the plugin that emitted this call).
+//   *
+//   * @return An optionally-present {@link BilateralReceiver}.
+//   */
+//  Optional<BilateralReceiver> getBilateralReceiver(InterledgerAddress sourceAccountAddress);
 
   /**
-   * <p>Connect to the remote peer.</p>
+   * Accessor for the plugin supporting the specified {@code accountAddress}.
+   *
+   * @param accountAddress The ILP address of the account to obtain a plugin for.
+   *
+   * @return An instance of {@link Plugin}.
    */
-  default CompletableFuture<Void> connect() {
-    return this.getBilateralSenderMux().connect().thenCompose(($) -> getBilateralReceiverMux().connect());
-  }
+  //Plugin<?> getPlugin(InterledgerAddress accountAddress);
 
-  /**
-   * Disconnect from the remote peer.
-   */
-  default CompletableFuture<Void> disconnect() {
-    return this.getBilateralSenderMux().disconnect().thenCompose(($) -> getBilateralReceiverMux().disconnect());
-  }
+  // TODO: Consider a provide mechanism?
+  //AccountProvider getAccountProvider(InterledgerAddress accountAddress);
+  // AccountProvider maybe has access to the plugin?
+
+//    // Provides account-level
+//    SM getBilateralSenderMux();
+//
+//    // TODO: Javadoc.
+//    RM getBilateralReceiverMux();
 
-  @Override
-  default void close() {
-    disconnect().join();
-  }
 }
Index: ilp-plugin-connections/src/main/java/org/interledger/plugin/connections/mux/BilateralReceiverMux.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ilp-plugin-connections/src/main/java/org/interledger/plugin/connections/mux/BilateralReceiverMux.java	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
+++ ilp-plugin-connections/src/main/java/org/interledger/plugin/connections/mux/BilateralReceiverMux.java	(date 1546449586000)
@@ -15,7 +15,10 @@
  *
  * <p>Because a MUX is meant to be utilized by a {@link BilateralConnection}, a MUX must always listen for events from
  * a {@link BilateralConnection} by implementing {@link BilateralConnectionEventListener}.</p>
+ *
+ * @deprecated Will be replaced by BilateralConnection.
  */
+@Deprecated
 public interface BilateralReceiverMux extends ConnectableReceiver {
 
   /**
@@ -28,9 +31,9 @@
    */
   Optional<BilateralReceiver> getBilateralReceiver(InterledgerAddress sourceAccountAddress);
 
-  void registerBilateralReceiver(InterledgerAddress accountAddress, BilateralReceiver sender);
+  //void registerBilateralReceiver(InterledgerAddress accountAddress, BilateralReceiver sender);
 
-  void unregisterBilateralReceiver(InterledgerAddress accountAddress);
+  //void unregisterBilateralReceiver(InterledgerAddress accountAddress);
 
   default CompletableFuture<Void> disconnectReceiver(final InterledgerAddress accountAddress) {
     Objects.requireNonNull(accountAddress);
Index: ilp-plugin-connections/src/main/java/org/interledger/plugin/connections/mux/AbstractBilateralComboMux.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ilp-plugin-connections/src/main/java/org/interledger/plugin/connections/mux/AbstractBilateralComboMux.java	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
+++ ilp-plugin-connections/src/main/java/org/interledger/plugin/connections/mux/AbstractBilateralComboMux.java	(date 1546453903000)
@@ -16,9 +16,12 @@
 
 /**
  * A combo sender/receiver MUX, for scenarios where the sender and receiver utilize the same underlying transport.
+ *
+ * @deprecated Replace with BilateralConnection.
  */
-public abstract class AbstractBilateralComboMux extends AbstractMux
-    implements BilateralSenderMux, BilateralReceiverMux {
+@Deprecated
+public abstract class AbstractBilateralComboMux extends AbstractMux implements BilateralSenderMux,
+    BilateralReceiverMux {
 
   protected final Logger logger = LoggerFactory.getLogger(this.getClass());
 
@@ -37,14 +40,14 @@
   }
 
   @Override
-  public void registerBilateralSender(final InterledgerAddress accountAddress, final BilateralSender sender) {
+  public void registerBilateralSender(final InterledgerAddress accountAddress, final BilateralSender bilateralSender) {
     Objects.requireNonNull(accountAddress);
-    Objects.requireNonNull(sender);
+    Objects.requireNonNull(bilateralSender);
 
     // If the plugin being added has not been added to this Connection, then register this Connection as an event-listener for the plugin.
-    if (this.bilateralSenders.put(accountAddress, sender) == null) {
-      bilateralSenders.put(accountAddress, sender);
-      sender.connect();
+    if (this.bilateralSenders.put(accountAddress, bilateralSender) == null) {
+      bilateralSenders.put(accountAddress, bilateralSender);
+      bilateralSender.connect();
     }
   }
 
Index: ilp-plugin-btp-springws/src/main/java/org/interledger/plugin/lpiv2/btp2/spring/ServerBtpPlugin.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ilp-plugin-btp-springws/src/main/java/org/interledger/plugin/lpiv2/btp2/spring/ServerBtpPlugin.java	(date 1546465716000)
+++ ilp-plugin-btp-springws/src/main/java/org/interledger/plugin/lpiv2/btp2/spring/ServerBtpPlugin.java	(date 1546465716000)
@@ -0,0 +1,152 @@
+package org.interledger.plugin.lpiv2.btp2.spring;
+
+import org.interledger.btp.BtpError;
+import org.interledger.btp.BtpMessage;
+import org.interledger.btp.BtpResponse;
+import org.interledger.btp.BtpResponsePacket;
+import org.interledger.btp.BtpSubProtocol;
+import org.interledger.btp.BtpSubProtocols;
+import org.interledger.btp.BtpTransfer;
+import org.interledger.core.InterledgerPreparePacket;
+import org.interledger.core.InterledgerResponsePacket;
+import org.interledger.core.asn.framework.InterledgerCodecContextFactory;
+import org.interledger.encoding.asn.framework.CodecContext;
+import org.interledger.plugin.BilateralReceiver.DataHandler;
+import org.interledger.plugin.lpiv2.PluginType;
+import org.interledger.plugin.lpiv2.btp2.BtpPluginSettings;
+import org.interledger.plugin.lpiv2.btp2.BtpReceiver;
+import org.interledger.plugin.lpiv2.btp2.BtpResponsePacketMapper;
+import org.interledger.plugin.lpiv2.btp2.BtpSender;
+import org.interledger.plugin.lpiv2.btp2.spring.converters.BinaryMessageToBtpPacketConverter;
+import org.interledger.plugin.lpiv2.btp2.spring.converters.BtpPacketToBinaryMessageConverter;
+import org.interledger.plugin.lpiv2.btp2.subprotocols.BtpSubProtocolHandlerRegistry;
+import org.interledger.plugin.lpiv2.btp2.subprotocols.ilp.IlpBtpConverter;
+
+import org.springframework.web.socket.WebSocketSession;
+
+import java.math.BigInteger;
+import java.util.Objects;
+import java.util.Optional;
+import java.util.concurrent.CompletableFuture;
+
+/**
+ * An extension of {@link AbstractBtpPlugin} for when the plugin is accepting incoming connections over a Websocket
+ * server.
+ */
+public class ServerBtpPlugin extends AbstractBtpPlugin<BtpPluginSettings> implements BtpSender, BtpReceiver {
+
+  public static final String PLUGIN_TYPE_STRING = "ClientWebsocketBtpPlugin";
+  public static final PluginType PLUGIN_TYPE = PluginType.of(PLUGIN_TYPE_STRING);
+
+  private final CodecContext ilpCodecContext;
+
+  private WebSocketSession webSocketSession;
+
+  /**
+   * Required-args Constructor.
+   */
+  public ServerBtpPlugin(
+      final BtpPluginSettings pluginSettings, final BinaryMessageToBtpPacketConverter binaryMessageToBtpPacketConverter,
+      final BtpPacketToBinaryMessageConverter btpPacketToBinaryMessageConverter,
+      final BtpSubProtocolHandlerRegistry btpSubProtocolHandlerRegistry,
+      final WebSocketSession webSocketSession
+  ) {
+    super(
+        pluginSettings, binaryMessageToBtpPacketConverter, btpPacketToBinaryMessageConverter,
+        btpSubProtocolHandlerRegistry
+    );
+
+    this.webSocketSession = Objects.requireNonNull(webSocketSession);
+
+    this.ilpCodecContext = InterledgerCodecContextFactory.oer();
+  }
+
+  @Override
+  public CompletableFuture<Void> doConnect() {
+    // TODO: Plugins should perhaps lose their connect functionality, and instead only a Connection should do that?
+    throw new RuntimeException("FIXME");
+//    // Because BTP client-plugins operate
+//    return this.connection.connect();
+  }
+
+  @Override
+  public CompletableFuture<Void> doDisconnect() {
+    // TODO: Plugins should perhaps lose their connect functionality, and instead only a Connection should do that?
+    throw new RuntimeException("FIXME");
+    //return connection.disconnect();
+  }
+
+  @Override
+  public Optional<DataHandler> getDataHandler() {
+    return Optional.empty();
+  }
+
+  // Send the preparePacket out over the webSocketSession using BTP encoding...
+  @Override
+  public CompletableFuture<Optional<InterledgerResponsePacket>> sendData(final InterledgerPreparePacket preparePacket) {
+    Objects.requireNonNull(preparePacket);
+
+    final BtpSubProtocols btpSubProtocols = new BtpSubProtocols();
+    final BtpSubProtocol ilpPrepare = IlpBtpConverter.toBtpSubprotocol(preparePacket, ilpCodecContext);
+    btpSubProtocols.add(ilpPrepare);
+
+    return this
+        /////////////////////////
+        // Send the BTP Message out over the WebSocket session.
+        /////////////////////////
+        .sendBtpMessage(
+            BtpMessage.builder()
+                .requestId(nextRequestId())
+                .subProtocols(btpSubProtocols)
+                .build()
+        )
+        /////////////////////////
+        // Expect a response, but handle the Connection-error condition as well...
+        /////////////////////////
+        .handle((btpResponsePacket, error) -> {
+          if (error != null) {
+            logger.error(error.getMessage(), error);
+            return Optional.empty();
+          } else {
+            // Convert the BtpResponse to the proper ILP response.
+            return new BtpResponsePacketMapper<Optional<InterledgerResponsePacket>>() {
+              @Override
+              protected Optional<InterledgerResponsePacket> handleBtpError(final BtpError btpError) {
+                Objects.requireNonNull(btpError);
+                logger.error("BTP Error while attempting to sendBtpMessage: {}", btpError);
+                return Optional.empty();
+              }
+
+              @Override
+              protected Optional<InterledgerResponsePacket> handleBtpResponse(final BtpResponse btpResponse) {
+                Objects.requireNonNull(btpResponse);
+                return Optional.of(IlpBtpConverter.toIlpPacket(btpResponse, ilpCodecContext));
+              }
+            }.map(btpResponsePacket);
+          }
+        });
+  }
+
+  /**
+   * Settle an outstanding ILP balance with a counterparty by transferring {@code amount} units of value from this ILP
+   * node to the counterparty of the account used by this plugin (this method correlates to <tt>sendMoney</tt> in the
+   * Javascript Connector).
+   *
+   * @param amount The amount of "money" to transfer.
+   */
+  @Override
+  public CompletableFuture<Void> sendMoney(BigInteger amount) {
+    throw new RuntimeException("FIXME");
+  }
+
+  @Override
+  public CompletableFuture<BtpResponsePacket> sendBtpMessage(BtpMessage btpMessage) {
+    return null;
+  }
+
+  @Override
+  public CompletableFuture<BtpResponsePacket> sendBtpTransfer(BtpTransfer btpTransfer) {
+    return null;
+  }
+
+}
Index: ilp-plugin-btp-springws/src/main/java/org/interledger/plugin/lpiv2/btp2/spring/connection/mux/ClientBtpWebsocketMux.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ilp-plugin-btp-springws/src/main/java/org/interledger/plugin/lpiv2/btp2/spring/connection/mux/ClientBtpWebsocketMux.java	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
+++ ilp-plugin-btp-springws/src/main/java/org/interledger/plugin/lpiv2/btp2/spring/connection/mux/ClientBtpWebsocketMux.java	(date 1546456178000)
@@ -5,11 +5,12 @@
 import org.interledger.btp.BtpMessage;
 import org.interledger.btp.BtpPacket;
 import org.interledger.btp.BtpResponse;
+import org.interledger.btp.BtpResponsePacket;
 import org.interledger.btp.BtpSession;
 import org.interledger.btp.BtpSessionCredentials;
 import org.interledger.btp.BtpSubProtocol.ContentType;
+import org.interledger.btp.BtpTransfer;
 import org.interledger.core.InterledgerAddress;
-import org.interledger.plugin.connections.mux.AbstractBilateralComboMux;
 import org.interledger.plugin.lpiv2.btp2.spring.BtpSessionUtils;
 import org.interledger.plugin.lpiv2.btp2.spring.converters.BinaryMessageToBtpPacketConverter;
 import org.interledger.plugin.lpiv2.btp2.spring.converters.BtpConversionException;
@@ -20,6 +21,7 @@
 import com.google.common.io.BaseEncoding;
 import org.springframework.web.socket.BinaryMessage;
 import org.springframework.web.socket.WebSocketSession;
+import org.springframework.web.socket.client.WebSocketClient;
 import org.springframework.web.socket.client.standard.StandardWebSocketClient;
 import org.springframework.web.socket.handler.BinaryWebSocketHandler;
 
@@ -30,12 +32,14 @@
 import java.util.concurrent.TimeUnit;
 
 /**
- * <p>An extension of {@link AbstractBilateralComboMux} that connects to a remote peer using Websockets and BTP Auth.
- * Incoming requests are forwarded to the proper registered plugin based upon the Auth settings.</p>
+ * <p>An extension of {@link AbstractBtpWebsocketComboMux} that connects to a remote peer using WebSockets and BTP
+ * Auth. Incoming requests are forwarded to the proper registered plugin based upon the Auth settings.</p>
  *
  * <p>Because this is a client-initiated Websocket connection, this MUX can only operate on a single ILP account, which
  * means there is only a single auth username/password allowed.</p>
+ * @deprecated Muxes are replaced by BilateralConnections.
  */
+@Deprecated
 public class ClientBtpWebsocketMux extends AbstractBtpWebsocketComboMux {
 
   // TODO: Consider moving to a settings? Note: Settings should have username/token, not a sessioncredentials.
@@ -134,7 +138,6 @@
     }
   }
 
-
   /**
    * Handle an incoming BinaryMessage from a Websocket, assuming it's a BTP Auth message. This implementation override
    * the default server-variant because the client must handle Auth differently from the Server.
@@ -199,4 +202,10 @@
     }
     return CompletableFuture.completedFuture(null);
   }
+
+  public WebSocketClient getWebSocketClient() {
+    return this.wsClient;
+  }
+
+
 }
\ No newline at end of file
Index: ilp-plugin-btp/src/main/java/org/interledger/plugin/lpiv2/btp2/subprotocols/auth/ServerAuthBtpSubprotocolHandler.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ilp-plugin-btp/src/main/java/org/interledger/plugin/lpiv2/btp2/subprotocols/auth/ServerAuthBtpSubprotocolHandler.java	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
+++ ilp-plugin-btp/src/main/java/org/interledger/plugin/lpiv2/btp2/subprotocols/auth/ServerAuthBtpSubprotocolHandler.java	(date 1545854029000)
@@ -93,26 +93,18 @@
                 String.format("Expected BTP SubProtocol with Id: %s", BTP_SUB_PROTOCOL_AUTH_TOKEN))
         );
 
-    final InterledgerAddress accountAddress = auth_username
-        // Assume multi-accounts.
-        .map(username -> btpMultiAuthenticator.usernameToIlpAddress(username))
-        // Assume single-accounts.
-        .orElseGet(() -> btpSingleAuthenticator.getAccountAddress());
-
     final BtpAuthenticator btpAuthenticator = auth_username
-        .map(username -> btpMultiAuthenticator.getBtpAuthenticator(accountAddress)
-            .orElseThrow(() -> new RuntimeException(
-                String.format("No BTP Authenticator for AccountAddress: %s", accountAddress))
-            ))
+        .map($ -> btpMultiAuthenticator.getBtpAuthenticator($)
+            .orElseThrow(() -> new BtpAuthenticationException("Invalid BTP Auth Credentials for " + auth_username))
+        )
         .orElse(btpSingleAuthenticator);
 
     // TODO: Put all of this into the CF.
-
     final boolean authenticated = btpAuthenticator.isValidAuthToken(auth_token);
     if (authenticated) {
       // SUCCESS! Respond with an empty Ack message...
       return CompletableFuture.supplyAsync(() -> {
-        this.storeAuthInBtpSession(btpSession, accountAddress, auth_token, auth_username);
+        this.storeAuthInBtpSession(btpSession, btpAuthenticator.getAccountAddress(), auth_token, auth_username);
         return Optional.of(ServerAuthBtpSubprotocolHandler.authResponse());
       });
     } else {
Index: ilp-plugin-btp-springws/src/main/java/org/interledger/plugin/lpiv2/btp2/spring/connection/AbstractSingleAccountBtpConnection.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ilp-plugin-btp-springws/src/main/java/org/interledger/plugin/lpiv2/btp2/spring/connection/AbstractSingleAccountBtpConnection.java	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
+++ ilp-plugin-btp-springws/src/main/java/org/interledger/plugin/lpiv2/btp2/spring/connection/AbstractSingleAccountBtpConnection.java	(date 1546458854000)
@@ -1,50 +1,124 @@
 package org.interledger.plugin.lpiv2.btp2.spring.connection;
 
-import org.interledger.core.InterledgerAddress;
-import org.interledger.plugin.connections.AbstractBilateralConnection;
+import org.interledger.btp.BtpMessage;
+import org.interledger.btp.BtpResponsePacket;
+import org.interledger.btp.BtpSessionCredentials;
+import org.interledger.btp.BtpTransfer;
 import org.interledger.plugin.connections.BilateralConnection;
-import org.interledger.plugin.connections.mux.AbstractBilateralComboMux;
+import org.interledger.plugin.connections.PluginFactory;
+import org.interledger.plugin.connections.settings.BilateralConnectionSettings;
+import org.interledger.plugin.lpiv2.btp2.spring.converters.BinaryMessageToBtpPacketConverter;
+import org.interledger.plugin.lpiv2.btp2.spring.converters.BtpPacketToBinaryMessageConverter;
+import org.interledger.plugin.lpiv2.btp2.subprotocols.BtpSubProtocolHandlerRegistry;
 
+import org.springframework.web.socket.BinaryMessage;
+import org.springframework.web.socket.WebSocketSession;
+
+import java.io.IOException;
 import java.util.Objects;
+import java.util.Optional;
+import java.util.concurrent.CompletableFuture;
 
 /**
  * A {@link BilateralConnection} that uses vanilla BTP specified in IL-RFC-23, meaning that this implementation only
  * supports a single account per Websocket connection (i.e., only the `auth_token` is considered when accepting an
  * incoming connection, thus limiting this implementation to a single Account).
  */
-public abstract class AbstractSingleAccountBtpConnection<T extends AbstractBilateralComboMux>
-    extends AbstractBilateralConnection<T, T> {
+public abstract class AbstractSingleAccountBtpConnection<CS extends SingleAccountConnectionSettings>
+    extends AbstractBtpConnection<CS> {
 
-  // TODO: Transition to BilateralConnectionSettings?
-  private final InterledgerAddress accountAddress;
+  private final BtpSessionCredentials btpSessionCredentials;
+
+  // Starts life as `empty`. There will only be a single connection in this MUX, and thus a single WS Session.
+  private Optional<WebSocketSession> webSocketSession = Optional.empty();
 
   /**
    * Required-args Constructor.
    *
-   * @param operatorAddress The {@link InterledgerAddress} of the operator of this connection.
-   * @param accountAddress  The {@link InterledgerAddress} of the account that this BTP connection supports.
-   * @param comboMux        An {@link AbstractBilateralComboMux} that provides both sender and receiver functionality.
+   * @param connectionSettings                A {@link BilateralConnectionSettings}.
+   * @param pluginFactory
+   * @param binaryMessageToBtpPacketConverter
+   * @param btpPacketToBinaryMessageConverter
+   * @param btpSubProtocolHandlerRegistry
    */
   public AbstractSingleAccountBtpConnection(
-      final InterledgerAddress operatorAddress,
-      final InterledgerAddress accountAddress,
-      final T comboMux
+      CS connectionSettings,
+      PluginFactory pluginFactory,
+      BinaryMessageToBtpPacketConverter binaryMessageToBtpPacketConverter,
+      BtpPacketToBinaryMessageConverter btpPacketToBinaryMessageConverter,
+      BtpSubProtocolHandlerRegistry btpSubProtocolHandlerRegistry
   ) {
-    super(operatorAddress, comboMux, comboMux);
-    this.accountAddress = Objects.requireNonNull(accountAddress);
+    super(
+        connectionSettings, pluginFactory, binaryMessageToBtpPacketConverter, btpPacketToBinaryMessageConverter,
+        btpSubProtocolHandlerRegistry
+    );
+
+    this.btpSessionCredentials = BtpSessionCredentials.builder()
+        .authUsername(Optional.empty())
+        .authToken(getConnectionSettings().getAuthToken())
+        .build();
+  }
+
+  /**
+   * Converts {@code btpMessage} into the proper binary format and then sends the payload out over the websocket,
+   * waiting for a response.
+   */
+  @Override
+  public CompletableFuture<BtpResponsePacket> sendBtpMessage(final BtpMessage btpMessage) {
+    Objects.requireNonNull(btpMessage);
+
+    // Translate the btpMessage to a BinaryMessage, and send out using the WebSocketSession.
+    return this.webSocketSession
+        .map(wss -> {
+          final BinaryMessage binaryMessage = this.btpPacketToBinaryMessageConverter.convert(btpMessage);
+          final long requestId = nextRequestId();
+          return this.sendMessageWithPendingRepsonse(requestId, wss, binaryMessage)
+              .handle((response, error) -> {
+                if (error != null) {
+                  // the pending response timed out or otherwise had a problem...
+                  throw new RuntimeException(error.getMessage(), error);
+                } else {
+                  // Might be an error or a response`
+                  return response;
+                }
+              });
+        }).orElseThrow(() -> new RuntimeException("No WebSocket session!"));
   }
 
-  public InterledgerAddress getAccountAddress() {
-    return accountAddress;
+  @Override
+  public CompletableFuture<BtpResponsePacket> sendBtpTransfer(BtpTransfer btpTransfer) {
+    throw new RuntimeException("FIXME!");
+    //return CompletableFuture.completedFuture(null);
   }
 
   /**
-   * For a BTP connections, we know the sender and receiver will be the same instance (i.e., a {@link
-   * AbstractBilateralComboMux}, so we can return either the sender or receiver to conform to this interface.
-   *
-   * @return
+   * Perform the logic of disconnecting the actual transport(s) supporting this bilateral connection.
    */
-  T getComboMux() {
-    return this.getBilateralSenderMux();
+  @Override
+  public CompletableFuture<Void> doDisconnectTransport() {
+    return CompletableFuture.supplyAsync(() -> {
+      synchronized (this) {
+        // Block on the Disconnect so that only one thread can operate at a time...
+        webSocketSession.ifPresent(webSocketSession -> {
+          try {
+            webSocketSession.close();
+            this.webSocketSession = null;
+
+            // TODO: Attempt to disconnect the WebsocketClient using stop()
+          } catch (IOException e) {
+            throw new RuntimeException(e);
+          }
+        });
+      }
+      return null;
+    });
+  }
+
+  protected BtpSessionCredentials getBtpSessionCredentials() {
+    return btpSessionCredentials;
+  }
+
+  protected Optional<WebSocketSession> getWebSocketSession() {
+    return webSocketSession;
   }
 }
Index: ilp-plugin-btp-springws/src/main/java/org/interledger/plugin/lpiv2/btp2/spring/BtpSocketHandler.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ilp-plugin-btp-springws/src/main/java/org/interledger/plugin/lpiv2/btp2/spring/BtpSocketHandler.java	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
+++ ilp-plugin-btp-springws/src/main/java/org/interledger/plugin/lpiv2/btp2/spring/BtpSocketHandler.java	(date 1546465103000)
@@ -28,8 +28,8 @@
 //  // getting connected to the right plugin only after the BTP Auth subprotocol has completed successfully.
 //  //
 //  // Key: auth_username that this plugin requires.
-//  // Value: The actual ServerWebsocketBtpPlugin
-//  private Map<String, ServerWebsocketBtpPlugin> registeredServerPlugins;
+//  // Value: The actual ServerBtpPlugin
+//  private Map<String, ServerBtpPlugin> registeredServerPlugins;
 //  // Once the Auth SubProtocol completes, an Account address for a plugin will be added to this set to indicate that this
 //  // plugin is currently authenticated.
 //  private Set<InterledgerAddress> authenticatedPluginAccounts;
@@ -115,18 +115,18 @@
 //
 //  // Moved!
 //  /**
-//   * <p>Register a {@link ServerWebsocketBtpPlugin} with this class. The BTP Auth SubProtocol will, if successfully
+//   * <p>Register a {@link ServerBtpPlugin} with this class. The BTP Auth SubProtocol will, if successfully
 //   * completed, associate a WebSocketSession to a registered plugin using the {@code authUserName} as a correlation
 //   * key.</p>
 //   *
 //   * @param authUserName           A {@link String} that uniquely identifies the principal of a BTP session. This value
 //   *                               is expected to be passed into the server via the `auth_username` using the BTP Auth
 //   *                               SubProtocol.
-//   * @param authenticatedBtpPlugin A {@link ServerWebsocketBtpPlugin} that should correlate to a particular BTP
+//   * @param authenticatedBtpPlugin A {@link ServerBtpPlugin} that should correlate to a particular BTP
 //   *                               Session.
 //   */
 //  public void registerPlugin(
-//      final String authUserName, final ServerWebsocketBtpPlugin authenticatedBtpPlugin
+//      final String authUserName, final ServerBtpPlugin authenticatedBtpPlugin
 //  ) {
 //    Objects.requireNonNull(authUserName);
 //    Objects.requireNonNull(authenticatedBtpPlugin);
@@ -180,16 +180,16 @@
 //  @Override
 //  public void onConnect(PluginConnectedEvent event) {
 //    // If a plugin connects, it means that auth succeeded, so move that plugin into the authenticated Map.
-//    this.authenticatedPluginAccounts.add(event.getPlugin().getPluginSettings().getPeerAccountAddress());
+//    this.authenticatedPluginAccounts.add(event.getPlugin().getPluginSettings().getAccountAddress());
 //  }
 //
 //  @Override
 //  public void onDisconnect(PluginDisconnectedEvent event) {
-//    this.authenticatedPluginAccounts.remove(event.getPlugin().getPluginSettings().getPeerAccountAddress());
+//    this.authenticatedPluginAccounts.remove(event.getPlugin().getPluginSettings().getAccountAddress());
 //  }
 //
 //  @Override
 //  public void onError(PluginErrorEvent event) {
-//    this.authenticatedPluginAccounts.remove(event.getPlugin().getPluginSettings().getPeerAccountAddress());
+//    this.authenticatedPluginAccounts.remove(event.getPlugin().getPluginSettings().getAccountAddress());
 //  }
 }
\ No newline at end of file
Index: ilp-plugin-core/src/test/java/org/interledger/plugin/lpiv2/TestHelpers.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ilp-plugin-core/src/test/java/org/interledger/plugin/lpiv2/TestHelpers.java	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
+++ ilp-plugin-core/src/test/java/org/interledger/plugin/lpiv2/TestHelpers.java	(date 1545669025000)
@@ -37,7 +37,7 @@
        * The ILP Address for remote peer account this Plugin is connecting to...
        */
       @Override
-      public InterledgerAddress getPeerAccountAddress() {
+      public InterledgerAddress getAccountAddress() {
         return PEER_ACCOUNT;
       }
 
Index: ilp-plugin-core/src/main/java/org/interledger/plugin/lpiv2/PluginSettings.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ilp-plugin-core/src/main/java/org/interledger/plugin/lpiv2/PluginSettings.java	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
+++ ilp-plugin-core/src/main/java/org/interledger/plugin/lpiv2/PluginSettings.java	(date 1545669025000)
@@ -21,9 +21,9 @@
   PluginType getPluginType();
 
   /**
-   * The ILP Address for remote peer account this Plugin is connecting to...
+   * The ILP Address for account this Plugin is operating upon...
    */
-  InterledgerAddress getPeerAccountAddress();
+  InterledgerAddress getAccountAddress();
 
   /**
    * The ILP address of the ILP Node operating this plugin.
Index: ilp-plugin-grpc/src/main/java/org/interledger/plugin/mux/grpc/bpp/GrinterledgerBppServer.java
===================================================================
--- ilp-plugin-grpc/src/main/java/org/interledger/plugin/mux/grpc/bpp/GrinterledgerBppServer.java	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
+++ ilp-plugin-bpp-grpc/src/main/java/org/interledger/plugin/lpiv2/bpp/grpc/connection/mux/GrpcBppServerMux.java	(date 1545327767000)
@@ -1,22 +1,23 @@
-package org.interledger.plugin.mux.grpc.bpp;
+package org.interledger.plugin.lpiv2.bpp.grpc.connection.mux;
 
+import org.interledger.bpp.grpc.BppGrpc;
+import org.interledger.bpp.grpc.BppProto.BppPrepare;
+import org.interledger.bpp.grpc.BppProto.BppResponse;
+import org.interledger.core.InterledgerAddress;
 import org.interledger.core.InterledgerFulfillPacket;
 import org.interledger.core.InterledgerPreparePacket;
 import org.interledger.core.InterledgerRejectPacket;
 import org.interledger.core.InterledgerResponsePacket;
 import org.interledger.core.InterledgerResponsePacketHandler;
 import org.interledger.encoding.asn.framework.CodecContext;
-import org.interledger.grpc.bpp.GrinterledgerBppGrpc;
-import org.interledger.grpc.bpp.GrinterledgerBppProto.GrinterledgerBppPrepare;
-import org.interledger.grpc.bpp.GrinterledgerBppProto.GrinterledgerBppResponse;
-import org.interledger.plugin.lpiv2.Plugin;
+import org.interledger.plugin.BilateralReceiver;
+import org.interledger.plugin.BilateralReceiver.DataHandler;
 import org.interledger.plugin.connections.mux.AbstractBilateralReceiverMux;
 import org.interledger.plugin.connections.mux.BilateralReceiverMux;
 
 import com.google.protobuf.ByteString;
 import io.grpc.Context;
 import io.grpc.Server;
-import io.grpc.ServerBuilder;
 import io.grpc.Status;
 import io.grpc.stub.StreamObserver;
 import org.slf4j.Logger;
@@ -24,38 +25,54 @@
 
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
-import java.io.IOException;
 import java.util.Objects;
 import java.util.concurrent.CompletableFuture;
 
 /**
- * Server that manages startup/shutdown of a gRPC server supporting the gRPC Interledger Push Protocol.
+ * A Bilateral Receiver MUX that listens to a gRPC server that supports BPP. This implementation will inspect the BPP
+ * packet and connect the incoming request to a register {@link BilateralReceiver}.
  */
-public class GrinterledgerBppServer {//extends AbstractBilateralReceiverMux implements BilateralReceiverMux {
+public class GrpcBppServerMux extends AbstractBilateralReceiverMux implements BilateralReceiverMux {
+
+  private final Logger logger = LoggerFactory.getLogger(this.getClass());
 
-//  private final Logger logger = LoggerFactory.getLogger(this.getClass());
-//
-//  private final CodecContext ilpCodecContext;
-//  private final Plugin<?> plugin;
-//  private Server server;
-//
-//  public GrinterledgerBppServer(final CodecContext ilpCodecContext, Plugin<?> plugin) {
+  //private final int grpcServerPort;
+  private final CodecContext ilpCodecContext;
+  private Server server;
+
+//  public GrpcBppServerMux(final CodecContext ilpCodecContext, final Plugin<?> plugin, final int grpcServerPort) {
 //    this.ilpCodecContext = Objects.requireNonNull(ilpCodecContext);
 //    this.plugin = Objects.requireNonNull(plugin);
+//    this.grpcServerPort = grpcServerPort;
 //  }
-//
-//  private void start() throws IOException {
-//    /* The port on which the server should run */
-//    int port = 50051;
-//    server = ServerBuilder.forPort(port)
-//        .addService(new GrinterledgerBppImpl(ilpCodecContext, plugin))
+
+  public GrpcBppServerMux(final CodecContext ilpCodecContext, final Server server) {
+    this.ilpCodecContext = Objects.requireNonNull(ilpCodecContext);
+    this.server = Objects.requireNonNull(server);
+
+    // Connect gRPC to this Mux...
+    final BppImpl bppImpl = new BppImpl(ilpCodecContext, this);
+    server.getMutableServices().add(bppImpl.bindService());
+
+    // TODO: Add this to the server definition in the Connector, and then remove from here...
+    //    Runtime.getRuntime().addShutdownHook(new Thread(() -> {
+//      // Use stderr here since the logger may have been reset by its JVM shutdown hook.
+//      System.err.println("*** shutting down gRPC server since JVM is shutting down");
+//      disconnect();
+//      System.err.println("*** server shut down");
+//    }));
+  }
+
+  //  private void start() throws IOException {
+//    server = ServerBuilder.forPort(grpcServerPort)
+//        .addService(new BppImpl(ilpCodecContext, plugin))
 //        .build()
 //        .start();
-//    logger.info("Server started, listening on " + port);
+//    logger.info("Server started, listening on " + grpcServerPort);
 //    Runtime.getRuntime().addShutdownHook(new Thread(() -> {
 //      // Use stderr here since the logger may have been reset by its JVM shutdown hook.
 //      System.err.println("*** shutting down gRPC server since JVM is shutting down");
-//      GrinterledgerBppServer.this.stop();
+//      GrpcBppServerMux.this.stop();
 //      System.err.println("*** server shut down");
 //    }));
 //  }
@@ -65,106 +82,121 @@
 //      server.shutdown();
 //    }
 //  }
-//
-//  @Override
-//  public CompletableFuture<Void> doConnect() {
-//    return CompletableFuture.completedFuture(null);
-//
-//  }
-//
-//  @Override
-//  public CompletableFuture<Void> doDisconnect() {
-//    return CompletableFuture.completedFuture(null);
-//  }
-//
-//  static class GrinterledgerBppImpl extends GrinterledgerBppGrpc.GrinterledgerBppImplBase {
-//
-//    private final CodecContext ilpCodecContext;
-//    // TODO: Narrow this type?
-//    private final Plugin<?> plugin;
-//
-//    public GrinterledgerBppImpl(final CodecContext ilpCodecContext, Plugin<?> plugin) {
-//      this.ilpCodecContext = Objects.requireNonNull(ilpCodecContext);
-//      this.plugin = plugin;
-//    }
-//
-//    /**
-//     * <pre>
-//     * Sends a PreparePacket to the Bilateral Peer
-//     * </pre>
-//     *
-//     * @param request
-//     * @param responseObserver
-//     */
-//    @Override
-//    public void send(
-//        final GrinterledgerBppPrepare request, final StreamObserver<GrinterledgerBppResponse> responseObserver
-//    ) {
-//
-//      if (Context.current().isCancelled()) {
-//        responseObserver.onError(Status.CANCELLED.withDescription("Cancelled by client").asRuntimeException());
-//        return;
-//      }
-//
-//      try {
-//        // Convert the request bytes into a Prepare Packet.
-//        final ByteArrayOutputStream out = new ByteArrayOutputStream();
-//        request.getPreparePacketBytes().writeTo(out);
-//        final InterledgerPreparePacket preparePacket = ilpCodecContext
-//            .read(InterledgerPreparePacket.class, new ByteArrayInputStream(out.toByteArray()));
-//
-//        plugin.safeGetDataSender().sendData(preparePacket)
-//            .whenComplete((ilpResponse, error) -> {
-//              if (error != null) {
-//                responseObserver.onError(error);
-//              } else {
-//
-//                // Handle a valid response...
-//                new InterledgerResponsePacketHandler() {
-//                  @Override
-//                  protected void handleFulfillPacket(InterledgerFulfillPacket interledgerFulfillPacket) {
-//                    // Convert to gRPC Response
-//                    try {
-//                      responseObserver.onNext(toSendDataResponse(interledgerFulfillPacket));
-//                      responseObserver.onCompleted();
-//                    } catch (IOException e) {
-//                      responseObserver.onError(e);
-//                    }
-//                  }
-//
-//                  @Override
-//                  protected void handleRejectPacket(InterledgerRejectPacket interledgerRejectPacket) {
-//                    try {
-//                      responseObserver.onNext(toSendDataResponse(interledgerRejectPacket));
-//                      responseObserver.onCompleted();
-//                    } catch (IOException e) {
-//                      responseObserver.onError(e);
-//                    }
-//                  }
-//
-//                  @Override
-//                  protected void handleExpiredPacket() {
-//                    // TODO: Return an error in gRPC?
-//                    responseObserver.onCompleted();
-//                  }
-//                }.handle(ilpResponse);
-//              }
-//
-//            });
-//      } catch (Exception e) {
-//        responseObserver.onError(e);
-//      }
-//    }
-//
-//    private GrinterledgerBppResponse toSendDataResponse(final InterledgerResponsePacket responsePacket)
-//        throws IOException {
-//      Objects.requireNonNull(responsePacket);
-//
-//      final ByteArrayOutputStream out = new ByteArrayOutputStream();
-//      ilpCodecContext.write(responsePacket, out);
-//      return GrinterledgerBppResponse.newBuilder()
-//          .setResponsePacketBytes(ByteString.readFrom(new ByteArrayInputStream(out.toByteArray())))
-//          .build();
-//    }
-//  }
+
+  /**
+   * Perform the logic of connecting the actual transport underneath this MUX.
+   */
+  @Override
+  public CompletableFuture<Void> doConnectTransport() {
+    // No-op because the grpc server listens for connections at startup, but doesn't connect on-demand.
+    return CompletableFuture.completedFuture(null);
+  }
+
+  /**
+   * Perform the logic of disconnecting the actual transport underneath this MUX.
+   */
+  @Override
+  public CompletableFuture<Void> doDisconnectTransport() {
+    // No-op because the grpc server listens for connections at startup, but doesn't connect on-demand.
+    return CompletableFuture.completedFuture(null);
+  }
+
+  /**
+   * An implementation of {@link BppImpl} that connects gRPC Server to a {@link BilateralReceiver}. Note that BPP will
+   * utilize a completely different gRPC transport channel for bilateral `send` operations, so despite this
+   * implementation's definition of `send`, this implementation is actually is implementing the receiving side of the
+   * RPC `send` operation.
+   */
+  static class BppImpl extends BppGrpc.BppImplBase {
+
+    private final CodecContext ilpCodecContext;
+    private final BilateralReceiverMux bilateralReceiverMux;
+
+    public BppImpl(final CodecContext ilpCodecContext, final BilateralReceiverMux bilateralReceiverMux) {
+      this.ilpCodecContext = Objects.requireNonNull(ilpCodecContext);
+      this.bilateralReceiverMux = Objects.requireNonNull(bilateralReceiverMux);
+    }
+
+    /**
+     * <p>Accepts an incoming Prepare bppPrepare, processes it, and then returns a response to the caller via the
+     * supplied {@code responseObserver}.</p>
+     *
+     * @param bppPrepare
+     * @param responseObserver
+     */
+    @Override
+    public void send(final BppPrepare bppPrepare, final StreamObserver<BppResponse> responseObserver) {
+      if (Context.current().isCancelled()) {
+        responseObserver.onError(Status.CANCELLED.withDescription("Cancelled by client").asRuntimeException());
+        return;
+      }
+
+      final InterledgerAddress accountAddress = InterledgerAddress.of(bppPrepare.getAccountAddress());
+
+      try {
+        // Convert the bppPrepare bytes into a Prepare Packet.
+        final ByteArrayOutputStream out = new ByteArrayOutputStream();
+        bppPrepare.getPreparePacketBytes().writeTo(out);
+
+        final InterledgerPreparePacket preparePacket = ilpCodecContext
+            .read(InterledgerPreparePacket.class, new ByteArrayInputStream(out.toByteArray()));
+
+        final DataHandler dataHandler = bilateralReceiverMux
+            .getBilateralReceiver(accountAddress)
+            .orElseThrow(() -> new RuntimeException(String.format(
+                "No BilateralReceiver registered with BilateralReceiverMux for Account: %s", accountAddress
+            )))
+            .getDataHandler()
+            .orElseThrow(() -> new RuntimeException("No DataHandler registered with BppImpl!"));
+
+        dataHandler.handleIncomingData(preparePacket)
+            .whenComplete((ilpResponse, error) -> {
+              // Push the response back to the grpc responseObserver so it will go back to the requestor...
+              if (error != null) {
+                responseObserver.onError(error);
+              } else {
+                // Handle a valid response...
+                new InterledgerResponsePacketHandler() {
+                  @Override
+                  protected void handleFulfillPacket(final InterledgerFulfillPacket interledgerFulfillPacket) {
+                    Objects.requireNonNull(interledgerFulfillPacket);
+                    responseObserver
+                        .onNext(toSendDataResponse(accountAddress, interledgerFulfillPacket));
+                    responseObserver.onCompleted();
+                  }
+
+                  @Override
+                  protected void handleRejectPacket(final InterledgerRejectPacket interledgerRejectPacket) {
+                    Objects.requireNonNull(interledgerRejectPacket);
+                    responseObserver
+                        .onNext(toSendDataResponse(accountAddress, interledgerRejectPacket));
+                    responseObserver.onCompleted();
+                  }
+
+                  @Override
+                  protected void handleExpiredPacket() {
+                    // TODO: Return an error in gRPC?
+                    responseObserver.onCompleted();
+                  }
+                }.handle(ilpResponse);
+              }
+            });
+      } catch (Exception e) {
+        responseObserver.onError(e);
+        responseObserver.onCompleted();
+      }
+    }
+
+    private BppResponse toSendDataResponse(
+        final InterledgerAddress accountAddress, final InterledgerResponsePacket responsePacket
+    ) {
+      Objects.requireNonNull(responsePacket);
+
+      final ByteString byteString = GrpcIOStreamUtils.toByteString(ilpCodecContext, responsePacket);
+      return BppResponse.newBuilder()
+          .setAccountAddress(accountAddress.getValue())
+          .setResponsePacketBytes(byteString)
+          .build();
+    }
+  }
 }
Index: ilp-plugin-core/src/main/java/org/interledger/plugin/BilateralSender.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ilp-plugin-core/src/main/java/org/interledger/plugin/BilateralSender.java	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
+++ ilp-plugin-core/src/main/java/org/interledger/plugin/BilateralSender.java	(date 1546395135000)
@@ -1,5 +1,7 @@
 package org.interledger.plugin;
 
+import org.interledger.core.InterledgerAddress;
+import org.interledger.core.InterledgerCondition;
 import org.interledger.core.InterledgerFulfillPacket;
 import org.interledger.core.InterledgerPreparePacket;
 import org.interledger.core.InterledgerRejectPacket;
@@ -9,6 +11,9 @@
 import org.interledger.plugin.BilateralReceiver.DataHandler;
 
 import java.math.BigInteger;
+import java.time.Instant;
+import java.util.Base64;
+import java.util.Objects;
 import java.util.Optional;
 import java.util.concurrent.CompletableFuture;
 
@@ -36,6 +41,9 @@
  */
 public interface BilateralSender extends Connectable {
 
+  InterledgerCondition PING_PROTOCOL_CONDITION =
+      InterledgerCondition.of(Base64.getDecoder().decode("Zmh6rfhivXdsj8GLjp+OIAiXFIVu4jOzkCpZHQ1fKSU="));
+
   Optional<DataSender> getDataSender();
 
   /**
@@ -64,6 +72,26 @@
         .orElseThrow(() -> new RuntimeException("You MUST register a MoneySender before accessing it!"));
   }
 
+  /**
+   * Send a 0-value payment to the destination and expect an ILP fulfillment, which demonstrates this sender has
+   * send-data connectivity to the indicated destination address.
+   *
+   * @param destinationAddress
+   */
+  default CompletableFuture<Optional<InterledgerResponsePacket>> ping(final InterledgerAddress destinationAddress) {
+    Objects.requireNonNull(destinationAddress);
+
+    final InterledgerPreparePacket pingPacket = InterledgerPreparePacket.builder()
+        .executionCondition(PING_PROTOCOL_CONDITION)
+        // TODO: Make this timeout configurable!
+        .expiresAt(Instant.now().plusSeconds(30))
+        .amount(BigInteger.ZERO)
+        .destination(destinationAddress)
+        .build();
+
+    return this.safeGetDataSender().sendData(pingPacket);
+  }
+
   /**
    * Defines how to send data to the other side of a bilateral connection (i.e., the other party * operating a single
    * account in tandem with the operator of this sender).
Index: ilp-plugin-grpc/src/main/java/org/interledger/plugin/mux/grpc/bpp/GrinterledgerBppClient.java
===================================================================
--- ilp-plugin-grpc/src/main/java/org/interledger/plugin/mux/grpc/bpp/GrinterledgerBppClient.java	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
+++ ilp-plugin-bpp-grpc/src/main/java/org/interledger/plugin/lpiv2/bpp/grpc/connection/mux/GrpcBppClientMux.java	(date 1545321751000)
@@ -1,14 +1,13 @@
-package org.interledger.plugin.mux.grpc.bpp;
+package org.interledger.plugin.lpiv2.bpp.grpc.connection.mux;
 
+import org.interledger.bpp.grpc.BppGrpc;
+import org.interledger.bpp.grpc.BppProto.BppPrepare;
+import org.interledger.bpp.grpc.BppProto.BppResponse;
 import org.interledger.core.InterledgerPreparePacket;
 import org.interledger.core.InterledgerResponsePacket;
 import org.interledger.encoding.asn.framework.CodecContext;
-import org.interledger.grpc.bpp.GrinterledgerBppGrpc;
-import org.interledger.grpc.bpp.GrinterledgerBppProto.GrinterledgerBppPrepare;
-import org.interledger.grpc.bpp.GrinterledgerBppProto.GrinterledgerBppResponse;
 import org.interledger.plugin.connections.mux.AbstractBilateralSenderMux;
 import org.interledger.plugin.connections.mux.BilateralSenderMux;
-import org.interledger.plugin.mux.grpc.GrpcIOStreamUtils;
 
 import com.spotify.futures.CompletableFuturesExtra;
 import io.grpc.Channel;
@@ -27,106 +26,103 @@
 
 /**
  * A simple client that sends ILPv4 Prepare-packets to a remote peer, and expects either a fulfill or a reject as a
- * response.
+ * response. This provides the <tt>client-side</tt> of a Bilateral Push Protocol (BPP) connection.
  */
-public class GrinterledgerBppClient{ // {extends AbstractBilateralSenderMux implements BilateralSenderMux {
+public class GrpcBppClientMux extends AbstractBilateralSenderMux implements BilateralSenderMux {
+
+  final GrpcBppClientMuxSettings settings;
+  private final Logger logger = LoggerFactory.getLogger(this.getClass());
+  private final CodecContext ilpCodecContext;
+  private final ManagedChannel channel;
+  private final BppGrpc.BppFutureStub nonblockingStub;
+
+  /**
+   * Construct a client connecting to server specified in {@code settings}.
+   */
+  public GrpcBppClientMux(final GrpcBppClientMuxSettings settings, final CodecContext ilpCodecContext) {
+    this(settings, ilpCodecContext, ManagedChannelBuilder.forAddress(settings.host(), settings.port())
+        // Channels are secure by default (via SSL/TLS), but in dev-mode, we disable TLS to avoid needing certificates.
+        //.usePlaintext()
+        .build());
+  }
+
+  /**
+   * Construct a client connecting to server using an existing channel.
+   */
+  GrpcBppClientMux(
+      final GrpcBppClientMuxSettings settings, final CodecContext ilpCodecContext, final ManagedChannel channel
+  ) {
+    this.settings = Objects.requireNonNull(settings);
+    this.ilpCodecContext = Objects.requireNonNull(ilpCodecContext);
+    this.channel = Objects.requireNonNull(channel);
+    this.nonblockingStub = BppGrpc.newFutureStub(channel);
+  }
+
+  /**
+   * Perform the logic of connecting the actual transport underneath this MUX.
+   */
+  @Override
+  public CompletableFuture<Void> doConnectTransport() {
+    return CompletableFuture.runAsync(() -> {
+      // TODO: How do we reconnect the Channel?
+
+      // If the channel shuts down, then disconnect this client.
+      this.channel.notifyWhenStateChanged(ConnectivityState.SHUTDOWN, () -> doDisconnectTransport());
+    });
+  }
+
+  /**
+   * Perform the logic of disconnecting the actual transport underneath this MUX.
+   */
+  @Override
+  public CompletableFuture<Void> doDisconnectTransport() {
+    return CompletableFuture.runAsync(this::shutdown);
+  }
 
-//  private final Logger logger = LoggerFactory.getLogger(this.getClass());
-//  private final CodecContext ilpCodecContext;
-//  private final ManagedChannel channel;
-//  private final GrinterledgerBppGrpc.GrinterledgerBppFutureStub nonblockingStub;
-//
-//  // TODO: Make Configurable.
-//  //@Option(name="--deadline_ms", usage="Deadline in milliseconds.")
-//  private int deadlineMs = 20 * 1000;
-//
-//  /**
-//   * Construct client connecting to HelloWorld server at {@code host:port}.
-//   */
-//  public GrinterledgerBppClient(final String host, final int port, final CodecContext ilpCodecContext) {
-//    this(ilpCodecContext, ManagedChannelBuilder.forAddress(host, port)
-//        // TODO: Enable/Disable via configuration.
-//        // Channels are secure by default (via SSL/TLS), but in dev-mode, we disable TLS to avoid needing certificates.
-//        //.usePlaintext()
-//        .build());
-//  }
-//
-//  /**
-//   * Construct client for accessing HelloWorld server using the existing channel.
-//   */
-//  GrinterledgerBppClient(final CodecContext ilpCodecContext, final ManagedChannel channel) {
-//    this.ilpCodecContext = Objects.requireNonNull(ilpCodecContext);
-//    this.channel = Objects.requireNonNull(channel);
-//    //this.blockingStub = PinterledgerGrpc.newBlockingStub(channel);
-//    this.nonblockingStub = GrinterledgerBppGrpc.newFutureStub(channel);
-//  }
-//
-//  @Override
-//  public CompletableFuture<Void> doConnectSenderMux() {
-//
-//    return CompletableFuture.runAsync(() -> {
-//
-//      // Connect the sender to the remote server....
-//      // TODO: How do we reconnect the Channel?
-//
-//      // If the channel shuts down, then disconnect this client.
-//      this.channel.notifyWhenStateChanged(ConnectivityState.SHUTDOWN, () -> shutdown());
-//    });
-//  }
-//
-//  /**
-//   * Perform the logic of disconnecting from the remote peer.
-//   */
-//  @Override
-//  public CompletableFuture<Void> doDisconnect() {
-//    return CompletableFuture.runAsync(this::shutdown);
-//  }
-//
-//  public void shutdown() {
-//    try {
-//      channel.shutdown().awaitTermination(5, TimeUnit.SECONDS);
-//    } catch (InterruptedException e) {
-//      throw new RuntimeException(e.getMessage(), e);
-//    }
-//  }
-//
-//  /**
-//   * Send a Prepare packet to the gRPC server this client is connected to.
-//   */
-//  public CompletableFuture<Optional<InterledgerResponsePacket>> send(final InterledgerPreparePacket preparePacket) {
-//    logger.debug("Sending preparePacket: {}", preparePacket);
-//
-//    final GrinterledgerBppPrepare request = GrinterledgerBppPrepare.newBuilder()
-//        .setPreparePacketBytes(GrpcIOStreamUtils.toByteString(ilpCodecContext, preparePacket))
-//        .build();
-//
-//    try {
-//      return CompletableFuturesExtra.toCompletableFuture(
-//          nonblockingStub.withDeadlineAfter(deadlineMs, TimeUnit.MILLISECONDS).send(request)
-//      )
-//          .thenApply(GrinterledgerBppResponse::getResponsePacketBytes)
-//          .thenApply(responsePacketBytes -> {
-//            final InterledgerResponsePacket packet = (InterledgerResponsePacket) GrpcIOStreamUtils
-//                .fromByteString(ilpCodecContext, responsePacketBytes);
-//            return Optional.ofNullable(packet);
-//          }).exceptionally(err -> {
-//            // If there's an error, then return empty.
-//            if (CompletionException.class.isAssignableFrom(err.getClass())) {
-//              logger.warn("gRPC call timed out: {}", err.getMessage(), err);
-//            } else {
-//              logger.error("Unexepcted Error: {}", err.getMessage(), err);
-//            }
-//            return Optional.empty();
-//          });
-//    } catch (StatusRuntimeException e) {
-//      // TODO: Look at status codes for better error messaging.
-//      logger.warn("Pinterledger Prepare Request Timed-out!", e.getMessage(), e);
-//      return CompletableFuture.completedFuture(Optional.empty());
-//    }
-//  }
-//
-//  public Channel getChannel() {
-//    return this.channel;
-//  }
+  public void shutdown() {
+    try {
+      channel.shutdown().awaitTermination(5, TimeUnit.SECONDS);
+    } catch (InterruptedException e) {
+      throw new RuntimeException(e.getMessage(), e);
+    }
+  }
 
+  /**
+   * Send a Prepare packet to the gRPC server this client is connected to.
+   */
+  public CompletableFuture<Optional<InterledgerResponsePacket>> send(final InterledgerPreparePacket preparePacket) {
+    logger.debug("Sending preparePacket: {}", preparePacket);
+
+    final BppPrepare request = BppPrepare.newBuilder()
+        .setPreparePacketBytes(GrpcIOStreamUtils.toByteString(ilpCodecContext, preparePacket))
+        .build();
+
+    try {
+      return CompletableFuturesExtra.toCompletableFuture(
+          nonblockingStub.withDeadlineAfter(settings.grpcDeadlineMillis(), TimeUnit.MILLISECONDS).send(request)
+      )
+          .thenApply(BppResponse::getResponsePacketBytes)
+          .thenApply(responsePacketBytes -> {
+            final InterledgerResponsePacket packet = (InterledgerResponsePacket) GrpcIOStreamUtils
+                .fromByteString(ilpCodecContext, responsePacketBytes);
+            return Optional.ofNullable(packet);
+          }).exceptionally(err -> {
+            // If there's an error, then return empty.
+            if (CompletionException.class.isAssignableFrom(err.getClass())) {
+              logger.warn("gRPC call timed out: {}", err.getMessage(), err);
+            } else {
+              logger.error("Unexepcted Error: {}", err.getMessage(), err);
+            }
+            return Optional.empty();
+          });
+    } catch (StatusRuntimeException e) {
+      // TODO: Look at status codes for better error messaging.
+      logger.warn("Pinterledger Prepare Request Timed-out!", e.getMessage(), e);
+      return CompletableFuture.completedFuture(Optional.empty());
+    }
+  }
+
+  public Channel getChannel() {
+    return this.channel;
+  }
 }
Index: ilp-plugin-connections/pom.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ilp-plugin-connections/pom.xml	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
+++ ilp-plugin-connections/pom.xml	(date 1545318025000)
@@ -13,8 +13,8 @@
 
   <name>ILP Plugin Connections</name>
   <description>
-    Defines a Connection primitive that defines how bilateral peers can connect to each other, possibly
-    operating one or many plugins over a single Connection.
+    Connection primitives that define how bilateral peers can connect to each other, possibly
+    operating one or more plugins over a single Connection.
   </description>
 
   <dependencies>
Index: ilp-plugin-grpc/src/main/proto/attic/btp2_1.proto
===================================================================
--- ilp-plugin-grpc/src/main/proto/attic/btp2_1.proto	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
+++ ilp-plugin-bpp-grpc/src/main/proto/attic/btp2_1.proto	(date 1543715958000)
@@ -1,0 +1,0 @@
Index: ilp-plugin-bpp-grpc/src/test/java/org/interledger/plugin/lpiv2/bpp/grpc/connection/mux/GrpcBppClientMuxTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ilp-plugin-bpp-grpc/src/test/java/org/interledger/plugin/lpiv2/bpp/grpc/connection/mux/GrpcBppClientMuxTest.java	(date 1545322640000)
+++ ilp-plugin-bpp-grpc/src/test/java/org/interledger/plugin/lpiv2/bpp/grpc/connection/mux/GrpcBppClientMuxTest.java	(date 1545322640000)
@@ -0,0 +1,246 @@
+package org.interledger.plugin.lpiv2.bpp.grpc.connection.mux;
+
+import static junit.framework.TestCase.fail;
+import static org.hamcrest.CoreMatchers.is;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.interledger.TestArtifacts.CODEC_CONTEXT;
+import static org.interledger.TestArtifacts.FULFILLMENT;
+import static org.interledger.TestArtifacts.FULFILL_PACKET;
+import static org.interledger.TestArtifacts.PREPARE_PACKET;
+import static org.interledger.TestArtifacts.REJECT_PACKET;
+import static org.interledger.plugin.lpiv2.bpp.grpc.connection.mux.GrpcIOStreamUtils.toByteString;
+import static org.mockito.AdditionalAnswers.delegatesTo;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+
+import org.interledger.bpp.grpc.BppGrpc;
+import org.interledger.bpp.grpc.BppProto.BppPrepare;
+import org.interledger.bpp.grpc.BppProto.BppResponse;
+import org.interledger.core.InterledgerFulfillPacket;
+import org.interledger.core.InterledgerRejectPacket;
+import org.interledger.core.InterledgerResponsePacket;
+import org.interledger.core.InterledgerResponsePacketHandler;
+
+import com.google.protobuf.ByteString;
+import io.grpc.Context;
+import io.grpc.ManagedChannel;
+import io.grpc.Status;
+import io.grpc.inprocess.InProcessChannelBuilder;
+import io.grpc.inprocess.InProcessServerBuilder;
+import io.grpc.stub.StreamObserver;
+import io.grpc.testing.GrpcCleanupRule;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.ArgumentCaptor;
+import org.mockito.ArgumentMatchers;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.util.Optional;
+
+/**
+ * A unit test that validates the {@link GrpcBppClientMux}.
+ */
+@RunWith(JUnit4.class)
+public class GrpcBppClientMuxTest {
+
+  /**
+   * This rule manages automatic graceful shutdown for the registered servers and channels at the end of test.
+   */
+  @Rule
+  public final GrpcCleanupRule grpcCleanup = new GrpcCleanupRule();
+
+  private ExpectedResult expectedResult;
+
+  private BppGrpc.BppImplBase serviceImpl;
+  private GrpcBppClientMux client;
+
+  @Before
+  public void setUp() throws Exception {
+    this.serviceImpl =
+        mock(BppGrpc.BppImplBase.class,
+            delegatesTo(new BppGrpc.BppImplBase() {
+              @Override
+              public void send(BppPrepare request,
+                  StreamObserver<BppResponse> responseObserver) {
+
+                if (Context.current().isCancelled()) {
+                  responseObserver
+                      .onError(Status.CANCELLED.withDescription("Cancelled by client").asRuntimeException());
+                  return;
+                }
+
+                try {
+
+                  switch (expectedResult) {
+                    case FULFILL: {
+                      final ByteString packetAsByteString = toByteString(CODEC_CONTEXT, FULFILL_PACKET);
+                      final BppResponse sendDataResponse = BppResponse.newBuilder()
+                          .setResponsePacketBytes(packetAsByteString)
+                          .build();
+                      // Send the response...
+                      responseObserver.onNext(sendDataResponse);
+                      responseObserver.onCompleted();
+                      break;
+                    }
+                    case REJECT: {
+                      final ByteString packetAsByteString = toByteString(CODEC_CONTEXT, REJECT_PACKET);
+                      final BppResponse sendDataResponse = BppResponse.newBuilder()
+                          .setResponsePacketBytes(packetAsByteString)
+                          .build();
+                      // Send the response...
+                      responseObserver.onNext(sendDataResponse);
+                      responseObserver.onCompleted();
+                      break;
+                    }
+                    case EXPIRE:
+                    default: {
+                      responseObserver.onCompleted();
+                      break;
+                    }
+                  }
+
+                } catch (Exception e) {
+                  responseObserver.onError(e);
+                }
+              }
+            }));
+
+    // Generate a unique in-process server name.
+    final String serverName = InProcessServerBuilder.generateName();
+
+    // Create a server, add service, start, and register for automatic graceful shutdown.
+    grpcCleanup.register(InProcessServerBuilder
+        .forName(serverName).directExecutor().addService(serviceImpl).build().start());
+
+    // Create a client channel and register for automatic graceful shutdown.
+    final ManagedChannel channel = grpcCleanup
+        .register(InProcessChannelBuilder.forName(serverName).directExecutor().build());
+
+    // Create a IlpPluginClient using the in-process channel;
+    final GrpcBppClientMuxSettings settings = GrpcBppClientMuxSettings.builder()
+        .port(5000)
+        .host("localhost")
+        .build();
+    client = new GrpcBppClientMux(settings, CODEC_CONTEXT, channel);
+  }
+
+  /**
+   * To test the client, call from the client against the fake server, and verify a fulfill response.
+   */
+  @Test
+  public void client_sendAndFulfill() throws IOException {
+    this.expectedResult = ExpectedResult.FULFILL;
+    final ArgumentCaptor<BppPrepare> requestCaptor = ArgumentCaptor.forClass(BppPrepare.class);
+
+    final ByteArrayOutputStream expectedPrepareBytesOutputStream = new ByteArrayOutputStream();
+    CODEC_CONTEXT.write(PREPARE_PACKET, expectedPrepareBytesOutputStream);
+    final byte[] expectedBytes = expectedPrepareBytesOutputStream.toByteArray();
+
+    final Optional<InterledgerResponsePacket> response = client.send(PREPARE_PACKET).join();
+
+    verify(serviceImpl).send(requestCaptor.capture(), ArgumentMatchers.any());
+    assertThat(requestCaptor.getValue().getPreparePacketBytes().toByteArray(), is(expectedBytes));
+
+    new InterledgerResponsePacketHandler() {
+
+      @Override
+      protected void handleFulfillPacket(InterledgerFulfillPacket interledgerFulfillPacket) {
+        assertThat(interledgerFulfillPacket.getFulfillment(), is(FULFILLMENT));
+      }
+
+      @Override
+      protected void handleRejectPacket(InterledgerRejectPacket interledgerRejectPacket) {
+        fail("Request should not reject!");
+      }
+
+      @Override
+      protected void handleExpiredPacket() {
+        fail("Request should not expired!");
+      }
+    }.handle(response);
+  }
+
+  /**
+   * To test the client, call from the client against the fake server, and verify a rejection response.
+   */
+  @Test
+  public void client_sendAndReject() throws IOException {
+    this.expectedResult = ExpectedResult.REJECT;
+    final ArgumentCaptor<BppPrepare> requestCaptor = ArgumentCaptor
+        .forClass(BppPrepare.class);
+
+    ByteArrayOutputStream expectedPrepareBytesOutputStream = new ByteArrayOutputStream();
+    CODEC_CONTEXT.write(PREPARE_PACKET, expectedPrepareBytesOutputStream);
+    final byte[] expectedBytes = expectedPrepareBytesOutputStream.toByteArray();
+
+    final Optional<InterledgerResponsePacket> response = client.send(PREPARE_PACKET).join();
+
+    verify(serviceImpl).send(requestCaptor.capture(), ArgumentMatchers.any());
+    assertThat(requestCaptor.getValue().getPreparePacketBytes().toByteArray(), is(expectedBytes));
+
+    new InterledgerResponsePacketHandler() {
+
+      @Override
+      protected void handleFulfillPacket(InterledgerFulfillPacket interledgerFulfillPacket) {
+        fail("Request should not fulfill!");
+      }
+
+      @Override
+      protected void handleRejectPacket(InterledgerRejectPacket interledgerRejectPacket) {
+        assertThat(interledgerRejectPacket, is(REJECT_PACKET));
+      }
+
+      @Override
+      protected void handleExpiredPacket() {
+        fail("Request should not expired!");
+      }
+    }.handle(response);
+  }
+
+  /**
+   * To test the client, call from the client against the fake server, and verify a rejection response.
+   */
+  @Test
+  public void client_sendAndTimeout() throws IOException {
+    this.expectedResult = ExpectedResult.EXPIRE;
+    final ArgumentCaptor<BppPrepare> requestCaptor = ArgumentCaptor
+        .forClass(BppPrepare.class);
+
+    ByteArrayOutputStream expectedPrepareBytesOutputStream = new ByteArrayOutputStream();
+    CODEC_CONTEXT.write(PREPARE_PACKET, expectedPrepareBytesOutputStream);
+    final byte[] expectedBytes = expectedPrepareBytesOutputStream.toByteArray();
+
+    final Optional<InterledgerResponsePacket> response = client.send(PREPARE_PACKET).join();
+
+    verify(serviceImpl).send(requestCaptor.capture(), ArgumentMatchers.any());
+    assertThat(requestCaptor.getValue().getPreparePacketBytes().toByteArray(), is(expectedBytes));
+
+    new InterledgerResponsePacketHandler() {
+
+      @Override
+      protected void handleFulfillPacket(InterledgerFulfillPacket interledgerFulfillPacket) {
+        fail("Request should not fulfill!");
+      }
+
+      @Override
+      protected void handleRejectPacket(InterledgerRejectPacket interledgerRejectPacket) {
+        fail("Request should not reject!");
+      }
+
+      @Override
+      protected void handleExpiredPacket() {
+        // No-op
+      }
+    }.handle(response);
+  }
+
+  private enum ExpectedResult {
+    FULFILL,
+    REJECT,
+    EXPIRE
+  }
+}
\ No newline at end of file
Index: ilp-plugin-btp/src/main/java/org/interledger/plugin/lpiv2/btp2/BtpResponsePacketHandler.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ilp-plugin-btp/src/main/java/org/interledger/plugin/lpiv2/btp2/BtpResponsePacketHandler.java	(date 1546443072000)
+++ ilp-plugin-btp/src/main/java/org/interledger/plugin/lpiv2/btp2/BtpResponsePacketHandler.java	(date 1546443072000)
@@ -0,0 +1,48 @@
+package org.interledger.plugin.lpiv2.btp2;
+
+import org.interledger.btp.BtpError;
+import org.interledger.btp.BtpPacket;
+import org.interledger.btp.BtpResponse;
+import org.interledger.core.InterledgerResponsePacket;
+
+import java.util.Objects;
+
+/**
+ * A helper class for mapping polymorphic BTP responses to their proper type.
+ */
+// TODO: Remove if unused.
+public abstract class BtpResponsePacketHandler {
+
+  /**
+   * Handle the supplied {@code btpResponse} in a type-safe manner.
+   *
+   * @param btpResponse The generic {@link InterledgerResponsePacket} to be mapped in a type-safe manner.
+   */
+  public final void handle(final BtpPacket btpResponse) {
+    Objects.requireNonNull(btpResponse);
+
+    if (BtpError.class.isAssignableFrom(btpResponse.getClass())) {
+      handleBtpError((BtpError) btpResponse);
+    } else if (BtpResponse.class.isAssignableFrom(btpResponse.getClass())) {
+      handleBtpResponse((BtpResponse) btpResponse);
+    } else {
+      throw new RuntimeException(String.format("Unsupported BtpResponse Type: %s", btpResponse.getClass()));
+    }
+
+  }
+
+  /**
+   * Handle the packet as an {@link BtpPacket}.
+   *
+   * @param btpError A {@link BtpError}.
+   */
+  protected abstract void handleBtpError(final BtpError btpError);
+
+  /**
+   * Handle the packet as an {@link BtpPacket}.
+   *
+   * @param btpResponse A {@link BtpResponse}.
+   */
+  protected abstract void handleBtpResponse(final BtpResponse btpResponse);
+
+}
Index: ilp-plugin-btp-springws/src/main/java/org/interledger/plugin/lpiv2/btp2/spring/ClientWebsocketBtpPlugin.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ilp-plugin-btp-springws/src/main/java/org/interledger/plugin/lpiv2/btp2/spring/ClientWebsocketBtpPlugin.java	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
+++ ilp-plugin-btp-springws/src/main/java/org/interledger/plugin/lpiv2/btp2/spring/ClientWebsocketBtpPlugin.java	(date 1546461923000)
@@ -1,132 +1,138 @@
 package org.interledger.plugin.lpiv2.btp2.spring;
 
+import org.interledger.btp.BtpError;
+import org.interledger.btp.BtpMessage;
+import org.interledger.btp.BtpResponse;
+import org.interledger.btp.BtpSessionCredentials;
+import org.interledger.btp.BtpSubProtocol;
+import org.interledger.btp.BtpSubProtocols;
+import org.interledger.core.InterledgerResponsePacket;
+import org.interledger.core.asn.framework.InterledgerCodecContextFactory;
+import org.interledger.encoding.asn.framework.CodecContext;
+import org.interledger.plugin.lpiv2.AbstractPlugin;
+import org.interledger.plugin.lpiv2.PluginSettings;
+import org.interledger.plugin.lpiv2.PluginType;
+import org.interledger.plugin.lpiv2.btp2.BtpResponsePacketMapper;
+import org.interledger.plugin.lpiv2.btp2.spring.connection.SingleAccountBtpClientConnection;
+import org.interledger.plugin.lpiv2.btp2.subprotocols.ilp.IlpBtpConverter;
+
+import org.springframework.web.socket.WebSocketSession;
+import org.springframework.web.socket.client.standard.StandardWebSocketClient;
+
+import java.security.SecureRandom;
+import java.util.Objects;
+import java.util.Optional;
+import java.util.Random;
+import java.util.concurrent.CompletableFuture;
+
 /**
- * An extension of {@link AbstractWebsocketBtpPlugin} that connects to a remote peer using BTP, but merely logs all
- * responses.
- */
-public class ClientWebsocketBtpPlugin { //extends AbstractWebsocketBtpPlugin<BtpClientPluginSettings> {
+ * An extension of {@link AbstractWebsocketBtpPluginOldWithMux} that connects to a remote peer using BTP, but merely
+ * logs all responses.
+ */
+public class ClientWebsocketBtpPlugin extends AbstractPlugin<PluginSettings> {
+
+  public static final String PLUGIN_TYPE_STRING = "ClientWebsocketBtpPlugin";
+  public static final PluginType PLUGIN_TYPE = PluginType.of(PLUGIN_TYPE_STRING);
+
+  private final Random random;
+
+  private final BtpSessionCredentials btpSessionCredentials;
+
+  // TODO: Consider moving to a single HttpUrl.
+  private final String remotePeerScheme;
+  private final String remotePeerHostname;
+  private final String remotePeerPort;
+
+  // Incoming and outgoing messages are transmitted via this client.
+  private final StandardWebSocketClient wsClient;
+
+  // Starts life as `empty`. There will only be a single connection in this MUX, and thus a single WS Session.
+  private Optional<WebSocketSession> webSocketSession = Optional.empty();
+
+  private final CodecContext ilpCodecContext;
+
+  /**
+   * Required-args Constructor.
+   */
+  public ClientWebsocketBtpPlugin(
+      final PluginSettings pluginSettings, final SingleAccountBtpClientConnection connection
+  ) {
+    super(pluginSettings);
+
+    this.ilpCodecContext = InterledgerCodecContextFactory.oer();
+    this.random = new SecureRandom();
+
+//    this.btpSessionCredentials = BtpSessionCredentials.builder()
+//        .authUsername(Optional.empty())
+//        .authToken(getConnectionSettings().getAuthToken())
+//        .build();
 
-//  public static final String PLUGIN_TYPE_STRING = "ClientWebsocketBtpPlugin";
-//  public static final PluginType PLUGIN_TYPE = PluginType.of(PLUGIN_TYPE_STRING);
-//
-//  private final StandardWebSocketClient wsClient;
-//
-//  /**
-//   * Required-args Constructor.
-//   */
-//  public ClientWebsocketBtpPlugin(final BtpClientPluginSettings settings) {
-//    this(settings, InterledgerCodecContextFactory.oer(), BtpCodecContextFactory.oer());
-//  }
-//
-//  /**
-//   * Required-args Constructor.
-//   */
-//  public ClientWebsocketBtpPlugin(
-//      final BtpClientPluginSettings settings,
-//      final CodecContext ilpCodecContext,
-//      final CodecContext btpCodecContext
-//  ) {
-//    this(
-//        settings,
-//        ilpCodecContext,
-//        btpCodecContext,
-//        // Clients don't need to authenticate the BtpSession...
-//        new BtpSubProtocolHandlerRegistry(new AlwaysAllowedBtpAuthenticationService(settings.getPeerAccountAddress())),
-//        new BinaryMessageToBtpPacketConverter(btpCodecContext),
-//        new BtpPacketToBinaryMessageConverter(btpCodecContext),
-//        new StandardWebSocketClient()
-//    );
-//  }
-//
-//  /**
-//   * Required-args Constructor.
-//   */
-//  public ClientWebsocketBtpPlugin(
-//      final BtpClientPluginSettings settings,
-//      final CodecContext ilpCodecContext,
-//      final CodecContext btpCodecContext,
-//      final BtpSubProtocolHandlerRegistry btpSubProtocolHandlerRegistry,
-//      final BinaryMessageToBtpPacketConverter binaryMessageToBtpPacketConverter,
-//      final BtpPacketToBinaryMessageConverter btpPacketToBinaryMessageConverter,
-//      final StandardWebSocketClient wsClient
-//  ) {
-//    super(settings, ilpCodecContext, btpCodecContext, btpSubProtocolHandlerRegistry, binaryMessageToBtpPacketConverter,
-//        btpPacketToBinaryMessageConverter);
-//
-//    this.wsClient = Objects.requireNonNull(wsClient);
-//  }
-//
-//  /**
-//   * Override the plugin-type in the supplied plugin settings.
-//   *
-//   * @param pluginSettings
-//   *
-//   * @return
-//   */
-//  private static final BtpClientPluginSettings setPluginType(final BtpClientPluginSettings pluginSettings) {
-//    return BtpClientPluginSettings.builder().from(pluginSettings).pluginType(PLUGIN_TYPE).build();
-//  }
-//
-//
-//  @Override
-//  public CompletableFuture<Void> doConnectSenderMux() {
-//    // Connect and initialize the WebSocketSession...
-//    try {
-//      this.webSocketSession = Optional.ofNullable(
-//          wsClient.doHandshake(
-//              new BinaryWebSocketHandler() {
-//                @Override
-//                protected void handleBinaryMessage(WebSocketSession session, BinaryMessage message) {
-//                  // TODO: What does the other side of the Websocket see if there's an exception here?
-//                  handleBinaryMessage(session, message).ifPresent(response -> {
-//                    try {
-//                      session.sendMessage(response);
-//                    } catch (IOException e) {
-//                      throw new RuntimeException(e);
-//                    }
-//                  });
-//                }
-//              },
-//              "{scheme}://{localhost}:{port}/btp",
-//              getPluginSettings().getRemotePeerScheme(),
-//              getPluginSettings().getRemotePeerHostname(),
-//              getPluginSettings().getRemotePeerPort())
-//              .get()
-//      );
-//    } catch (Exception e) {
-//      this.disconnect().join();
-//      throw new RuntimeException(e.getMessage(), e);
-//    }
-//
-//    // AUTH
-//    final long requestId = nextRequestId();
-//    final Optional<String> authUserName = getPluginSettings().getAuthUsername();
-//    final String authToken = getPluginSettings().getSecret();
-//    final BtpMessage btpAuthMessage = this.constructAuthMessage(requestId, authToken, authUserName);
-//    final BinaryMessage binaryAuthMessage = btpPacketToBinaryMessageConverter.convert(btpAuthMessage);
-//    logger.debug(
-//        "Websocket Auth BinaryMessage Bytes: {}",
-//        BaseEncoding.base16().encode(binaryAuthMessage.getPayload().array())
-//    );
-//    return this.sendMessageWithPendingRepsonse(requestId, binaryAuthMessage)
-//        .thenAccept((response) -> {
-//          // Convert to Void response...
-//        });
-//  }
-//
-//  @Override
-//  public CompletableFuture<Void> doDisconnect() {
-//    synchronized (webSocketSession) {
-//      // Block on the Disconnect so that only one thread can operate at a time...
-//      webSocketSession.ifPresent(webSocketSession -> {
-//        try {
-//          webSocketSession.close();
-//          this.webSocketSession = Optional.empty();
-//        } catch (IOException e) {
-//          throw new RuntimeException(e);
-//        }
-//      });
-//    }
-//    return CompletableFuture.completedFuture(null);
-//  }
+    ////////////////////////
+    // REGISTER DATA SENDER: This plugin's sendData function should use the connection to send a BTP packet.
+    ////////////////////////
+    // TODO: Consider not registering a sendData, but instead make the plugin implement this method directly (plugin is a DataSender, instead of plugin _has_ a Datasender).
+    this.registerDataSender((preparePacket -> {
+      final BtpSubProtocols btpSubProtocols = new BtpSubProtocols();
+      final BtpSubProtocol ilpPrepare = IlpBtpConverter.toBtpSubprotocol(preparePacket, ilpCodecContext);
+      btpSubProtocols.add(ilpPrepare);
+
+      // Map the response back to an ILP fulfill or reject...
+      return connection
+          /////////////////////////
+          // Send the BTP Message out over the connection....
+          /////////////////////////
+          .sendBtpMessage(BtpMessage.builder()
+              .requestId(nextRequestId())
+              .subProtocols(btpSubProtocols)
+              .build()
+          )
+          /////////////////////////
+          // Expect a response, but handle the Connection-error condition as well...
+          /////////////////////////
+          .handle((btpResponsePacket, error) -> {
+            if (error != null) {
+              logger.error(error.getMessage(), error);
+              return Optional.<InterledgerResponsePacket>empty();
+            } else {
+              // Convert the BtpResponse to the proper ILP response.
+              return new BtpResponsePacketMapper<Optional<InterledgerResponsePacket>>() {
+                @Override
+                protected Optional<InterledgerResponsePacket> handleBtpError(final BtpError btpError) {
+                  Objects.requireNonNull(btpError);
+                  logger.error("BTP Error while attempting to sendBtpMessage: {}", btpError);
+                  return Optional.empty();
+                }
+
+                @Override
+                protected Optional<InterledgerResponsePacket> handleBtpResponse(final BtpResponse btpResponse) {
+                  Objects.requireNonNull(btpResponse);
+                  return Optional.of(IlpBtpConverter.toIlpPacket(btpResponse, ilpCodecContext));
+                }
+              }.map(btpResponsePacket);
+            }
+          });
+    }));
+  }
+
+  /**
+   * Returns the next random request id using a PRNG.
+   */
+  protected long nextRequestId() {
+    return Math.abs(random.nextInt());
+  }
+
+  @Override
+  public CompletableFuture<Void> doConnect() {
+    // TODO: Plugins should perhaps lose their connect functionality, and instead only a Connection should do that?
+    throw new RuntimeException("FIXME");
+//    // Because BTP client-plugins operate
+//    return this.connection.connect();
+  }
+
+  @Override
+  public CompletableFuture<Void> doDisconnect() {
+    // TODO: Plugins should perhaps lose their connect functionality, and instead only a Connection should do that?
+    throw new RuntimeException("FIXME");
+    //return connection.disconnect();
+  }
 }
\ No newline at end of file
Index: ilp-plugin-grpc/src/test/java/org/interledger/plugin/mux/grpc/bpp/GrinterledgerBppServerTest.java
===================================================================
--- ilp-plugin-grpc/src/test/java/org/interledger/plugin/mux/grpc/bpp/GrinterledgerBppServerTest.java	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
+++ ilp-plugin-bpp-grpc/src/test/java/org/interledger/plugin/lpiv2/bpp/grpc/connection/mux/GrpcBppServerMuxTest.java	(date 1545412712000)
@@ -1,4 +1,4 @@
-package org.interledger.plugin.mux.grpc.bpp;
+package org.interledger.plugin.lpiv2.bpp.grpc.connection.mux;
 
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.core.Is.is;
@@ -6,17 +6,21 @@
 import static org.interledger.TestArtifacts.FULFILLMENT;
 import static org.interledger.TestArtifacts.PREPARE_PACKET;
 import static org.interledger.TestArtifacts.REJECT_PACKET;
-import static org.interledger.plugin.mux.grpc.GrpcIOStreamUtils.toByteString;
+import static org.interledger.plugin.lpiv2.bpp.grpc.connection.mux.GrpcIOStreamUtils.toByteString;
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.when;
 
+import org.interledger.bpp.grpc.BppGrpc;
+import org.interledger.bpp.grpc.BppProto.BppPrepare;
+import org.interledger.bpp.grpc.BppProto.BppResponse;
+import org.interledger.core.InterledgerAddress;
 import org.interledger.core.InterledgerFulfillPacket;
 import org.interledger.core.InterledgerRejectPacket;
-import org.interledger.grpc.bpp.GrinterledgerBppGrpc;
-import org.interledger.grpc.bpp.GrinterledgerBppProto.GrinterledgerBppPrepare;
-import org.interledger.grpc.bpp.GrinterledgerBppProto.GrinterledgerBppResponse;
+import org.interledger.plugin.connections.mux.BilateralReceiverMux;
 import org.interledger.plugin.lpiv2.Plugin;
-//import org.interledger.plugin.mux.grpc.bpp.GrinterledgerBppServer.GrinterledgerBppImpl;
+import org.interledger.plugin.lpiv2.bpp.grpc.connection.mux.GrpcBppServerMux.BppImpl;
 
+import io.grpc.Server;
 import io.grpc.Status;
 import io.grpc.StatusRuntimeException;
 import io.grpc.inprocess.InProcessChannelBuilder;
@@ -30,124 +34,132 @@
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.util.Optional;
 import java.util.concurrent.CompletableFuture;
 
 /**
- * A unit test that validates the {@link GrinterledgerBppServer}.
+ * A unit test that validates the {@link GrpcBppServerMux}.
  */
 @RunWith(JUnit4.class)
-public class GrinterledgerBppServerTest {
+public class GrpcBppServerMuxTest {
+
+  private static final InterledgerAddress ACCOUNT_ADDRESS = InterledgerAddress.of("test.foo-account");
+
+  /**
+   * This rule manages automatic graceful shutdown for the registered servers and channels at the end of test.
+   */
+  @Rule
+  public final GrpcCleanupRule grpcCleanup = new GrpcCleanupRule();
+
+  @Mock
+  Plugin<?> pluginMock;
+
+  @Mock
+  BilateralReceiverMux receiverMux;
 
-//  /**
-//   * This rule manages automatic graceful shutdown for the registered servers and channels at the end of test.
-//   */
-//  @Rule
-//  public final GrpcCleanupRule grpcCleanup = new GrpcCleanupRule();
-//
-//  @Mock
-//  Plugin<?> pluginMock;
-//
-//  private GrinterledgerBppGrpc.GrinterledgerBppBlockingStub blockingStub;
-//
-//  @Before
-//  public void setup() throws IOException {
-//    MockitoAnnotations.initMocks(this);
-//
-//    // Generate a unique in-process server name.
-//    final String serverName = InProcessServerBuilder.generateName();
-//
-//    when(pluginMock.safeGetDataSender()).thenReturn((packet) -> CompletableFuture.completedFuture(Optional.empty()));
-//    when(pluginMock.safeGetDataHandler()).thenReturn((packet) -> CompletableFuture.completedFuture(Optional.empty()));
-//    when(pluginMock.safeGetMoneySender()).thenReturn((packet) -> CompletableFuture.completedFuture(null));
-//    when(pluginMock.safeGetMoneyHandler()).thenReturn((packet) -> CompletableFuture.completedFuture(null));
-//    when(pluginMock.connect()).thenReturn(CompletableFuture.completedFuture(null));
-//    when(pluginMock.disconnect()).thenReturn(CompletableFuture.completedFuture(null));
-//
-//    // Create a server, add service, start, and register for automatic graceful shutdown.
-//    grpcCleanup.register(InProcessServerBuilder
-//        .forName(serverName).directExecutor().addService(new GrinterledgerBppImpl(CODEC_CONTEXT, pluginMock)).build()
-//        .start());
-//
-//    blockingStub = GrinterledgerBppGrpc.newBlockingStub(
-//        // Create a client channel and register for automatic graceful shutdown.
-//        grpcCleanup.register(InProcessChannelBuilder.forName(serverName).directExecutor().build()));
-//  }
-//
-//  /**
-//   * To test the server, make calls with a real stub using the in-process channel, and verify an ILP Fulfill response.
-//   */
-//  @Test
-//  public void pinterledgerImpl_sendWithFulfill() throws Exception {
-//    // This test always fulfills...
-//    final InterledgerFulfillPacket expectedFulfillPacket = InterledgerFulfillPacket.builder()
-//        .fulfillment(FULFILLMENT)
-//        .build();
-//    when(pluginMock.safeGetDataSender()).thenReturn((preparePacket) ->
-//        CompletableFuture.completedFuture(Optional.of(expectedFulfillPacket))
-//    );
-//
-//    final GrinterledgerBppResponse reply = blockingStub.send(
-//        GrinterledgerBppPrepare.newBuilder()
-//            .setPreparePacketBytes(toByteString(CODEC_CONTEXT, PREPARE_PACKET))
-//            .build()
-//    );
-//    final ByteArrayOutputStream actualOutputStream = new ByteArrayOutputStream();
-//    actualOutputStream.write(reply.getResponsePacketBytes().toByteArray());
-//    final InterledgerFulfillPacket packet = CODEC_CONTEXT
-//        .read(InterledgerFulfillPacket.class, new ByteArrayInputStream(actualOutputStream.toByteArray()));
-//
-//    assertThat(packet.getFulfillment(), is(FULFILLMENT));
-//  }
-//
-//  /**
-//   * To test the server, make calls with a real stub using the in-process channel, and verify an ILP Fulfill response.
-//   */
-//  @Test
-//  public void pinterledgerImpl_sendWithReject() throws Exception {
-//
-//    // This test always rejects...
-//    when(pluginMock.safeGetDataSender()).thenReturn((packet) ->
-//        CompletableFuture.completedFuture(Optional.of(REJECT_PACKET))
-//    );
-//
-//    final GrinterledgerBppResponse reply = blockingStub.send(
-//        GrinterledgerBppPrepare.newBuilder()
-//            .setPreparePacketBytes(toByteString(CODEC_CONTEXT, PREPARE_PACKET))
-//            .build()
-//    );
-//    final ByteArrayOutputStream actualOutputStream = new ByteArrayOutputStream();
-//    actualOutputStream.write(reply.getResponsePacketBytes().toByteArray());
-//    final InterledgerRejectPacket packet = CODEC_CONTEXT
-//        .read(InterledgerRejectPacket.class, new ByteArrayInputStream(actualOutputStream.toByteArray()));
-//
-//    assertThat(packet, is(REJECT_PACKET));
-//  }
-//
-//  /**
-//   * To test the server, make calls with a real stub using the in-process channel, and verify an ILP Fulfill response.
-//   */
-//  @Test(expected = StatusRuntimeException.class)
-//  public void pinterledgerImpl_sendWithTimeout() {
-//
-//    // This test always times out...
-//    when(pluginMock.safeGetDataSender()).thenReturn((packet) ->
-//        CompletableFuture.completedFuture(Optional.empty())
-//    );
-//
-//    try {
-//      blockingStub.send(GrinterledgerBppPrepare.newBuilder()
-//          .setPreparePacketBytes(toByteString(CODEC_CONTEXT, PREPARE_PACKET))
-//          .build()
-//      );
-//    } catch (StatusRuntimeException e) {
-//      assertThat(e.getStatus().getCode(), is(Status.Code.CANCELLED));
-//      throw e;
-//    }
-//  }
+  private BppGrpc.BppBlockingStub blockingStub;
+  private GrpcBppServerMux serverMux;
+
+  @Before
+  public void setup() throws IOException {
+    MockitoAnnotations.initMocks(this);
+
+    // Generate a unique in-process server name.
+    final String serverName = InProcessServerBuilder.generateName();
+
+    when(receiverMux.getBilateralReceiver(any())).thenReturn(Optional.of(pluginMock));
+
+    when(pluginMock.safeGetDataSender()).thenReturn((packet) -> CompletableFuture.completedFuture(Optional.empty()));
+    when(pluginMock.safeGetDataHandler()).thenReturn((packet) -> CompletableFuture.completedFuture(Optional.empty()));
+    when(pluginMock.safeGetMoneySender()).thenReturn((packet) -> CompletableFuture.completedFuture(null));
+    when(pluginMock.safeGetMoneyHandler()).thenReturn((packet) -> CompletableFuture.completedFuture(null));
+    when(pluginMock.connect()).thenReturn(CompletableFuture.completedFuture(null));
+    when(pluginMock.disconnect()).thenReturn(CompletableFuture.completedFuture(null));
+
+    // Create a server, add service, start, and register for automatic graceful shutdown.
+    final Server server = InProcessServerBuilder.forName(serverName).directExecutor()
+        .addService(new BppImpl(CODEC_CONTEXT, receiverMux)).build();
+    grpcCleanup.register(server.start());
+
+    blockingStub = BppGrpc.newBlockingStub(
+        // Create a client channel and register for automatic graceful shutdown.
+        grpcCleanup.register(InProcessChannelBuilder.forName(serverName).directExecutor().build()));
+
+    serverMux = new GrpcBppServerMux(CODEC_CONTEXT, server);
+    serverMux.registerBilateralReceiver(ACCOUNT_ADDRESS, pluginMock);
+    serverMux.connect();
+  }
+
+  /**
+   * To test the server, make calls with a real stub using the in-process channel, and verify an ILP Fulfill response.
+   */
+  @Test
+  public void serverMux_sendWithFulfill() {
+    // This test always fulfills...
+    final InterledgerFulfillPacket expectedFulfillPacket = InterledgerFulfillPacket.builder()
+        .fulfillment(FULFILLMENT)
+        .build();
+
+    // Make the plugin fulfill correctly when it encounters a prepare packet...
+    when(pluginMock.safeGetDataSender()).thenReturn((preparePacket) ->
+        CompletableFuture.completedFuture(Optional.of(expectedFulfillPacket))
+    );
+
+    // Simulates an incoming message on the Server....
+    final BppResponse reply = blockingStub.send(
+        BppPrepare.newBuilder()
+            .setPreparePacketBytes(toByteString(CODEC_CONTEXT, PREPARE_PACKET))
+            .build()
+    );
+    final InterledgerFulfillPacket packet = (InterledgerFulfillPacket) GrpcIOStreamUtils
+        .fromByteString(CODEC_CONTEXT, reply.getResponsePacketBytes());
+    assertThat(packet.getFulfillment(), is(FULFILLMENT));
+  }
+
+  /**
+   * To test the server, make calls with a real stub using the in-process channel, and verify an ILP Fulfill response.
+   */
+  @Test
+  public void serverMux_sendWithReject() {
+
+    // This test always rejects...
+    when(pluginMock.safeGetDataSender()).thenReturn((packet) ->
+        CompletableFuture.completedFuture(Optional.of(REJECT_PACKET))
+    );
+
+    final BppResponse reply = blockingStub.send(
+        BppPrepare.newBuilder()
+            .setPreparePacketBytes(toByteString(CODEC_CONTEXT, PREPARE_PACKET))
+            .build()
+    );
+
+    final InterledgerRejectPacket packet = (InterledgerRejectPacket) GrpcIOStreamUtils
+        .fromByteString(CODEC_CONTEXT, reply.getResponsePacketBytes());
+    assertThat(packet, is(REJECT_PACKET));
+  }
+
+  /**
+   * To test the server, make calls with a real stub using the in-process channel, and verify an ILP Fulfill response.
+   */
+  @Test(expected = StatusRuntimeException.class)
+  public void serverMux_sendWithTimeout() {
+
+    // This test always times out...
+    when(pluginMock.safeGetDataSender()).thenReturn((packet) ->
+        CompletableFuture.completedFuture(Optional.empty())
+    );
+
+    try {
+      blockingStub.send(BppPrepare.newBuilder()
+          .setPreparePacketBytes(toByteString(CODEC_CONTEXT, PREPARE_PACKET))
+          .build()
+      );
+    } catch (StatusRuntimeException e) {
+      assertThat(e.getStatus().getCode(), is(Status.Code.CANCELLED));
+      throw e;
+    }
+  }
 
 
 }
\ No newline at end of file
Index: ilp-plugin-btp-springws/src/main/java/org/interledger/plugin/lpiv2/btp2/spring/AbstractWebsocketBtpPlugin.java
===================================================================
--- ilp-plugin-btp-springws/src/main/java/org/interledger/plugin/lpiv2/btp2/spring/AbstractWebsocketBtpPlugin.java	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
+++ ilp-plugin-btp-springws/src/main/java/org/interledger/plugin/lpiv2/btp2/spring/AbstractWebsocketBtpPluginOldWithMux.java	(date 1546455987000)
@@ -6,7 +6,7 @@
 import org.interledger.btp.BtpRuntimeException;
 import org.interledger.btp.BtpSession;
 import org.interledger.encoding.asn.framework.CodecContext;
-import org.interledger.plugin.lpiv2.btp2.AbstractBtpPlugin;
+import org.interledger.plugin.lpiv2.btp2.AbstractBtpPlugin_OldWithMux;
 import org.interledger.plugin.lpiv2.btp2.BtpPluginSettings;
 import org.interledger.plugin.lpiv2.btp2.spring.converters.BinaryMessageToBtpPacketConverter;
 import org.interledger.plugin.lpiv2.btp2.spring.converters.BtpPacketToBinaryMessageConverter;
@@ -26,12 +26,16 @@
 import java.util.concurrent.locks.LockSupport;
 
 /**
- * <p>An extension of {@link AbstractBtpPlugin} that operates over a Websocket mux with a Websocket
+ * <p>An extension of {@link AbstractBtpPlugin_OldWithMux} that operates over a Websocket mux with a Websocket
  * implementation provided by the Spring Framework. This class is abstract because the implementation that uses a
  * Websocket Client is different from the Websocket implementation that operates using a Websocket server, though this
  * class contains all logic and functionality that is common between the two.</p>
+ *
+ * @deprecated BTP Functionality should be delegated to the MUX.
  */
-public abstract class AbstractWebsocketBtpPlugin<PS extends BtpPluginSettings> extends AbstractBtpPlugin<PS> {
+@Deprecated
+public abstract class AbstractWebsocketBtpPluginOldWithMux<PS extends BtpPluginSettings> extends
+    AbstractBtpPlugin_OldWithMux<PS> {
 
   protected final BinaryMessageToBtpPacketConverter binaryMessageToBtpPacketConverter;
   protected final BtpPacketToBinaryMessageConverter btpPacketToBinaryMessageConverter;
@@ -49,7 +53,7 @@
   /**
    * Required-args Constructor.
    */
-  public AbstractWebsocketBtpPlugin(
+  public AbstractWebsocketBtpPluginOldWithMux(
       final PS pluginSettings,
       final CodecContext ilpCodecContext,
       final CodecContext btpCodecContext,
@@ -66,7 +70,7 @@
   /**
    * Required-args Constructor.
    */
-  public AbstractWebsocketBtpPlugin(
+  public AbstractWebsocketBtpPluginOldWithMux(
       final PS pluginSettings,
       final CodecContext ilpCodecContext,
       final CodecContext btpCodecContext,
@@ -146,7 +150,7 @@
 //          Objects.requireNonNull(incomingBtpError);
 //
 //          logger.error("Incoming BtpError from `{}` with message `{}`",
-//              getPluginSettings().getPeerAccountAddress(),
+//              getPluginSettings().getAccountAddress(),
 //              new String(incomingBtpError.getErrorData())
 //          );
 //
@@ -250,7 +254,7 @@
 //              //
 //              //                  // Client: Create a BTPSession (maybe handle in the registry?)
 //              //                  BtpSessionCredentials btpSessionCredentials = ImmutableBtpSessionCredentials.builder()
-//              //                    .name(btpSession.getPeerAccountAddress().getValue()).build();
+//              //                    .name(btpSession.getAccountAddress().getValue()).build();
 //              //                  btpSession.setValidAuthentication(btpSessionCredentials);
 //              //
 //              //                  //final BtpResponse btpResponse = (BtpResponse) btpResponseToConnectAsObject;
Index: ilp-plugin-btp/src/main/java/org/interledger/plugin/lpiv2/btp2/BtpRequestPacketHandler.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ilp-plugin-btp/src/main/java/org/interledger/plugin/lpiv2/btp2/BtpRequestPacketHandler.java	(date 1546443072000)
+++ ilp-plugin-btp/src/main/java/org/interledger/plugin/lpiv2/btp2/BtpRequestPacketHandler.java	(date 1546443072000)
@@ -0,0 +1,49 @@
+package org.interledger.plugin.lpiv2.btp2;
+
+import org.interledger.btp.BtpError;
+import org.interledger.btp.BtpMessage;
+import org.interledger.btp.BtpPacket;
+import org.interledger.btp.BtpTransfer;
+import org.interledger.core.InterledgerResponsePacket;
+
+import java.util.Objects;
+
+/**
+ * A helper class for mapping polymorphic BTP request packets to their proper type.
+ */
+// TODO: Remove if unused.
+public abstract class BtpRequestPacketHandler {
+
+  /**
+   * Handle the supplied {@code btpRequest} in a type-safe manner.
+   *
+   * @param btpRequest The generic {@link InterledgerResponsePacket} to be mapped in a type-safe manner.
+   */
+  public final void handle(final BtpPacket btpRequest) {
+    Objects.requireNonNull(btpRequest);
+
+    if (BtpMessage.class.isAssignableFrom(btpRequest.getClass())) {
+      handleBtpMessage((BtpMessage) btpRequest);
+    } else if (BtpTransfer.class.isAssignableFrom(btpRequest.getClass())) {
+      handleBtpTransfer((BtpTransfer) btpRequest);
+    } else {
+      throw new RuntimeException(String.format("Unsupported BtpRequest Type: %s", btpRequest.getClass()));
+    }
+
+  }
+
+  /**
+   * Handle the packet as an {@link BtpPacket}.
+   *
+   * @param btpMessage A {@link BtpError}.
+   */
+  protected abstract void handleBtpMessage(final BtpMessage btpMessage);
+
+  /**
+   * Handle the packet as an {@link BtpPacket}.
+   *
+   * @param btpTransfer A {@link BtpTransfer}.
+   */
+  protected abstract void handleBtpTransfer(final BtpTransfer btpTransfer);
+
+}
Index: ilp-plugin-core/src/main/java/org/interledger/plugin/lpiv2/Plugin.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ilp-plugin-core/src/main/java/org/interledger/plugin/lpiv2/Plugin.java	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
+++ ilp-plugin-core/src/main/java/org/interledger/plugin/lpiv2/Plugin.java	(date 1546463831000)
@@ -1,16 +1,17 @@
 package org.interledger.plugin.lpiv2;
 
 import org.interledger.core.InterledgerPreparePacket;
-import org.interledger.plugin.BilateralPinger;
-import org.interledger.plugin.BilateralReceiver;
-import org.interledger.plugin.BilateralSender;
+import org.interledger.plugin.BilateralReceiver.DataHandler;
+import org.interledger.plugin.BilateralReceiver.MoneyHandler;
+import org.interledger.plugin.BilateralSender.DataSender;
+import org.interledger.plugin.BilateralSender.MoneySender;
 import org.interledger.plugin.Connectable;
 import org.interledger.plugin.lpiv2.events.PluginEventListener;
 import org.interledger.plugin.lpiv2.exceptions.DataHandlerAlreadyRegisteredException;
 import org.interledger.plugin.lpiv2.exceptions.MoneyHandlerAlreadyRegisteredException;
-import org.interledger.plugin.lpiv2.exceptions.MoneySenderAlreadyRegisteredException;
 
 import java.math.BigInteger;
+import java.util.Optional;
 import java.util.UUID;
 import java.util.concurrent.CompletableFuture;
 
@@ -28,8 +29,7 @@
  * Sender/Connector's call <tt>sendData</tt>, wait for a fulfillment, and then call <tt>sendMoney</tt> (possibly
  * infrequently or even only eventually for bulk settlement) if the fulfillment is valid.</p>
  */
-public interface Plugin<T extends PluginSettings> extends BilateralPinger, BilateralSender, BilateralReceiver,
-    Connectable {
+public interface Plugin<T extends PluginSettings> extends DataSender, MoneySender, Connectable {
 
   /**
    * The settings for this Plugin.
@@ -57,24 +57,6 @@
    */
   void removePluginEventListener(UUID eventHandlerId);
 
-  void registerDataSender(BilateralSender.DataSender dataSender) throws MoneySenderAlreadyRegisteredException;
-
-  /**
-   * Removes the currently used {@oink DataSender}. This has the same effect as if {@link
-   * #registerDataSender(DataSender)} had never been called. If no bilateral sender is currently set, this method does
-   * nothing.
-   */
-  void unregisterDataSender();
-
-  void registerMoneySender(BilateralSender.MoneySender moneySender) throws MoneySenderAlreadyRegisteredException;
-
-  /**
-   * Removes the currently used {@oink DataSender}. This has the same effect as if {@link
-   * #registerDataSender(DataSender)} had never been called. If no bilateral sender is currently set, this method does
-   * nothing.
-   */
-  void unregisterMoneySender();
-
   /**
    * <p>Set the callback which is used to handle incoming prepared data packets. The handler should expect one
    * parameter (an ILP Prepare Packet) and return a CompletableFuture for the resulting response. If an error occurs,
@@ -90,7 +72,9 @@
    *
    * @param dataHandler An instance of {@link DataHandler}.
    */
-  void registerDataHandler(BilateralReceiver.DataHandler dataHandler) throws DataHandlerAlreadyRegisteredException;
+  void registerDataHandler(DataHandler dataHandler) throws DataHandlerAlreadyRegisteredException;
+
+  Optional<DataHandler> getDataHandler();
 
   /**
    * Removes the currently used {@link DataHandler}. This has the same effect as if {@link
@@ -99,10 +83,12 @@
    */
   void unregisterDataHandler();
 
+  Optional<MoneyHandler> getMoneyHandler();
+
   /**
    * <p>Set the callback which is used to handle incoming money. The callback should expect one parameter (the amount)
    * and return a {@link CompletableFuture}. If an error occurs, the callback MAY throw an exception. In general, the
-   * callback should behave as {@link MoneySender#sendMoney(BigInteger)} does.</p>
+   * callback should behave as {@link #sendMoney(BigInteger)} does.</p>
    *
    * <p>If a money handler is already set, this method throws a {@link MoneyHandlerAlreadyRegisteredException}. In
    * order to change the money handler, the old handler must first be removed via {@link #unregisterMoneyHandler()}.
@@ -113,7 +99,7 @@
    *
    * @param moneyHandler An instance of {@link MoneyHandler}.
    */
-  void registerMoneyHandler(BilateralReceiver.MoneyHandler moneyHandler) throws MoneyHandlerAlreadyRegisteredException;
+  void registerMoneyHandler(MoneyHandler moneyHandler) throws MoneyHandlerAlreadyRegisteredException;
 
   /**
    * Removes the currently used money handler. This has the same effect as if {@link
Index: ilp-plugin-core/src/main/java/org/interledger/plugin/lpiv2/AbstractPlugin.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ilp-plugin-core/src/main/java/org/interledger/plugin/lpiv2/AbstractPlugin.java	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
+++ ilp-plugin-core/src/main/java/org/interledger/plugin/lpiv2/AbstractPlugin.java	(date 1546463831000)
@@ -1,14 +1,14 @@
 package org.interledger.plugin.lpiv2;
 
+import org.interledger.plugin.BilateralReceiver.DataHandler;
+import org.interledger.plugin.BilateralReceiver.MoneyHandler;
 import org.interledger.plugin.lpiv2.events.PluginConnectedEvent;
 import org.interledger.plugin.lpiv2.events.PluginDisconnectedEvent;
 import org.interledger.plugin.lpiv2.events.PluginErrorEvent;
 import org.interledger.plugin.lpiv2.events.PluginEventEmitter;
 import org.interledger.plugin.lpiv2.events.PluginEventListener;
 import org.interledger.plugin.lpiv2.exceptions.DataHandlerAlreadyRegisteredException;
-import org.interledger.plugin.lpiv2.exceptions.DataSenderAlreadyRegisteredException;
 import org.interledger.plugin.lpiv2.exceptions.MoneyHandlerAlreadyRegisteredException;
-import org.interledger.plugin.lpiv2.exceptions.MoneySenderAlreadyRegisteredException;
 
 import com.google.common.collect.Maps;
 import org.slf4j.Logger;
@@ -39,11 +39,6 @@
   // The emitter used by this plugin.
   private PluginEventEmitter pluginEventEmitter;
 
-  private AtomicReference<DataSender> dataSenderAtomicReference = new AtomicReference<>();
-
-  // TODO: Use a no-op MoneyHandler by default, and remove checks in connect/disconnect.
-  private AtomicReference<MoneySender> moneySenderAtomicReference = new AtomicReference<>();
-
   private AtomicReference<DataHandler> dataHandlerAtomicReference = new AtomicReference<>();
 
   // TODO: Use a no-op MoneyHandler by default, and remove checks in connect/disconnect.
@@ -75,7 +70,7 @@
     try {
       if (this.connected.compareAndSet(NOT_CONNECTED, CONNECTED)) {
         logger.debug("[{}] `{}` connecting to `{}`...", this.pluginSettings.getPluginType(),
-            this.pluginSettings.getLocalNodeAddress(), this.getPluginSettings().getPeerAccountAddress());
+            this.pluginSettings.getLocalNodeAddress(), this.getPluginSettings().getAccountAddress());
 
         return this.doConnect()
             .whenComplete(($, error) -> {
@@ -84,18 +79,18 @@
                 this.pluginEventEmitter.emitEvent(PluginConnectedEvent.of(this));
 
                 logger.debug("[{}] `{}` connected to `{}`", this.getPluginSettings().getPluginType(),
-                    this.pluginSettings.getLocalNodeAddress(), this.getPluginSettings().getPeerAccountAddress());
+                    this.pluginSettings.getLocalNodeAddress(), this.getPluginSettings().getAccountAddress());
               } else {
                 final String errorMessage = String.format("[%s] `%s` error while trying to connect to `%s`",
                     this.pluginSettings.getPluginType(),
-                    this.pluginSettings.getLocalNodeAddress(), this.getPluginSettings().getPeerAccountAddress()
+                    this.pluginSettings.getLocalNodeAddress(), this.getPluginSettings().getAccountAddress()
                 );
                 logger.error(errorMessage, error);
               }
             });
       } else {
         logger.debug("[{}] `{}` already connected to `{}`...", this.pluginSettings.getPluginType(),
-            this.pluginSettings.getLocalNodeAddress(), this.getPluginSettings().getPeerAccountAddress());
+            this.pluginSettings.getLocalNodeAddress(), this.getPluginSettings().getAccountAddress());
         // No-op: We're already expectedCurrentState...
         return CompletableFuture.completedFuture(null);
       }
@@ -125,7 +120,7 @@
     try {
       if (this.connected.compareAndSet(CONNECTED, NOT_CONNECTED)) {
         logger.debug("[{}] `{}` disconnecting from `{}`...", this.pluginSettings.getPluginType(),
-            this.pluginSettings.getLocalNodeAddress(), this.getPluginSettings().getPeerAccountAddress());
+            this.pluginSettings.getLocalNodeAddress(), this.getPluginSettings().getAccountAddress());
 
         return this.doDisconnect()
             .whenComplete(($, error) -> {
@@ -134,22 +129,22 @@
                 this.pluginEventEmitter.emitEvent(PluginDisconnectedEvent.of(this));
 
                 logger.debug("[{}] `{}` disconnected from `{}`.", this.pluginSettings.getPluginType(),
-                    this.pluginSettings.getLocalNodeAddress(), this.getPluginSettings().getPeerAccountAddress());
+                    this.pluginSettings.getLocalNodeAddress(), this.getPluginSettings().getAccountAddress());
               } else {
                 final String errorMessage = String.format("[%s] `%s` error while trying to disconnect from `%s`",
                     this.pluginSettings.getPluginType(),
-                    this.pluginSettings.getLocalNodeAddress(), this.getPluginSettings().getPeerAccountAddress()
+                    this.pluginSettings.getLocalNodeAddress(), this.getPluginSettings().getAccountAddress()
                 );
                 logger.error(errorMessage, error);
               }
             })
             .thenAccept(($) -> {
               logger.debug("[{}] `{}` disconnected from `{}`...", this.pluginSettings.getPluginType(),
-                  this.pluginSettings.getLocalNodeAddress(), this.getPluginSettings().getPeerAccountAddress());
+                  this.pluginSettings.getLocalNodeAddress(), this.getPluginSettings().getAccountAddress());
             });
       } else {
         logger.debug("[{}] `{}` already disconnected from `{}`...", this.pluginSettings.getPluginType(),
-            this.pluginSettings.getLocalNodeAddress(), this.getPluginSettings().getPeerAccountAddress());
+            this.pluginSettings.getLocalNodeAddress(), this.getPluginSettings().getAccountAddress());
         // No-op: We're already expectedCurrentState...
         return CompletableFuture.completedFuture(null);
       }
@@ -189,28 +184,6 @@
     return this.pluginSettings;
   }
 
-  @Override
-  public void registerDataSender(final DataSender dataSender)
-      throws DataHandlerAlreadyRegisteredException {
-    Objects.requireNonNull(dataSender, "dataSender must not be null!");
-    if (!this.dataSenderAtomicReference.compareAndSet(null, dataSender)) {
-      throw new DataSenderAlreadyRegisteredException(
-          "DataSender may not be registered twice. Call unregisterDataSender first!",
-          this.getPluginSettings().getLocalNodeAddress()
-      );
-    }
-  }
-
-  @Override
-  public Optional<DataSender> getDataSender() {
-    return Optional.ofNullable(this.dataSenderAtomicReference.get());
-  }
-
-  @Override
-  public void unregisterDataSender() {
-    this.dataSenderAtomicReference.set(null);
-  }
-
   @Override
   public void registerDataHandler(final DataHandler ilpDataHandler)
       throws DataHandlerAlreadyRegisteredException {
@@ -223,11 +196,6 @@
     }
   }
 
-  @Override
-  public Optional<DataHandler> getDataHandler() {
-    return Optional.ofNullable(this.dataHandlerAtomicReference.get());
-  }
-
   @Override
   public void unregisterDataHandler() {
     this.dataHandlerAtomicReference.set(null);
@@ -255,28 +223,6 @@
     this.moneyHandlerAtomicReference.set(null);
   }
 
-  @Override
-  public Optional<MoneySender> getMoneySender() {
-    return Optional.ofNullable(moneySenderAtomicReference.get());
-  }
-
-  @Override
-  public void registerMoneySender(final MoneySender moneySender)
-      throws MoneySenderAlreadyRegisteredException {
-    Objects.requireNonNull(moneySender, "moneySender must not be null!");
-    if (!this.moneySenderAtomicReference.compareAndSet(null, moneySender)) {
-      throw new MoneyHandlerAlreadyRegisteredException(
-          "MoneySender may not be registered twice. Call unregisterMoneySender first!",
-          this.getPluginSettings().getLocalNodeAddress()
-      );
-    }
-  }
-
-  @Override
-  public void unregisterMoneySender() {
-    this.moneySenderAtomicReference.set(null);
-  }
-
   /**
    * An example {@link PluginEventEmitter} that allows events to be synchronously emitted into a {@link Plugin}.
    *
Index: ilp-plugin-grpc/src/main/proto/attic/btp3.proto
===================================================================
--- ilp-plugin-grpc/src/main/proto/attic/btp3.proto	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
+++ ilp-plugin-bpp-grpc/src/main/proto/attic/btp3.proto	(date 1543715958000)
@@ -1,0 +1,0 @@
Index: ilp-plugin-btp/src/main/java/org/interledger/plugin/lpiv2/btp2/BtpSender.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ilp-plugin-btp/src/main/java/org/interledger/plugin/lpiv2/btp2/BtpSender.java	(date 1546442443000)
+++ ilp-plugin-btp/src/main/java/org/interledger/plugin/lpiv2/btp2/BtpSender.java	(date 1546442443000)
@@ -0,0 +1,19 @@
+package org.interledger.plugin.lpiv2.btp2;
+
+import org.interledger.btp.BtpMessage;
+import org.interledger.btp.BtpResponsePacket;
+import org.interledger.btp.BtpTransfer;
+
+import java.util.concurrent.CompletableFuture;
+
+/**
+ * Defines the contract that any sender of BTP packets must implement.
+ */
+public interface BtpSender {
+
+  // Can either be a BtpResponse or a BtpError...
+  CompletableFuture<BtpResponsePacket> sendBtpMessage(BtpMessage btpMessage);
+
+  // Can either be a BtpResponse or a BtpError...
+  CompletableFuture<BtpResponsePacket> sendBtpTransfer(BtpTransfer btpTransfer);
+}
Index: ilp-plugin-core/src/main/java/org/interledger/plugin/lpiv2/LoopbackPlugin.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ilp-plugin-core/src/main/java/org/interledger/plugin/lpiv2/LoopbackPlugin.java	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
+++ ilp-plugin-core/src/main/java/org/interledger/plugin/lpiv2/LoopbackPlugin.java	(date 1546391136000)
@@ -53,7 +53,7 @@
     // Sending Money on a Loopback plugin is a no-op
     this.registerMoneySender((amount) -> CompletableFuture.completedFuture(null));
 
-    // This is called when the other side of the account relationship has called sendMoney, and a packet has been
+    // This is called when the other side of the account relationship has called sendData, and a packet has been
     // forward (usually through a Connector) to this plugin, which will handle the incoming prepare packet.
     this.registerDataHandler((incomingPreparePacket) -> CompletableFuture.supplyAsync(() -> {
           final byte[] preimage = Arrays.copyOfRange(incomingPreparePacket.getData(), 0, 32);
@@ -76,7 +76,7 @@
     return PluginSettings.builder()
         .pluginType(LoopbackPlugin.PLUGIN_TYPE)
         .localNodeAddress(localNodeAddress)
-        .peerAccountAddress(accountAddress)
+        .accountAddress(accountAddress)
         .build();
   }
 
Index: ilp-plugin-bpp-grpc/src/main/proto/bpp.proto
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ilp-plugin-bpp-grpc/src/main/proto/bpp.proto	(date 1545327203000)
+++ ilp-plugin-bpp-grpc/src/main/proto/bpp.proto	(date 1545327203000)
@@ -0,0 +1,40 @@
+syntax = "proto3";
+
+option java_multiple_files = false;
+option java_package = "org.interledger.bpp.grpc";
+option java_outer_classname = "BppProto";
+option objc_class_prefix = "BPP";
+
+package interledger;
+
+import public "google/protobuf/empty.proto";
+
+// BPP: Bilateral Push Protocol is a synchronous RPC service (i.e., non-streaming) that allows nodes to send and receive
+// bilateral messages, possibly relating to multiple accounts, using the same gRPC transport. In this setup, each node
+// operates a single gRPC client and a single gRPC server. Incoming requests come in from the remote on the gRPC server,
+// and responses are returned on this server transport path. Outgoing requests go out to the remote using the gRPC client,
+// with those repsonses being returned back on the same gRPC client.
+
+// Note that any custom information for these requests must be supplied in meta-data using gRPC headers, since there is
+// no direct support for sub-protocols in BPP.
+service Bpp {
+
+    rpc TestConnection (google.protobuf.Empty) returns (google.protobuf.Empty) {
+    }
+
+    // Send an ILP Prepare packet.
+    rpc Send (BppPrepare) returns (BppResponse) {
+    }
+}
+
+// An envelope for an Interledger Prepare Packet.
+message BppPrepare {
+    string accountAddress = 1; // The Account this packet should be attached to.
+    bytes preparePacketBytes = 2;
+}
+
+// An envelope for an Interledger Packet (fulfill, or reject).
+message BppResponse {
+    string accountAddress = 1; // The Account this packet should be attached to.
+    bytes responsePacketBytes = 2;
+}
\ No newline at end of file
Index: ilp-plugin-btp/src/main/java/org/interledger/plugin/lpiv2/btp2/AbstractBtpPlugin_OldWithMux.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ilp-plugin-btp/src/main/java/org/interledger/plugin/lpiv2/btp2/AbstractBtpPlugin_OldWithMux.java	(date 1546455949000)
+++ ilp-plugin-btp/src/main/java/org/interledger/plugin/lpiv2/btp2/AbstractBtpPlugin_OldWithMux.java	(date 1546455949000)
@@ -0,0 +1,376 @@
+package org.interledger.plugin.lpiv2.btp2;
+
+import static org.interledger.btp.BtpSubProtocol.ContentType.MIME_APPLICATION_OCTET_STREAM;
+import static org.interledger.plugin.lpiv2.btp2.subprotocols.BtpSubProtocolHandlerRegistry.BTP_SUB_PROTOCOL_AUTH;
+import static org.interledger.plugin.lpiv2.btp2.subprotocols.BtpSubProtocolHandlerRegistry.BTP_SUB_PROTOCOL_AUTH_TOKEN;
+import static org.interledger.plugin.lpiv2.btp2.subprotocols.BtpSubProtocolHandlerRegistry.BTP_SUB_PROTOCOL_AUTH_USERNAME;
+import static org.interledger.plugin.lpiv2.btp2.subprotocols.BtpSubProtocolHandlerRegistry.BTP_SUB_PROTOCOL_ILP;
+
+import org.interledger.btp.BtpErrorCode;
+import org.interledger.btp.BtpMessage;
+import org.interledger.btp.BtpPacket;
+import org.interledger.btp.BtpResponse;
+import org.interledger.btp.BtpRuntimeException;
+import org.interledger.btp.BtpSession;
+import org.interledger.btp.BtpSubProtocol;
+import org.interledger.btp.BtpSubProtocols;
+import org.interledger.core.InterledgerErrorCode;
+import org.interledger.core.InterledgerFulfillPacket;
+import org.interledger.core.InterledgerPacket;
+import org.interledger.core.InterledgerProtocolException;
+import org.interledger.core.InterledgerRejectPacket;
+import org.interledger.core.InterledgerResponsePacket;
+import org.interledger.encoding.asn.framework.CodecContext;
+import org.interledger.plugin.lpiv2.AbstractPlugin;
+import org.interledger.plugin.lpiv2.Plugin;
+import org.interledger.plugin.lpiv2.btp2.subprotocols.AbstractBtpSubProtocolHandler;
+import org.interledger.plugin.lpiv2.btp2.subprotocols.BtpSubProtocolHandlerRegistry;
+import org.interledger.plugin.lpiv2.btp2.subprotocols.ilp.IlpBtpSubprotocolHandler;
+import org.interledger.plugin.lpiv2.exceptions.DataHandlerAlreadyRegisteredException;
+
+import java.nio.charset.StandardCharsets;
+import java.security.SecureRandom;
+import java.util.Objects;
+import java.util.Optional;
+import java.util.Random;
+import java.util.concurrent.CompletableFuture;
+
+/**
+ * <p>An extension of {@link AbstractPlugin} that is capable of representing a data channel with no money involved.
+ * This class takes care of most of the work of translating between BTP and the ledger plugin interface (LPI), and will
+ * send BTP messages with no knowledge of the data within, so it can be used for ILP packets. The implementation
+ * returned by {@link #getMoneySender()} is a no-op because, by default, there is no system involved in handling money
+ * with BTP.</p>
+ *
+ * <p>Two features must be defined in order for this Plugin to handle money. The first is
+ * {@link #getMoneySender()}, which sends an amount of units to the peer for this Plugin. This should be done via a BTP
+ * <tt>TRANSFER</tt> call. The second method is {@link #getMoneyHandler()}, which is called
+ * on an incoming BTP <tt>TRANSFER</tt> message.</p>
+ *
+ * <p>The main use of this Plugin, however, is as a building block for plugins that _do_ have an underlying ledger.</p>
+ *
+ * @deprecated BTP Functionality should be delegated to the BTP Mux.
+ */
+@Deprecated
+public abstract class AbstractBtpPlugin_OldWithMux<T extends BtpPluginSettings> extends AbstractPlugin<T> implements Plugin<T> {
+
+  private final CodecContext ilpCodecContext;
+  private final CodecContext btpCodecContext;
+  private final Random random;
+  private final BtpSubProtocolHandlerRegistry btpSubProtocolHandlerRegistry;
+
+  /**
+   * Required-args Constructor.
+   */
+  public AbstractBtpPlugin_OldWithMux(
+      final T pluginSettings,
+      final CodecContext ilpCodecContext,
+      final CodecContext btpCodecContext,
+      final BtpSubProtocolHandlerRegistry btpSubProtocolHandlerRegistry
+  ) {
+    super(pluginSettings);
+    this.ilpCodecContext = Objects.requireNonNull(ilpCodecContext);
+    this.btpCodecContext = Objects.requireNonNull(btpCodecContext);
+    this.btpSubProtocolHandlerRegistry = btpSubProtocolHandlerRegistry;
+    this.random = new SecureRandom();
+
+    // No need to do anything with the data-handler because it's overridden below.
+    // Peg the dataSender to this class's implementation so that it always translates to BTP in order to send.
+    super.registerDataSender(this::sendData);
+
+    // No-op because there is no money-handling in default BTP.
+    super.registerMoneyHandler((amount) -> CompletableFuture.completedFuture(null));
+    super.registerMoneySender((amount) -> CompletableFuture.completedFuture(null));
+  }
+
+  /**
+   * <p>Handles an incoming {@link BtpMessage} by delegating it to a registered handler.</p>
+   *
+   * <p>There are also a couple of tricky cases to handle:</p>
+   *
+   * <ul>
+   * <li>If an unexpected BTP packet is received, no response should be sent. An unexpected BTP packet is a
+   * response for which a request was not sent, or a response for a request which has already been responded to.</li>
+   * <li>If an unreadable BTP packet is received, no response should be sent. An unreadable BTP packet is one which
+   * is structurally invalid, i.e. terminates before length prefixes dictate or contains illegal characters.</li>
+   * </ul>
+   *
+   * <p>Incoming BTP messages can be either requests or responses, so sub-classes should be careful to handle both
+   * types of message, especially when bridging to synchronous API contracts, where it may become confusing as to
+   * whether an incoming message corresponds to the input our output portion of a particular synchronous method.</p>
+   *
+   * @param btpSession
+   * @param incomingBtpMessage
+   *
+   * @return
+   */
+  // TODO: Use future?
+  public BtpResponse onIncomingBtpMessage(final BtpSession btpSession, final BtpMessage incomingBtpMessage)
+      throws BtpRuntimeException {
+
+    Objects.requireNonNull(btpSession);
+    Objects.requireNonNull(incomingBtpMessage);
+
+    try {
+      final BtpSubProtocols responses = new BtpSubProtocols();
+
+      // Only the primary sub-protocol should be handled. The secondary sub-protocols should not request additional
+      // actions or information. If multiple actions or pieces of information are required, multiple separate Messages
+      // should be sent. The secondary sub-protocols should only modify the request made in the primary sub-protocol, or
+      // provide additional contextual data which can be consumed in a readonly way (without affecting the result).
+      final BtpSubProtocol primarySubprotocol = incomingBtpMessage.getPrimarySubProtocol();
+      final AbstractBtpSubProtocolHandler handler =
+          this.btpSubProtocolHandlerRegistry
+              .getHandler(primarySubprotocol.getProtocolName(), primarySubprotocol.getContentType())
+              .orElseThrow(() -> new BtpRuntimeException(
+                  BtpErrorCode.F00_NotAcceptedError,
+                  String.format("No BTP Handler registered for BTP SubProtocol: %s",
+                      primarySubprotocol.getProtocolName()))
+              );
+
+      final CompletableFuture<Optional<BtpSubProtocol>> btpSubProtocolResponse = handler
+          .handleSubprotocolMessage(btpSession, incomingBtpMessage);
+
+      // Add the response, but only if it's present.
+      btpSubProtocolResponse.get().ifPresent(responses::add);
+
+      // Now that there's a proper response, send it back to the connected client...
+      return BtpResponse.builder()
+          .requestId(incomingBtpMessage.getRequestId())
+          .subProtocols(responses)
+          .build();
+    } catch (Exception e) {
+      throw new BtpRuntimeException(BtpErrorCode.T00_UnreachableError, e.getMessage(), e);
+    }
+  }
+
+  /**
+   * Allows a sub-class to implement the actual logic of sending a {@link BtpPacket} over the appropriate mux, such we
+   * Websockets.
+   *
+   * @param btpMessage A {@link BtpMessage}.
+   *
+   * @return A {@link CompletableFuture} that yields a {@link BtpResponse}.
+   */
+  protected abstract CompletableFuture<Optional<BtpResponse>> doSendDataOverBtp(final BtpPacket btpMessage)
+      throws BtpRuntimeException;
+
+  protected CodecContext getIlpCodecContext() {
+    return ilpCodecContext;
+  }
+
+  protected CodecContext getBtpCodecContext() {
+    return btpCodecContext;
+  }
+
+  /**
+   * Returns the next random request id using a PRNG.
+   */
+  protected long nextRequestId() {
+    return Math.abs(random.nextInt());
+  }
+
+  /**
+   * An authentication message must have as its primary <tt>protocolData</tt> entry must have the name of 'auth',
+   * content type <tt>MIME_APPLICATION_OCTET_STREAM</tt>, and empty data, and among the secondary entries, there MUST be
+   * a UTF-8 'auth_token' entry.
+   *
+   * @return
+   */
+  public BtpMessage constructAuthMessage(
+      final long requestId, final String authToken, final Optional<String> authUserName
+  ) {
+    Objects.requireNonNull(authToken);
+    Objects.requireNonNull(authUserName);
+
+    final BtpSubProtocol authSubProtocol = BtpSubProtocol.builder()
+        .protocolName(BTP_SUB_PROTOCOL_AUTH)
+        .contentType(BtpSubProtocol.ContentType.MIME_APPLICATION_OCTET_STREAM)
+        .build();
+    final BtpSubProtocols btpSubProtocols = BtpSubProtocols.fromPrimarySubProtocol(authSubProtocol);
+
+    // In situations where no authentication is needed, the 'auth_token' data can be set to the empty string,
+    // but it cannot be omitted.
+    final BtpSubProtocol authTokenSubprotocol = BtpSubProtocol.builder()
+        .protocolName(BTP_SUB_PROTOCOL_AUTH_TOKEN)
+        .contentType(BtpSubProtocol.ContentType.MIME_APPLICATION_OCTET_STREAM)
+        .data(authToken.getBytes(StandardCharsets.UTF_8))
+        .build();
+    btpSubProtocols.add(authTokenSubprotocol);
+
+    authUserName.ifPresent($ -> {
+      final BtpSubProtocol authUsernameSubprotocol = BtpSubProtocol.builder()
+          .protocolName(BTP_SUB_PROTOCOL_AUTH_USERNAME)
+          .contentType(BtpSubProtocol.ContentType.MIME_APPLICATION_OCTET_STREAM)
+          .data($.getBytes(StandardCharsets.UTF_8))
+          .build();
+      btpSubProtocols.add(authUsernameSubprotocol);
+    });
+
+    return BtpMessage.builder()
+        .requestId(requestId)
+        .subProtocols(btpSubProtocols)
+        .build();
+  }
+
+//  private BtpError constructBtpError(final long requestId, final BtpRuntimeException btpRuntimeException) {
+//    Objects.requireNonNull(btpRuntimeException);
+//    return BtpError.builder()
+//        .requestId(requestId)
+//        .errorCode(btpRuntimeException.getCode())
+//        .triggeredAt(btpRuntimeException.getTriggeredAt())
+//        .errorData(btpRuntimeException.getMessage().getBytes(Charset.forName("UTF-8")))
+//        .build();
+//  }
+
+  //////////////////////
+  // Helper Methods
+  //////////////////////
+
+//  protected final BtpError constructBtpError(final long requestId, final String errorData) {
+//    Objects.requireNonNull(errorData);
+//
+//    // Respond with a BTP Error on the websocket session.
+//    return this.constructBtpError(requestId, errorData, Instant.now(), BtpErrorCode.F00_NotAcceptedError);
+//  }
+
+//  protected final BtpError constructBtpError(final long requestId, final String errorData,
+//      final Instant triggeredAt, final BtpErrorCode btpErrorCode) {
+//    Objects.requireNonNull(errorData);
+//
+//    // Respond with a BTP Error on the websocket session.
+//    return BtpError.builder()
+//        .requestId(requestId)
+//        .triggeredAt(triggeredAt)
+//        .errorCode(btpErrorCode)
+//        .errorData(errorData.getBytes(Charset.forName("UTF-8")))
+//        .build();
+//  }
+
+  public BtpSubProtocolHandlerRegistry getBtpSubProtocolHandlerRegistry() {
+    return btpSubProtocolHandlerRegistry;
+  }
+
+  // All BTP Plugins forward to the BtpSubprotocol registry to handle data.
+  @Override
+  public Optional<DataHandler> getDataHandler() {
+    // When this plugin receives a new DataHandler, it must be connected to the BtpSubProtocol registered in the registry,
+    // so we always just return that handler, if present.
+    return this.getBtpSubProtocolHandlerRegistry()
+        .getHandler(BTP_SUB_PROTOCOL_ILP, MIME_APPLICATION_OCTET_STREAM)
+        .map(ilpHandler -> (IlpBtpSubprotocolHandler) ilpHandler)
+        .map(IlpBtpSubprotocolHandler::getDataHandler);
+  }
+
+  // All BTP Plugins forward to the BtpSubprotocol registry to handle data.
+  @Override
+  public void unregisterDataHandler() {
+    final IlpBtpSubprotocolHandler handler = this.getBtpSubProtocolHandlerRegistry()
+        .getHandler(BTP_SUB_PROTOCOL_ILP, MIME_APPLICATION_OCTET_STREAM)
+        .map(abstractHandler -> (IlpBtpSubprotocolHandler) abstractHandler)
+        .orElseThrow(() -> new RuntimeException(
+            String.format("BTP subprotocol handler with name `%s` MUST be registered!", BTP_SUB_PROTOCOL_ILP)));
+
+    handler.unregisterDataHandler();
+  }
+
+  // All BTP Plugins forward to the BtpSubprotocol registry to handle data.
+  @Override
+  public void registerDataHandler(final DataHandler ilpDataHandler) throws DataHandlerAlreadyRegisteredException {
+    // The BilateralDataHandler for Btp Plugins is always the ILP handler registered with the BtpProtocolRegistry, so setting
+    // a handler here should overwrite the handler there.
+
+    final IlpBtpSubprotocolHandler handler = this.getBtpSubProtocolHandlerRegistry()
+        .getHandler(BTP_SUB_PROTOCOL_ILP, MIME_APPLICATION_OCTET_STREAM)
+        .map(abstractHandler -> (IlpBtpSubprotocolHandler) abstractHandler)
+        .orElseThrow(() -> new RuntimeException(
+            String.format("BTP subprotocol handler with name `%s` MUST be registered!", BTP_SUB_PROTOCOL_ILP)));
+
+    handler.registerDataHandler(getPluginSettings().getLocalNodeAddress(), ilpDataHandler);
+  }
+
+  /**
+   * Translates an ILP Prepare Packet into BTP for further processing.
+   *
+   * @param preparePacket
+   *
+   * @return
+   */
+  private final CompletableFuture<Optional<InterledgerResponsePacket>> sendData(final InterledgerPacket preparePacket) {
+
+    Objects.requireNonNull(preparePacket);
+
+    // TODO: Implement re-connection logic, but only if this is a BTP Client. Servers simply have to wait to be
+    // connected...
+    // If the plugin is not connected, then throw an exception...
+    if (!this.isConnected()) {
+      throw new InterledgerProtocolException(
+          InterledgerRejectPacket.builder()
+              .message("Plugin not connected!")
+              .triggeredBy(getPluginSettings().getLocalNodeAddress())
+              .code(InterledgerErrorCode.T01_LEDGER_UNREACHABLE)
+              .build()
+      );
+    }
+
+    //if(this.get)
+
+    // From JS...
+    //      type: BtpPacket.TYPE_MESSAGE,
+    //        requestId: await _requestId(),
+    //      data: { protocolData: [{
+    //      protocolName: 'ilp',
+    //        contentType: BtpPacket.MIME_APPLICATION_OCTET_STREAM,
+    //        data: buffer
+    //    }] }
+    //    }
+
+    // This is just a translation layer. Transmit the above `preparePacket` to a remote peer via BTP.
+    final BtpSubProtocol ilpSubProtocol = IlpBtpSubprotocolHandler
+        .toBtpSubprotocol(preparePacket, ilpCodecContext);
+    final BtpMessage btpMessage = BtpMessage.builder()
+        .requestId(nextRequestId())
+        .subProtocols(BtpSubProtocols.fromPrimarySubProtocol(ilpSubProtocol))
+        .build();
+
+    // This is synchronized by the Map...
+    //    if (this.acknowledgedRequests.putIfAbsent(btpMessage.getRequestId(), false) == false) {
+    //      // The request is already pending, so throw an exception.
+    //      throw new RuntimeException(
+    //        String.format("Encountered duplicate requestId: `%s`", btpMessage.getRequestId()));
+    //    }
+
+    // TODO: FIXME per https://stackoverflow.com/questions/33913193/completablefuture-waiting-for-first-one-normally-return
+
+    final CompletableFuture<Optional<InterledgerResponsePacket>> response = this.doSendDataOverBtp(btpMessage)
+        .thenApply(btpResponse -> btpResponse
+            .map($ -> IlpBtpSubprotocolHandler.toIlpPacket($, ilpCodecContext))
+            .map(Optional::of)
+            .orElse(Optional.empty())
+        )
+        .thenApply(ilpPacket -> ilpPacket
+            .map(p -> {
+              // Convert the ilpPacket into either a fulfill or an exception.
+              // TODO Use InterlederPacketHandler if this sticks around...
+              if (InterledgerFulfillPacket.class.isAssignableFrom(p.getClass())) {
+                return (InterledgerFulfillPacket) p;
+              } else {
+                return (InterledgerRejectPacket) p;
+              }
+            })
+            .map(Optional::of)
+            .orElse(Optional.empty())
+        );
+
+    // NOTE: Request/Response matching is a function of Websockets and being able to
+    return response;
+  }
+
+  @Override
+  public final void registerDataSender(final DataSender dataSender) throws DataHandlerAlreadyRegisteredException {
+    throw new RuntimeException(
+        "BTP Plugins may not register a customer DataSender because all send operations flow over BTP!");
+  }
+
+
+}
Index: ilp-plugin-grpc/src/main/proto/attic/grinterledger_stream.proto
===================================================================
--- ilp-plugin-grpc/src/main/proto/attic/grinterledger_stream.proto	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
+++ ilp-plugin-bpp-grpc/src/main/proto/attic/bpp_stream.proto	(date 1545319046000)
@@ -1,7 +1,7 @@
 syntax = "proto3";
 
 //option java_multiple_files = false;
-//option java_package = "org.interledger.org.interledger.plugin.mux.grpc.stream";
+//option java_package = "org.interledger.org.interledger.plugin.lpiv2.bpp.mux.grpc.stream";
 //option java_outer_classname = "PinterledgerStreamProto";
 //option objc_class_prefix = "PINTS";
 //
Index: ilp-plugin-grpc/src/main/java/org/interledger/plugin/lpiv2/grpc/GrpcPluginSettings.java
===================================================================
--- ilp-plugin-grpc/src/main/java/org/interledger/plugin/lpiv2/grpc/GrpcPluginSettings.java	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
+++ ilp-plugin-bpp-grpc/src/main/java/org/interledger/plugin/lpiv2/bpp/grpc/GrpcPluginSettings.java	(date 1545319046000)
@@ -1,4 +1,4 @@
-package org.interledger.plugin.lpiv2.grpc;
+package org.interledger.plugin.lpiv2.bpp.grpc;
 
 import org.interledger.plugin.lpiv2.PluginSettings;
 
Index: ilp-plugin-grpc/src/main/java/org/interledger/plugin/mux/grpc/bpp/GrpcBppPushConnectionSettings.java
===================================================================
--- ilp-plugin-grpc/src/main/java/org/interledger/plugin/mux/grpc/bpp/GrpcBppPushConnectionSettings.java	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
+++ ilp-plugin-bpp-grpc/src/main/java/org/interledger/plugin/lpiv2/bpp/grpc/connection/BppConnectionSettings.java	(date 1545411592000)
@@ -1,10 +1,10 @@
-package org.interledger.plugin.mux.grpc.bpp;
+package org.interledger.plugin.lpiv2.bpp.grpc.connection;
 
-import org.interledger.plugin.connections.BilateralConnectionSettings;
+import org.interledger.plugin.connections.settings.BilateralConnectionSettings;
 
 import org.immutables.value.Value;
 
-public interface GrpcBppPushConnectionSettings extends BilateralConnectionSettings {
+public interface BppConnectionSettings extends BilateralConnectionSettings {
 
   /**
    * The HTTP host to connect to in order to speak gRPC.
@@ -44,7 +44,7 @@
   //String getSecret();
 
   @Value.Immutable
-  abstract class AbstractGrpcBppPushConnectionSettings implements GrpcBppPushConnectionSettings {
+  abstract class AbstractBppConnectionSettings implements BppConnectionSettings {
 
   }
 }
Index: ilp-plugin-btp/src/main/java/org/interledger/plugin/lpiv2/btp2/subprotocols/ilp/IlpBtpSubprotocolHandler.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ilp-plugin-btp/src/main/java/org/interledger/plugin/lpiv2/btp2/subprotocols/ilp/IlpBtpSubprotocolHandler.java	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
+++ ilp-plugin-btp/src/main/java/org/interledger/plugin/lpiv2/btp2/subprotocols/ilp/IlpBtpSubprotocolHandler.java	(date 1546454644000)
@@ -84,7 +84,10 @@
    * @param ilpCodecContext A {@link CodecContext} that can operate on ILP primitives.
    *
    * @return A {@link BtpSubProtocol}
+   *
+   * @deprecated Replace with {@link IlpBtpConverter}
    */
+  @Deprecated
   public static BtpSubProtocol toBtpSubprotocol(
       final InterledgerPacket ilpPacket, final CodecContext ilpCodecContext
   ) {
@@ -111,7 +114,10 @@
    * @param ilpCodecContext A {@link CodecContext} that can read ILP Packets.
    *
    * @return An newly constructed {@link InterledgerPacket}.
+   *
+   * @deprecated Replace with {@link IlpBtpConverter}
    */
+  @Deprecated
   public static InterledgerResponsePacket toIlpPacket(
       BtpResponse btpResponse, final CodecContext ilpCodecContext
   ) {
Index: ilp-plugin-btp-springws/src/main/java/org/interledger/plugin/lpiv2/btp2/spring/connection/mux/ServerBtpWebsocketMux.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ilp-plugin-btp-springws/src/main/java/org/interledger/plugin/lpiv2/btp2/spring/connection/mux/ServerBtpWebsocketMux.java	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
+++ ilp-plugin-btp-springws/src/main/java/org/interledger/plugin/lpiv2/btp2/spring/connection/mux/ServerBtpWebsocketMux.java	(date 1546456178000)
@@ -1,7 +1,6 @@
 package org.interledger.plugin.lpiv2.btp2.spring.connection.mux;
 
 import org.interledger.btp.BtpSession;
-import org.interledger.plugin.BilateralReceiver;
 import org.interledger.plugin.connections.mux.AbstractBilateralComboMux;
 import org.interledger.plugin.lpiv2.btp2.spring.BtpSessionUtils;
 import org.interledger.plugin.lpiv2.btp2.spring.converters.BinaryMessageToBtpPacketConverter;
@@ -15,13 +14,14 @@
 import org.springframework.web.socket.WebSocketSession;
 
 import java.util.concurrent.CompletableFuture;
-import java.util.concurrent.TimeUnit;
-import java.util.stream.Collectors;
 
 /**
  * <p>An extension of {@link AbstractBilateralComboMux} that accepts incoming Websocket connections from various hosts.
  * Once authenticated, each host can connect to a plugin for actual handling.</p>
+ *
+ * @deprecated Muxes are replaced by BilateralConnections.
  */
+@Deprecated
 public class ServerBtpWebsocketMux extends AbstractBtpWebsocketComboMux implements WebSocketHandler {
 
   public ServerBtpWebsocketMux(
@@ -114,7 +114,6 @@
     // one.
     this.disconnect();
 
-
 //    final CompletableFuture[] disconnectFutures = this.getBilateralReceivers().values().stream()
 //        .map(BilateralReceiver::disconnect)
 //        .collect(Collectors.toList())
Index: ilp-plugin-grpc/src/main/java/org/interledger/plugin/lpiv2/grpc/GrpcBppPushPlugin.java
===================================================================
--- ilp-plugin-grpc/src/main/java/org/interledger/plugin/lpiv2/grpc/GrpcBppPushPlugin.java	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
+++ ilp-plugin-bpp-grpc/src/main/java/org/interledger/plugin/lpiv2/bpp/grpc/GrpcBppPushPlugin.java	(date 1545669025000)
@@ -1,4 +1,4 @@
-package org.interledger.plugin.lpiv2.grpc;
+package org.interledger.plugin.lpiv2.bpp.grpc;
 
 import org.interledger.encoding.asn.framework.CodecContext;
 import org.interledger.plugin.connections.mux.BilateralReceiverMux;
@@ -28,8 +28,8 @@
     this.senderMux = Objects.requireNonNull(senderMux);
     this.receiverMux = Objects.requireNonNull(receiverMux);
 
-    this.senderMux.registerBilateralSender(pluginSettings.getPeerAccountAddress(), this);
-    this.receiverMux.registerBilateralReceiver(pluginSettings.getPeerAccountAddress(), this);
+    this.senderMux.registerBilateralSender(pluginSettings.getAccountAddress(), this);
+    this.receiverMux.registerBilateralReceiver(pluginSettings.getAccountAddress(), this);
   }
 
   /**
Index: ilp-plugin-btp-springws/src/main/java/org/interledger/plugin/lpiv2/btp2/spring/package-info.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ilp-plugin-btp-springws/src/main/java/org/interledger/plugin/lpiv2/btp2/spring/package-info.java	(date 1545325650000)
+++ ilp-plugin-btp-springws/src/main/java/org/interledger/plugin/lpiv2/btp2/spring/package-info.java	(date 1545325650000)
@@ -0,0 +1,16 @@
+/**
+ * <p>Contains all implementations of connections, muxes, and plugins to support BTP over Websockets.</p>
+ *
+ * <p>From the perspective of an ILP connector, BTP client-accounts will be configured at runtime with proper
+ * connection parameters, and will then instantiate a new {@link org.interledger.plugin.lpiv2.btp2.spring.ClientWebsocketBtpPlugin}
+ * for each connection.</p>
+ *
+ * <p>From the perspective of an ILP connector, BTP server-accounts have two flavors: single-account BTP and
+ * multi-account BTP. Single-account BTP is configured at runtime by constructing an instance of {@link
+ * org.interledger.plugin.lpiv2.btp2.spring.connection.SingleAccountBtpServerConnection}. Likewise, a multi-account
+ * Connection is established by constructing an instance of {@link org.interledger.plugin.lpiv2.btp2.spring.connection.MultiAccountBtpServerConnection}.
+ * From here, plugins can be obtained from a MUX, which can then be used to obtain a bilateral sender/receiver, which is
+ * typically a {@link org.interledger.plugin.lpiv2.Plugin}.</p>
+ */
+
+package org.interledger.plugin.lpiv2.btp2.spring;
\ No newline at end of file
Index: ilp-plugin-btp-springws/pom.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ilp-plugin-btp-springws/pom.xml	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
+++ ilp-plugin-btp-springws/pom.xml	(date 1545318002000)
@@ -11,9 +11,9 @@
 
   <artifactId>ilp-plugin-btp-springws</artifactId>
 
-  <name>ILP Plugin BTP 2.0 over Spring WebSockets</name>
+  <name>ILP Plugin BTP over Spring WebSockets</name>
   <description>
-    Java implementation of a BTP Plugin that communicates over WebSockets using Spring libraries.
+    Java implementation of a BTP 2.0 Plugin that communicates over WebSockets using Spring libraries.
   </description>
 
   <properties>
Index: ilp-plugin-btp-springws/src/main/java/org/interledger/plugin/lpiv2/btp2/spring/connection/mux/AbstractBtpWebsocketComboMux.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ilp-plugin-btp-springws/src/main/java/org/interledger/plugin/lpiv2/btp2/spring/connection/mux/AbstractBtpWebsocketComboMux.java	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
+++ ilp-plugin-btp-springws/src/main/java/org/interledger/plugin/lpiv2/btp2/spring/connection/mux/AbstractBtpWebsocketComboMux.java	(date 1546456178000)
@@ -11,6 +11,7 @@
 import org.interledger.btp.BtpPacket;
 import org.interledger.btp.BtpPacketMapper;
 import org.interledger.btp.BtpResponse;
+import org.interledger.btp.BtpResponsePacket;
 import org.interledger.btp.BtpRuntimeException;
 import org.interledger.btp.BtpSession;
 import org.interledger.btp.BtpSessionCredentials;
@@ -19,6 +20,8 @@
 import org.interledger.btp.BtpSubProtocols;
 import org.interledger.btp.BtpTransfer;
 import org.interledger.plugin.connections.mux.AbstractBilateralComboMux;
+import org.interledger.plugin.lpiv2.btp2.BtpReceiver;
+import org.interledger.plugin.lpiv2.btp2.BtpSender;
 import org.interledger.plugin.lpiv2.btp2.spring.BtpSessionUtils;
 import org.interledger.plugin.lpiv2.btp2.spring.converters.BinaryMessageToBtpPacketConverter;
 import org.interledger.plugin.lpiv2.btp2.spring.converters.BtpConversionException;
@@ -48,8 +51,11 @@
 /**
  * <p>An extension of {@link AbstractBilateralComboMux} that accepts incoming Websocket connections from various hosts
  * that speak BTP. Once authenticated, each host can connect to a plugin for actual handling.</p>
+ *
+ * @deprecated Muxes are replaced by BilateralConnections.
  */
-public abstract class AbstractBtpWebsocketComboMux extends AbstractBilateralComboMux {
+@Deprecated
+public abstract class AbstractBtpWebsocketComboMux extends AbstractBilateralComboMux implements BtpSender, BtpReceiver {
 
   protected final BinaryMessageToBtpPacketConverter binaryMessageToBtpPacketConverter;
   protected final BtpPacketToBinaryMessageConverter btpPacketToBinaryMessageConverter;
@@ -57,7 +63,7 @@
   // TODO: Use WeakHashMap?
   // When the client sends a request out to a peer, it will wait for an async response from that peer. When that
   // response comes back, it will be combined with a pending response.
-  protected final Map<Long, CompletableFuture<Optional<BtpResponse>>> pendingResponses;
+  protected final Map<Long, CompletableFuture<BtpResponsePacket>> pendingResponses;
 
   private final BtpSubProtocolHandlerRegistry btpSubProtocolHandlerRegistry;
 
@@ -79,6 +85,125 @@
     this.random = new SecureRandom();
   }
 
+  ////////////////////
+  // BtpSender Methods
+  ////////////////////
+
+  /**
+   * Converts {@code btpMessage} into the proper binary format and then sends the payload out over the websocket,
+   * waiting for a response.
+   */
+  @Override
+  public CompletableFuture<BtpResponsePacket> sendBtpMessage(final BtpMessage btpMessage) {
+    Objects.requireNonNull(btpMessage);
+
+    // Translate the btpMessage to a BinaryMessage, and send out using the WebSocketSession.
+    return this.webSocketSession
+        .map(wss -> {
+          final BinaryMessage binaryMessage = this.btpPacketToBinaryMessageConverter.convert(btpMessage);
+          final long requestId = nextRequestId();
+          return this.sendMessageWithPendingRepsonse(requestId, wss, binaryMessage)
+              .handle((response, error) -> {
+                if (error != null) {
+                  // the pending response timed out or otherwise had a problem...
+                  throw new RuntimeException(error.getMessage(), error);
+                } else {
+                  // Might be an error or a response`
+                  return response;
+                }
+              });
+        }).orElseThrow(() -> new RuntimeException("No WebSocket session!"));
+  }
+
+  @Override
+  public CompletableFuture<BtpResponsePacket> sendBtpTransfer(BtpTransfer btpTransfer) {
+    throw new RuntimeException("FIXME!");
+    //return CompletableFuture.completedFuture(null);
+  }
+
+  //////////////////////
+  // BtpReceiver Methods
+  //////////////////////
+
+  /**
+   * Handle an incoming BTP Packet. The payload may be a BTP Request type, or it may be a BTP response type, so
+   * implementations must handle all BTP packet types approporiately.
+   *
+   * @param incomingBtpPacket A {@link BtpPacket} sent from the bilateral BTP peer.
+   *
+   * @return An optionally-present response of type {@link BtpResponsePacket}.
+   */
+  @Override
+  public Optional<BtpResponsePacket> handleBtpPacket(final BtpSession btpSession, final BtpPacket incomingBtpPacket) {
+    Objects.requireNonNull(btpSession, "BtpSession is required!");
+    Objects.requireNonNull(incomingBtpPacket);
+
+    try {
+      // If incomingBtpMessage is a BTPResponse, we need to connect it to a pending sendData. If this is a
+      // BtpMessage, we can simply handle it...
+      return new BtpPacketMapper<Optional<BtpResponsePacket>>() {
+        @Override
+        protected Optional<BtpResponsePacket> mapBtpMessage(final BtpMessage incomingBtpMessage) {
+          Objects.requireNonNull(incomingBtpMessage);
+          logger.trace("incomingBtpMessage: {}", incomingBtpMessage);
+
+          // A WebSocketSession always has a BtpSession, but it may not be authenticated...
+          final BtpResponse btpResponse = handleIncomingBtpMessage(btpSession, incomingBtpMessage);
+          return Optional.of(btpResponse);
+        }
+
+        @Override
+        protected Optional<BtpResponsePacket> mapBtpTransfer(final BtpTransfer incomingBtpTransfer) {
+          Objects.requireNonNull(incomingBtpTransfer);
+          logger.trace("incomingBtpMessage: {}", incomingBtpTransfer);
+          throw new RuntimeException("Not yet implemented!");
+        }
+
+        @Override
+        protected Optional<BtpResponsePacket> mapBtpError(BtpError incomingBtpError) {
+          Objects.requireNonNull(incomingBtpError);
+          logger.error(
+              "Incoming BtpError from `{}` with message `{}`",
+              btpSession.getBtpSessionCredentials().get(), new String(incomingBtpError.getErrorData())
+          );
+
+          // The incoming message was a BtpError, so don't return a response to the peer.
+          return Optional.empty();
+        }
+
+        @Override
+        protected Optional<BtpResponsePacket> mapBtpResponse(final BtpResponse incomingBtpResponse) {
+          Objects.requireNonNull(incomingBtpResponse);
+
+          logger.trace("IncomingBtpResponse: {} ", incomingBtpResponse);
+
+          // Generally, BTP always returns a response to the caller, even under error conditions. There are two
+          // exceptions, however, listed as "tricky cases" in the BTP specification:
+          //
+          // 1. An unexpected BTP packet is received
+          // 2. An unreadable BTP packet is received
+          //
+          // If the packet was unreadable, then this method will have never been called, so we can ignore this
+          // case here. However, if an unexpected packet is encountered, we need to emit this error, but then return
+          // null to the caller of this method so that no response is returned to the BTP peer.
+
+          // TODO: If auth fails on the server, we might need to send a response from the join....otherwise, just
+          // return Optional.empty();
+          if (joinPendingResponse(incomingBtpResponse)) {
+            return Optional.empty();
+          } else {
+            return Optional.empty();
+          }
+        }
+      }.map(incomingBtpPacket);
+    } catch (BtpRuntimeException e) {
+      logger.error(e.getMessage(), e);
+      // If anything throws a BTP Exception, then return a BTP Error on the channel...
+      final BtpError btpError = e.toBtpError(incomingBtpPacket.getRequestId());
+      return Optional.of(btpError);
+    }
+  }
+
   /**
    * Handle an incoming BinaryMessage from a Websocket by converting it into a {@link BtpMessage} and forwarding it to
    * the appropriate receiver (i.e., plugin).
@@ -103,7 +228,7 @@
     final Optional<BinaryMessage> response;
     if (!btpSession.isAuthenticated()) {
       // Do Auth. This will merely initialize the credentials into the BTPSession and return an Ack.
-       response = this.handleBinaryAuthMessage(webSocketSession, incomingBinaryMessage)
+      response = this.handleBinaryAuthMessage(webSocketSession, incomingBinaryMessage)
           .map(foo -> btpPacketToBinaryMessageConverter.convert(foo));
 //
 //       This functionality needs to be different between client and server...
@@ -115,25 +240,28 @@
 
       //On the client, we need to rejoin the pending response...
 
-          // On the client, a pendingResponse will be waiting to complete the auth properly....we need to join the empty response to it.
-          //.map(btpResponse -> this.joinPendingResponse(btpResponse))
-          //.map($ -> Optional.<BinaryMessage>empty())
-          //.orElse(Optional.empty());
+      // On the client, a pendingResponse will be waiting to complete the auth properly....we need to join the empty response to it.
+      //.map(btpResponse -> this.joinPendingResponse(btpResponse))
+      //.map($ -> Optional.<BinaryMessage>empty())
+      //.orElse(Optional.empty());
     } else {
       // If the auth subprotocol completes successfully, then we'll end up here with an authenticated Websocket Session.
-      final BtpPacket incomingBtpPacket;
       try {
         // If there's a problem de-serializing the BtpPacket from the BinaryMessage, then close the connection and
         // return empty. This is one of the "tricky cases" as defined in the BTP spec where we don't want to get into
         // an infinite loop.
-        incomingBtpPacket = this.binaryMessageToBtpPacketConverter.convert(incomingBinaryMessage);
+        final BtpPacket incomingBtpPacket = this.binaryMessageToBtpPacketConverter.convert(incomingBinaryMessage);
+        final Optional<BtpResponsePacket> btpResponse = this.handleBtpPacket(btpSession, incomingBtpPacket);
+        if (btpResponse.isPresent()) {
+          response = Optional.of(btpPacketToBinaryMessageConverter.convert(btpResponse.get()));
+        } else {
+          response = Optional.empty();
+        }
       } catch (BtpConversionException btpConversionException) {
         logger.error("Unable to deserialize BtpPacket from incomingBinaryMessage: {}", btpConversionException);
         this.disconnect().join();
         return;
       }
-
-      response = this.handleBtpPacket(webSocketSession, incomingBtpPacket);
     }
 
     // Return the response to the caller, if there is a response.
@@ -200,92 +328,6 @@
     }
   }
 
-  /**
-   * Handle an incoming BTP Packet by detecting its actual type, and then forwarding it appropriately to the correct BTP
-   * handling facility.
-   *
-   * @param webSocketSession
-   * @param incomingBtpPacket
-   *
-   * @return
-   */
-  public Optional<BinaryMessage> handleBtpPacket(
-      final WebSocketSession webSocketSession, final BtpPacket incomingBtpPacket
-  ) {
-    Objects.requireNonNull(webSocketSession);
-    Objects.requireNonNull(incomingBtpPacket);
-
-    try {
-      // If incomingBtpMessage is a BTPResponse, we need to connect it to a pending sendData. If this is a
-      // BtpMessage, we can simply handle it...
-      return new BtpPacketMapper<Optional<BinaryMessage>>() {
-        @Override
-        protected Optional<BinaryMessage> mapBtpMessage(final BtpMessage incomingBtpMessage) {
-          Objects.requireNonNull(incomingBtpMessage);
-          logger.trace("incomingBtpMessage: {}", incomingBtpMessage);
-
-          // A WebSocketSession always has a BtpSession, but it may not be authenticated...
-          final BtpSession btpSession = BtpSessionUtils.getBtpSessionFromWebSocketSession(webSocketSession)
-              .orElseThrow(() -> new RuntimeException("BtpSession is required!"));
-          final BtpResponse btpResponse = handleIncomingBtpMessage(btpSession, incomingBtpMessage);
-          return Optional.of(btpPacketToBinaryMessageConverter.convert(btpResponse));
-        }
-
-        @Override
-        protected Optional<BinaryMessage> mapBtpTransfer(final BtpTransfer incomingBtpTransfer) {
-          Objects.requireNonNull(incomingBtpTransfer);
-          logger.trace("incomingBtpMessage: {}", incomingBtpTransfer);
-          throw new RuntimeException("Not yet implemented!");
-        }
-
-        @Override
-        protected Optional<BinaryMessage> mapBtpError(BtpError incomingBtpError) {
-          Objects.requireNonNull(incomingBtpError);
-
-          final BtpSession session = BtpSessionUtils.getBtpSessionFromWebSocketSession(webSocketSession)
-              .orElseThrow(() -> new RuntimeException("BtpSession is required!"));
-          logger.error(
-              "Incoming BtpError from `{}` with message `{}`",
-              session.getBtpSessionCredentials().get(), new String(incomingBtpError.getErrorData())
-          );
-
-          // The incoming message was a BtpError, so don't return a response to the peer.
-          return Optional.empty();
-        }
-
-        @Override
-        protected Optional<BinaryMessage> mapBtpResponse(final BtpResponse incomingBtpResponse) {
-          Objects.requireNonNull(incomingBtpResponse);
-
-          logger.trace("IncomingBtpResponse: {} ", incomingBtpResponse);
-
-          // Generally, BTP always returns a response to the caller, even under error conditions. There are two
-          // exceptions, however, listed as "tricky cases" in the BTP specification:
-          //
-          // 1. An unexpected BTP packet is received
-          // 2. An unreadable BTP packet is received
-          //
-          // If the packet was unreadable, then this method will have never been called, so we can ignore this
-          // case here. However, if an unexpected packet is encountered, we need to emit this error, but then return
-          // null to the caller of this method so that no response is returned to the BTP peer.
-
-          // TODO: If auth fails on the server, we might need to send a response from the join....otherwise, just
-          // return Optional.empty();
-          if (joinPendingResponse(incomingBtpResponse)) {
-            return Optional.empty();
-          } else {
-            return Optional.empty();
-          }
-        }
-      }.map(incomingBtpPacket);
-    } catch (BtpRuntimeException e) {
-      logger.error(e.getMessage(), e);
-      // If anything throws a BTP Exception, then return a BTP Error on the channel...
-      final BtpError btpError = e.toBtpError(incomingBtpPacket.getRequestId());
-      return Optional.ofNullable(btpPacketToBinaryMessageConverter.convert(btpError));
-    }
-  }
-
   /**
    * <p>Handles an incoming {@link BtpMessage} by delegating it to a registered handler.</p>
    *
@@ -396,13 +438,13 @@
         .build();
   }
 
-  protected CompletableFuture<Optional<BtpResponse>> sendMessageWithPendingRepsonse(
+  protected CompletableFuture<BtpResponsePacket> sendMessageWithPendingRepsonse(
       final long requestId, final WebSocketSession webSocketSession, final WebSocketMessage webSocketMessage
   ) {
     Objects.requireNonNull(webSocketMessage);
     try {
       // Register the pending response first, just in-cae the Websocket returns faster than this method can complete.
-      final CompletableFuture<Optional<BtpResponse>> pendingResponse = registerPendingResponse(requestId);
+      final CompletableFuture<BtpResponsePacket> pendingResponse = registerPendingResponse(requestId);
       webSocketSession.sendMessage(webSocketMessage);
       return pendingResponse;
     } catch (IOException e) {
@@ -449,14 +491,14 @@
    *
    * @return
    */
-  protected final CompletableFuture<Optional<BtpResponse>> registerPendingResponse(final long requestId) {
+  protected final CompletableFuture<BtpResponsePacket> registerPendingResponse(final long requestId) {
 
     // TODO: Use WeakReferences here to prevent memory leaks...
 
     // This response will expire in the alotted time (see below). This response is immediately returned to the caller,
     // but nothing happens until this CF expires, or the CF is completed from a different thread (by passing-in an
     // incoming message, which is actually a response).
-    final CompletableFuture<Optional<BtpResponse>> pendingResponse = CompletableFuture.supplyAsync(
+    final CompletableFuture<BtpResponsePacket> pendingResponse = CompletableFuture.supplyAsync(
         () -> {
           // TODO: Configure this amount as a property.
           // TODO: Move back to seconds and set a default of 15.
@@ -490,7 +532,7 @@
     Objects.requireNonNull(incomingBtpResponse,
         "incomingBtpResponse must not be null in order to correlate to a pending response identifier!");
 
-    final CompletableFuture<Optional<BtpResponse>> pendingResponse = pendingResponses
+    final CompletableFuture<BtpResponsePacket> pendingResponse = pendingResponses
         .get(incomingBtpResponse.getRequestId());
 
     // If there's no pending response, then return empty, and log an error.
@@ -533,7 +575,7 @@
               } else {
                 // Pipe the incomingBtpResponse into the pending response so that whatever caller is waiting for it will
                 // receive it.
-                return pendingResponse.complete(Optional.of(incomingBtpResponse));
+                return pendingResponse.complete(incomingBtpResponse);
               }
             })
             // Join is preferable here as opposed to get(timeout) because the anyOf (above) combines a timeout future,
Index: ilp-plugin-connections/src/main/java/org/interledger/plugin/connections/mux/AbstractMux.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ilp-plugin-connections/src/main/java/org/interledger/plugin/connections/mux/AbstractMux.java	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
+++ ilp-plugin-connections/src/main/java/org/interledger/plugin/connections/mux/AbstractMux.java	(date 1546453903000)
@@ -1,7 +1,6 @@
 package org.interledger.plugin.connections.mux;
 
 import org.interledger.plugin.Connectable;
-import org.interledger.plugin.lpiv2.events.PluginConnectedEvent;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -11,7 +10,10 @@
 
 /**
  * An abstract MUX implementation that provides basic connection tracking.
+ *
+ * @deprecated Will be replaced by a BilateralConnection.
  */
+@Deprecated
 public abstract class AbstractMux implements Connectable {
 
   private final AtomicBoolean connected = new AtomicBoolean(NOT_CONNECTED);
@@ -37,18 +39,18 @@
 //                this.pluginEventEmitter.emitEvent(PluginConnectedEvent.of(this));
 //
 //                logger.debug("[{}] `{}` connected to `{}`", this.getPluginSettings().getPluginType(),
-//                    this.pluginSettings.getLocalNodeAddress(), this.getPluginSettings().getPeerAccountAddress());
+//                    this.pluginSettings.getLocalNodeAddress(), this.getPluginSettings().getAccountAddress());
 //              } else {
 //                final String errorMessage = String.format("[%s] `%s` error while trying to connect to `%s`",
 //                    this.pluginSettings.getPluginType(),
-//                    this.pluginSettings.getLocalNodeAddress(), this.getPluginSettings().getPeerAccountAddress()
+//                    this.pluginSettings.getLocalNodeAddress(), this.getPluginSettings().getAccountAddress()
 //                );
 //                logger.error(errorMessage, error);
 //              }
 //            });
 //      } else {
 //        logger.debug("[{}] `{}` already connected to `{}`...", this.pluginSettings.getPluginType(),
-//            this.pluginSettings.getLocalNodeAddress(), this.getPluginSettings().getPeerAccountAddress());
+//            this.pluginSettings.getLocalNodeAddress(), this.getPluginSettings().getAccountAddress());
 //        // No-op: We're already expectedCurrentState...
 //        return CompletableFuture.completedFuture(null);
 //      }
Index: ilp-plugin-btp-grpc/src/main/proto/ilpv4_gates.proto
===================================================================
--- ilp-plugin-btp-grpc/src/main/proto/ilpv4_gates.proto	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
+++ ilp-plugin-bpp-grpc/src/main/proto/attic/ilpv4_gates.proto	(date 1543103089000)
@@ -1,0 +1,0 @@
Index: ilp-plugin-core/src/main/java/org/interledger/plugin/lpiv2/Plugin_Old.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ilp-plugin-core/src/main/java/org/interledger/plugin/lpiv2/Plugin_Old.java	(date 1546463791000)
+++ ilp-plugin-core/src/main/java/org/interledger/plugin/lpiv2/Plugin_Old.java	(date 1546463791000)
@@ -0,0 +1,121 @@
+package org.interledger.plugin.lpiv2;
+
+import org.interledger.core.InterledgerPreparePacket;
+import org.interledger.plugin.BilateralReceiver;
+import org.interledger.plugin.BilateralSender;
+import org.interledger.plugin.lpiv2.events.PluginEventListener;
+import org.interledger.plugin.lpiv2.exceptions.DataHandlerAlreadyRegisteredException;
+import org.interledger.plugin.lpiv2.exceptions.MoneyHandlerAlreadyRegisteredException;
+import org.interledger.plugin.lpiv2.exceptions.MoneySenderAlreadyRegisteredException;
+
+import java.math.BigInteger;
+import java.util.UUID;
+import java.util.concurrent.CompletableFuture;
+
+/**
+ * <p>An abstraction for communicating with a remote Interledger peer using a single account.</p>
+ *
+ * <p>The overall flow of funds in ILPv4 is as follows:
+ *
+ * <pre>
+ * Sender --sendData-> Connector 1 --sendData-> Connector 2 --sendData-> Receiver
+ *    |                        |                        |
+ *    `----sendMoney->         `----sendMoney->         `----sendMoney->
+ * </pre>
+ *
+ * Sender/Connector's call <tt>sendData</tt>, wait for a fulfillment, and then call <tt>sendMoney</tt> (possibly
+ * infrequently or even only eventually for bulk settlement) if the fulfillment is valid.</p>
+ */
+public interface Plugin_Old<T extends PluginSettings> extends BilateralSender, BilateralReceiver {
+
+  /**
+   * The settings for this Plugin.
+   */
+  T getPluginSettings();
+
+  /**
+   * Add a  plugin event handler to this plugin.
+   *
+   * Care should be taken when adding multiple handlers to ensure that they perform distinct operations, otherwise
+   * duplicate functionality might be unintentionally introduced.
+   *
+   * @param eventHandler A {@link PluginEventListener} that can handle various types of events emitted by this ledger
+   *                     plugin.
+   *
+   * @return A {@link UUID} representing the unique identifier of the handler, as seen by this ledger plugin.
+   */
+  void addPluginEventListener(UUID eventHandlerId, PluginEventListener eventHandler);
+
+  /**
+   * Removes an event handler from the collection of handlers registered with this ledger plugin.
+   *
+   * @param eventHandlerId A {@link UUID} representing the unique identifier of the handler, as seen by this ledger
+   *                       plugin.
+   */
+  void removePluginEventListener(UUID eventHandlerId);
+
+  void registerDataSender(DataSender dataSender) throws MoneySenderAlreadyRegisteredException;
+
+  /**
+   * Removes the currently used {@oink DataSender}. This has the same effect as if {@link
+   * #registerDataSender(DataSender)} had never been called. If no bilateral sender is currently set, this method does
+   * nothing.
+   */
+  void unregisterDataSender();
+
+  void registerMoneySender(MoneySender moneySender) throws MoneySenderAlreadyRegisteredException;
+
+  /**
+   * Removes the currently used {@oink DataSender}. This has the same effect as if {@link
+   * #registerDataSender(DataSender)} had never been called. If no bilateral sender is currently set, this method does
+   * nothing.
+   */
+  void unregisterMoneySender();
+
+  /**
+   * <p>Set the callback which is used to handle incoming prepared data packets. The handler should expect one
+   * parameter (an ILP Prepare Packet) and return a CompletableFuture for the resulting response. If an error occurs,
+   * the callback MAY throw an exception. In general, the callback should behave as {@link
+   * DataSender#sendData(InterledgerPreparePacket)} does.</p>
+   *
+   * <p>If a data handler is already set, this method throws a {@link DataHandlerAlreadyRegisteredException}. In order
+   * to change the data handler, the old handler must first be removed via {@link #unregisterDataHandler()}. This is to
+   * ensure that handlers are not overwritten by accident.</p>
+   *
+   * <p>If an incoming packet is received by the plugin, but no handler is registered, the plugin SHOULD respond with
+   * an error.</p>
+   *
+   * @param dataHandler An instance of {@link DataHandler}.
+   */
+  void registerDataHandler(DataHandler dataHandler) throws DataHandlerAlreadyRegisteredException;
+
+  /**
+   * Removes the currently used {@link DataHandler}. This has the same effect as if {@link
+   * #registerDataHandler(DataHandler)} had never been called. If no data handler is currently set, this method does
+   * nothing.
+   */
+  void unregisterDataHandler();
+
+  /**
+   * <p>Set the callback which is used to handle incoming money. The callback should expect one parameter (the amount)
+   * and return a {@link CompletableFuture}. If an error occurs, the callback MAY throw an exception. In general, the
+   * callback should behave as {@link MoneySender#sendMoney(BigInteger)} does.</p>
+   *
+   * <p>If a money handler is already set, this method throws a {@link MoneyHandlerAlreadyRegisteredException}. In
+   * order to change the money handler, the old handler must first be removed via {@link #unregisterMoneyHandler()}.
+   * This is to ensure that handlers are not overwritten by accident.</p>
+   *
+   * <p>If incoming money is received by the plugin, but no handler is registered, the plugin SHOULD return an error
+   * (and MAY return the money.)</p>
+   *
+   * @param moneyHandler An instance of {@link MoneyHandler}.
+   */
+  void registerMoneyHandler(MoneyHandler moneyHandler) throws MoneyHandlerAlreadyRegisteredException;
+
+  /**
+   * Removes the currently used money handler. This has the same effect as if {@link
+   * #registerMoneyHandler(MoneyHandler)} had never been called. If no money handler is currently set, this method does
+   * nothing.
+   */
+  void unregisterMoneyHandler();
+}
Index: ilp-plugin-bpp-grpc/src/main/java/org/interledger/plugin/lpiv2/bpp/grpc/connection/mux/GrpcBppClientMuxSettings.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ilp-plugin-bpp-grpc/src/main/java/org/interledger/plugin/lpiv2/bpp/grpc/connection/mux/GrpcBppClientMuxSettings.java	(date 1545323225000)
+++ ilp-plugin-bpp-grpc/src/main/java/org/interledger/plugin/lpiv2/bpp/grpc/connection/mux/GrpcBppClientMuxSettings.java	(date 1545323225000)
@@ -0,0 +1,58 @@
+package org.interledger.plugin.lpiv2.bpp.grpc.connection.mux;
+
+import org.interledger.plugin.connections.mux.MuxSettings;
+
+import org.immutables.value.Value.Default;
+import org.immutables.value.Value.Immutable;
+
+public interface GrpcBppClientMuxSettings extends MuxSettings {
+
+  static ImmutableGrpcBppClientMuxSettings.Builder builder() {
+    return ImmutableGrpcBppClientMuxSettings.builder();
+  }
+
+  /**
+   * The HTTP host to connect to in order to speak gRPC.
+   *
+   * @return
+   */
+  String host();
+
+  /**
+   * The HTTP port to connect to in order to speak gRPC.
+   *
+   * @return
+   */
+  int port();
+
+  /**
+   * The time to wait for a gRPC call to execute before timing out.
+   *
+   * @return
+   */
+  //@Option(name="--deadline_ms", usage="Deadline in milliseconds.")
+  long grpcDeadlineMillis();
+
+  /**
+   * <p>The credential identifier used to connect authenticate to a remote gRPC server.</p>
+   *
+   * @return
+   */
+  //String getUsername();
+
+  /**
+   * <p>The credential used to connect authenticate to a remote gRPC server.</p>
+   */
+  //String getPassword();
+
+  @Immutable
+  abstract class AbstractGrpcBppClientMuxSettings implements GrpcBppClientMuxSettings {
+
+    @Default
+    @Override
+    public long grpcDeadlineMillis() {
+      return 20 * 1000;
+    }
+
+  }
+}
Index: ilp-plugin-btp-springws/src/main/java/org/interledger/plugin/lpiv2/btp2/spring/connection2/BtpPluginConnectionManager.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ilp-plugin-btp-springws/src/main/java/org/interledger/plugin/lpiv2/btp2/spring/connection2/BtpPluginConnectionManager.java	(date 1546465238000)
+++ ilp-plugin-btp-springws/src/main/java/org/interledger/plugin/lpiv2/btp2/spring/connection2/BtpPluginConnectionManager.java	(date 1546465238000)
@@ -0,0 +1,706 @@
+package org.interledger.plugin.lpiv2.btp2.spring.connection2;
+
+import static java.util.concurrent.CompletableFuture.anyOf;
+import static org.interledger.plugin.lpiv2.btp2.subprotocols.BtpSubProtocolHandlerRegistry.BTP_SUB_PROTOCOL_AUTH;
+import static org.interledger.plugin.lpiv2.btp2.subprotocols.BtpSubProtocolHandlerRegistry.BTP_SUB_PROTOCOL_AUTH_TOKEN;
+import static org.interledger.plugin.lpiv2.btp2.subprotocols.BtpSubProtocolHandlerRegistry.BTP_SUB_PROTOCOL_AUTH_USERNAME;
+
+import org.interledger.btp.BtpError;
+import org.interledger.btp.BtpErrorCode;
+import org.interledger.btp.BtpMessage;
+import org.interledger.btp.BtpPacket;
+import org.interledger.btp.BtpPacketMapper;
+import org.interledger.btp.BtpResponse;
+import org.interledger.btp.BtpResponsePacket;
+import org.interledger.btp.BtpRuntimeException;
+import org.interledger.btp.BtpSession;
+import org.interledger.btp.BtpSessionCredentials;
+import org.interledger.btp.BtpSubProtocol;
+import org.interledger.btp.BtpSubProtocol.ContentType;
+import org.interledger.btp.BtpSubProtocols;
+import org.interledger.btp.BtpTransfer;
+import org.interledger.plugin.connections.AbstractPluginConnectionManager;
+import org.interledger.plugin.lpiv2.btp2.spring.BtpSessionUtils;
+import org.interledger.plugin.lpiv2.btp2.spring.converters.BinaryMessageToBtpPacketConverter;
+import org.interledger.plugin.lpiv2.btp2.spring.converters.BtpConversionException;
+import org.interledger.plugin.lpiv2.btp2.spring.converters.BtpPacketToBinaryMessageConverter;
+import org.interledger.plugin.lpiv2.btp2.subprotocols.AbstractBtpSubProtocolHandler;
+import org.interledger.plugin.lpiv2.btp2.subprotocols.BtpSubProtocolHandlerRegistry;
+
+import com.google.common.collect.Maps;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.springframework.web.socket.BinaryMessage;
+import org.springframework.web.socket.CloseStatus;
+import org.springframework.web.socket.WebSocketHandler;
+import org.springframework.web.socket.WebSocketMessage;
+import org.springframework.web.socket.WebSocketSession;
+
+import java.io.IOException;
+import java.nio.charset.Charset;
+import java.nio.charset.StandardCharsets;
+import java.security.SecureRandom;
+import java.time.Instant;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Optional;
+import java.util.Random;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.CompletionException;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.locks.LockSupport;
+
+// NOTE: Should only be used in a Connector or other node running a WebSocket server. Otherwise, use the ClientBtpPlugin.
+public class BtpPluginConnectionManager extends AbstractPluginConnectionManager implements WebSocketHandler {
+
+  protected final BinaryMessageToBtpPacketConverter binaryMessageToBtpPacketConverter;
+  protected final BtpPacketToBinaryMessageConverter btpPacketToBinaryMessageConverter;
+
+  // TODO: Use WeakHashMap?
+  // When the client sends a request out to a peer, it will wait for an async response from that peer. When that
+  // response comes back, it will be combined with a pending response.
+  protected final Map<Long, CompletableFuture<BtpResponsePacket>> pendingResponses;
+  protected final Logger logger = LoggerFactory.getLogger(this.getClass());
+
+  private final BtpSubProtocolHandlerRegistry btpSubProtocolHandlerRegistry;
+  private final Random random;
+
+  /**
+   * Required-args Constructor.
+   */
+  public BtpPluginConnectionManager(
+      //final CS connectionSettings,
+      //final PluginFactory pluginFactory,
+      final BinaryMessageToBtpPacketConverter binaryMessageToBtpPacketConverter,
+      final BtpPacketToBinaryMessageConverter btpPacketToBinaryMessageConverter,
+      final BtpSubProtocolHandlerRegistry btpSubProtocolHandlerRegistry
+  ) {
+    this.binaryMessageToBtpPacketConverter = Objects.requireNonNull(binaryMessageToBtpPacketConverter);
+    this.btpPacketToBinaryMessageConverter = Objects.requireNonNull(btpPacketToBinaryMessageConverter);
+    this.btpSubProtocolHandlerRegistry = Objects.requireNonNull(btpSubProtocolHandlerRegistry);
+
+    this.pendingResponses = Maps.newConcurrentMap();
+    this.random = new SecureRandom();
+  }
+
+  //////////////////////
+  // BtpSender Methods
+  //////////////////////
+
+  /**
+   * Converts {@code btpMessage} into the proper binary format and then sends the payload out over the websocket,
+   * waiting for a response.
+   */
+  @Override
+  public CompletableFuture<BtpResponsePacket> sendBtpMessage(final BtpMessage btpMessage) {
+    Objects.requireNonNull(btpMessage);
+
+    // Translate the btpMessage to a BinaryMessage, and send out using the WebSocketSession.
+    return this.webSocketSession
+        .map(wss -> {
+          final BinaryMessage binaryMessage = this.btpPacketToBinaryMessageConverter.convert(btpMessage);
+          final long requestId = nextRequestId();
+          return this.sendMessageWithPendingRepsonse(requestId, wss, binaryMessage)
+              .handle((response, error) -> {
+                if (error != null) {
+                  // the pending response timed out or otherwise had a problem...
+                  throw new RuntimeException(error.getMessage(), error);
+                } else {
+                  // Might be an error or a response`
+                  return response;
+                }
+              });
+        }).orElseThrow(() -> new RuntimeException("No WebSocket session!"));
+  }
+
+  @Override
+  public CompletableFuture<BtpResponsePacket> sendBtpTransfer(BtpTransfer btpTransfer) {
+    throw new RuntimeException("FIXME!");
+    //return CompletableFuture.completedFuture(null);
+  }
+
+  //////////////////////
+  // BtpReceiver Methods
+  //////////////////////
+
+  /**
+   * Handle an incoming BTP Packet. The payload may be a BTP Request type, or it may be a BTP response type, so
+   * implementations must handle all BTP packet types approporiately.
+   *
+   * @param incomingBtpPacket A {@link BtpPacket} sent from the bilateral BTP peer.
+   *
+   * @return An optionally-present response of type {@link BtpResponsePacket}.
+   */
+  @Override
+  public Optional<BtpResponsePacket> handleBtpPacket(final BtpSession btpSession, final BtpPacket incomingBtpPacket) {
+    Objects.requireNonNull(btpSession, "BtpSession is required!");
+    Objects.requireNonNull(incomingBtpPacket);
+
+    try {
+      // If incomingBtpMessage is a BTPResponse, we need to connect it to a pending sendData. If this is a
+      // BtpMessage, we can simply handle it...
+      return new BtpPacketMapper<Optional<BtpResponsePacket>>() {
+        @Override
+        protected Optional<BtpResponsePacket> mapBtpMessage(final BtpMessage incomingBtpMessage) {
+          Objects.requireNonNull(incomingBtpMessage);
+          logger.trace("incomingBtpMessage: {}", incomingBtpMessage);
+
+          // A WebSocketSession always has a BtpSession, but it may not be authenticated...
+          final BtpResponse btpResponse = handleIncomingBtpMessage(btpSession, incomingBtpMessage);
+          return Optional.of(btpResponse);
+        }
+
+        @Override
+        protected Optional<BtpResponsePacket> mapBtpTransfer(final BtpTransfer incomingBtpTransfer) {
+          Objects.requireNonNull(incomingBtpTransfer);
+          logger.trace("incomingBtpMessage: {}", incomingBtpTransfer);
+          throw new RuntimeException("Not yet implemented!");
+        }
+
+        @Override
+        protected Optional<BtpResponsePacket> mapBtpError(BtpError incomingBtpError) {
+          Objects.requireNonNull(incomingBtpError);
+          logger.error(
+              "Incoming BtpError from `{}` with message `{}`",
+              btpSession.getBtpSessionCredentials().get(), new String(incomingBtpError.getErrorData())
+          );
+
+          // The incoming message was a BtpError, so don't return a response to the peer.
+          return Optional.empty();
+        }
+
+        @Override
+        protected Optional<BtpResponsePacket> mapBtpResponse(final BtpResponse incomingBtpResponse) {
+          Objects.requireNonNull(incomingBtpResponse);
+
+          logger.trace("IncomingBtpResponse: {} ", incomingBtpResponse);
+
+          // Generally, BTP always returns a response to the caller, even under error conditions. There are two
+          // exceptions, however, listed as "tricky cases" in the BTP specification:
+          //
+          // 1. An unexpected BTP packet is received
+          // 2. An unreadable BTP packet is received
+          //
+          // If the packet was unreadable, then this method will have never been called, so we can ignore this
+          // case here. However, if an unexpected packet is encountered, we need to emit this error, but then return
+          // null to the caller of this method so that no response is returned to the BTP peer.
+
+          // TODO: If auth fails on the server, we might need to send a response from the join....otherwise, just
+          // return Optional.empty();
+          if (joinPendingResponse(incomingBtpResponse)) {
+            return Optional.empty();
+          } else {
+            return Optional.empty();
+          }
+        }
+      }.map(incomingBtpPacket);
+    } catch (BtpRuntimeException e) {
+      logger.error(e.getMessage(), e);
+      // If anything throws a BTP Exception, then return a BTP Error on the channel...
+      final BtpError btpError = e.toBtpError(incomingBtpPacket.getRequestId());
+      return Optional.of(btpError);
+    }
+  }
+
+  /**
+   * Handle an incoming BinaryMessage from a Websocket by converting it into a {@link BtpMessage} and forwarding it to
+   * the appropriate receiver (i.e., plugin).
+   *
+   * @param webSocketSession
+   * @param incomingBinaryMessage
+   *
+   * @return A {@link BinaryMessage} that can immediately be returned to the caller (this response will contain
+   *     everything required to be eligible as a BTP response), or nothing if the response is {@link Optional#empty()}.
+   */
+  public void handleBinaryMessage(
+      final WebSocketSession webSocketSession, final BinaryMessage incomingBinaryMessage
+  ) {
+    Objects.requireNonNull(webSocketSession);
+    Objects.requireNonNull(incomingBinaryMessage);
+
+    // The first message in a WebSocketSession MUST be the auth protocol. Thus, as long as the BtpSession is not
+    // authenticated, then we should attempt to perform the auth sub_protocol.
+    final BtpSession btpSession = BtpSessionUtils.getBtpSessionFromWebSocketSession(webSocketSession)
+        .orElseThrow(() -> new RuntimeException("BtpSession is required!"));
+
+    final Optional<BinaryMessage> response;
+    if (!btpSession.isAuthenticated()) {
+      // Do Auth. This will merely initialize the credentials into the BTPSession and return an Ack.
+      response = this.handleBinaryAuthMessage(webSocketSession, incomingBinaryMessage)
+          .map(foo -> btpPacketToBinaryMessageConverter.convert(foo));
+//
+//       This functionality needs to be different between client and server...
+//      client should never echo responses back to the server, so response MUSt always be empty.
+      // A client response will
+//      if(btpResponse.get().getSubProtocols().size() == 0){
+//
+//      }
+
+      //On the client, we need to rejoin the pending response...
+
+      // On the client, a pendingResponse will be waiting to complete the auth properly....we need to join the empty response to it.
+      //.map(btpResponse -> this.joinPendingResponse(btpResponse))
+      //.map($ -> Optional.<BinaryMessage>empty())
+      //.orElse(Optional.empty());
+    } else {
+      // If the auth subprotocol completes successfully, then we'll end up here with an authenticated Websocket Session.
+      try {
+        // If there's a problem de-serializing the BtpPacket from the BinaryMessage, then close the connection and
+        // return empty. This is one of the "tricky cases" as defined in the BTP spec where we don't want to get into
+        // an infinite loop.
+        final BtpPacket incomingBtpPacket = this.binaryMessageToBtpPacketConverter.convert(incomingBinaryMessage);
+        final Optional<BtpResponsePacket> btpResponse = this.handleBtpPacket(btpSession, incomingBtpPacket);
+        if (btpResponse.isPresent()) {
+          response = Optional.of(btpPacketToBinaryMessageConverter.convert(btpResponse.get()));
+        } else {
+          response = Optional.empty();
+        }
+      } catch (BtpConversionException btpConversionException) {
+        logger.error("Unable to deserialize BtpPacket from incomingBinaryMessage: {}", btpConversionException);
+        this.disconnect().join();
+        return;
+      }
+    }
+
+    // Return the response to the caller, if there is a response.
+    response.ifPresent($ -> {
+      try {
+        // TODO: What does the other side of the WebSocket see if there's an exception here?
+        webSocketSession.sendMessage($);
+      } catch (IOException e) {
+        throw new RuntimeException(e);
+      }
+    });
+
+  }
+
+  /**
+   * Handle an incoming BinaryMessage from a Websocket, assuming it's a BTP Auth message.
+   *
+   * @param webSocketSession
+   * @param incomingBinaryMessage
+   *
+   * @return A {@link BinaryMessage} that can immediately be returned to the caller (this response will contain
+   *     everything required to be eligible as a BTP response), or nothing if the response is {@link Optional#empty()}.
+   */
+  public Optional<BtpResponse> handleBinaryAuthMessage(
+      final WebSocketSession webSocketSession, final BinaryMessage incomingBinaryMessage
+  ) {
+    Objects.requireNonNull(webSocketSession);
+    Objects.requireNonNull(incomingBinaryMessage);
+
+    final AbstractBtpSubProtocolHandler btpAuthSubprotocolHandler = this.btpSubProtocolHandlerRegistry
+        .getHandler(BTP_SUB_PROTOCOL_AUTH, ContentType.MIME_APPLICATION_OCTET_STREAM)
+        .orElseThrow(() -> new RuntimeException("No Auth Subprotocol Handler registered!"));
+
+    // If there's a problem de-serializing the BtpPacket from the BinaryMessage, then close the connection and
+    // return empty. This is one of the "tricky cases" as defined in the BTP spec where we don't want to get into
+    // an infinite loop.
+    final BtpPacket incomingBtpPacket;
+    try {
+      incomingBtpPacket = this.binaryMessageToBtpPacketConverter.convert(incomingBinaryMessage);
+      final BtpSession btpSession = BtpSessionUtils.getBtpSessionFromWebSocketSession(webSocketSession)
+          .orElseThrow(() -> new RuntimeException("BtpSession is required!"));
+      return btpAuthSubprotocolHandler.handleSubprotocolMessage(btpSession, incomingBtpPacket)
+          .thenApply(btpSubProtocol -> btpSubProtocol
+              .map($ -> {
+                // If there's no exception, then reaching here means the btp_auth SubProtocol succeeded.
+                // Ack the response, but only if
+                final BtpSubProtocols responses = new BtpSubProtocols();
+                responses.add($);
+                final BtpResponse response = BtpResponse.builder()
+                    .requestId(incomingBtpPacket.getRequestId())
+                    .subProtocols(responses)
+                    .build();
+                return response;
+              })
+              //.map(btpPacketToBinaryMessageConverter::convert)
+              .map(Optional::of)
+              // If there is no sub-protocol to return, then return empty so no response is sent back over the connection.
+              .orElse(Optional.empty())
+          )
+          .join();
+    } catch (BtpConversionException btpConversionException) {
+      logger.error(btpConversionException.getMessage(), btpConversionException);
+      throw btpConversionException;
+    }
+  }
+
+  /**
+   * <p>Handles an incoming {@link BtpMessage} by delegating it to a registered handler.</p>
+   *
+   * <p>There are also a couple of tricky cases to handle:</p>
+   *
+   * <ul>
+   * <li>If an unexpected BTP packet is received, no response should be sent. An unexpected BTP packet is a
+   * response for which a request was not sent, or a response for a request which has already been responded to.</li>
+   * <li>If an unreadable BTP packet is received, no response should be sent. An unreadable BTP packet is one which
+   * is structurally invalid, i.e. terminates before length prefixes dictate or contains illegal characters.</li>
+   * </ul>
+   *
+   * <p>Incoming BTP messages can be either requests or responses, so sub-classes should be careful to handle both
+   * types of message, especially when bridging to synchronous API contracts, where it may become confusing as to
+   * whether an incoming message corresponds to the input our output portion of a particular synchronous method.</p>
+   *
+   * @param btpSession
+   * @param incomingBtpMessage
+   *
+   * @return
+   */
+  // TODO: Use future?
+  public BtpResponse handleIncomingBtpMessage(final BtpSession btpSession, final BtpMessage incomingBtpMessage)
+      throws BtpRuntimeException {
+
+    Objects.requireNonNull(btpSession);
+    Objects.requireNonNull(incomingBtpMessage);
+
+    try {
+      final BtpSubProtocols responses = new BtpSubProtocols();
+
+      // Only the primary sub-protocol should be handled. The secondary sub-protocols should not request additional
+      // actions or information. If multiple actions or pieces of information are required, multiple separate Messages
+      // should be sent. The secondary sub-protocols should only modify the request made in the primary sub-protocol, or
+      // provide additional contextual data which can be consumed in a readonly way (without affecting the result).
+      final BtpSubProtocol primarySubprotocol = incomingBtpMessage.getPrimarySubProtocol();
+      final AbstractBtpSubProtocolHandler handler =
+          this.btpSubProtocolHandlerRegistry
+              .getHandler(primarySubprotocol.getProtocolName(), primarySubprotocol.getContentType())
+              .orElseThrow(() -> new BtpRuntimeException(
+                  BtpErrorCode.F00_NotAcceptedError,
+                  String.format("No BTP Handler registered for BTP SubProtocol: %s",
+                      primarySubprotocol.getProtocolName()))
+              );
+
+      final CompletableFuture<Optional<BtpSubProtocol>> btpSubProtocolResponse = handler
+          .handleSubprotocolMessage(btpSession, incomingBtpMessage);
+
+      // Add the response, but only if it's present.
+      btpSubProtocolResponse.get().ifPresent(responses::add);
+
+      // Now that there's a proper response, send it back to the connected client...
+      return BtpResponse.builder()
+          .requestId(incomingBtpMessage.getRequestId())
+          .subProtocols(responses)
+          .build();
+    } catch (Exception e) {
+      throw new BtpRuntimeException(BtpErrorCode.T00_UnreachableError, e.getMessage(), e);
+    }
+  }
+
+  /**
+   * Returns the next random request id using a PRNG.
+   */
+  protected long nextRequestId() {
+    return Math.abs(random.nextInt());
+  }
+
+  /**
+   * An authentication message must have as its primary <tt>protocolData</tt> entry must have the name of 'auth',
+   * content type <tt>MIME_APPLICATION_OCTET_STREAM</tt>, and empty data, and among the secondary entries, there MUST be
+   * a UTF-8 'auth_token' entry.
+   *
+   * @return
+   */
+  public BtpMessage constructAuthMessage(
+      final long requestId, final BtpSessionCredentials btpSessionCredentials
+  ) {
+    Objects.requireNonNull(btpSessionCredentials);
+
+    final BtpSubProtocol authSubProtocol = BtpSubProtocol.builder()
+        .protocolName(BTP_SUB_PROTOCOL_AUTH)
+        .contentType(BtpSubProtocol.ContentType.MIME_APPLICATION_OCTET_STREAM)
+        .build();
+    final BtpSubProtocols btpSubProtocols = BtpSubProtocols.fromPrimarySubProtocol(authSubProtocol);
+
+    // In situations where no authentication is needed, the 'auth_token' data can be set to the empty string,
+    // but it cannot be omitted.
+    final BtpSubProtocol authTokenSubprotocol = BtpSubProtocol.builder()
+        .protocolName(BTP_SUB_PROTOCOL_AUTH_TOKEN)
+        .contentType(BtpSubProtocol.ContentType.MIME_APPLICATION_OCTET_STREAM)
+        .data(btpSessionCredentials.getAuthToken().getBytes(StandardCharsets.UTF_8))
+        .build();
+    btpSubProtocols.add(authTokenSubprotocol);
+
+    btpSessionCredentials.getAuthUsername().ifPresent($ -> {
+      final BtpSubProtocol authUsernameSubprotocol = BtpSubProtocol.builder()
+          .protocolName(BTP_SUB_PROTOCOL_AUTH_USERNAME)
+          .contentType(BtpSubProtocol.ContentType.MIME_APPLICATION_OCTET_STREAM)
+          .data($.getBytes(StandardCharsets.UTF_8))
+          .build();
+      btpSubProtocols.add(authUsernameSubprotocol);
+    });
+
+    return BtpMessage.builder()
+        .requestId(requestId)
+        .subProtocols(btpSubProtocols)
+        .build();
+  }
+
+  protected CompletableFuture<BtpResponsePacket> sendMessageWithPendingRepsonse(
+      final long requestId, final WebSocketSession webSocketSession, final WebSocketMessage webSocketMessage
+  ) {
+    Objects.requireNonNull(webSocketMessage);
+    try {
+      // Register the pending response first, just in-cae the Websocket returns faster than this method can complete.
+      final CompletableFuture<BtpResponsePacket> pendingResponse = registerPendingResponse(requestId);
+      webSocketSession.sendMessage(webSocketMessage);
+      return pendingResponse;
+    } catch (IOException e) {
+      try {
+        this.disconnect().get();
+      } catch (Exception e1) {
+        throw new RuntimeException(e1);
+      }
+      throw new RuntimeException(e);
+    }
+  }
+
+  /**
+   * <p>Register and return a "pending response", mapping it to the supplied {@code requestId}. This mechanism works by
+   * returning a completed future to a caller, who then waits for the future to be completed. The receiver processes the
+   * request, and eventually returns a response by completing the appropriate <tt>pending respsonse</tt>.</p>
+   *
+   * <p>The following diagram illustrates this flow:</p>
+   *
+   * <pre>
+   * ┌──────────┐                                              ┌──────────┐
+   * │          │────────────Request (Object)─────────────────▷│          │
+   * │          │                                              │          │
+   * │          │             Response (Uncompleted            │          │
+   * │          │◁─────────────CompletableFuture)───△──────────┤          │
+   * │          │                                   │          │          │
+   * │          │                                   │          │          │
+   * │          │                                   │          │          │
+   * │          │                                   │          │          │
+   * │  Sender  │                                   │ Complete │ Receiver │
+   * │          │                                   └or Timeout┤          │
+   * │          │                                              │          │
+   * │          │                                              │          │
+   * │          │                                              │          │
+   * │          │                                              │          │
+   * │          │                                              │          │
+   * │          │                                              │          │
+   * │          │                                              │          │
+   * └──────────┘                                              └──────────┘
+   * </pre>
+   *
+   * @param requestId The unique identifier of the request that should receive a response, but only once that response
+   *                  can be returned.
+   *
+   * @return
+   */
+  protected final CompletableFuture<BtpResponsePacket> registerPendingResponse(final long requestId) {
+
+    // TODO: Use WeakReferences here to prevent memory leaks...
+
+    // This response will expire in the alotted time (see below). This response is immediately returned to the caller,
+    // but nothing happens until this CF expires, or the CF is completed from a different thread (by passing-in an
+    // incoming message, which is actually a response).
+    final CompletableFuture<BtpResponsePacket> pendingResponse = CompletableFuture.supplyAsync(
+        () -> {
+          // TODO: Configure this amount as a property.
+          // TODO: Move back to seconds and set a default of 15.
+          LockSupport.parkNanos(TimeUnit.MINUTES.toNanos(15));
+          throw new BtpRuntimeException(BtpErrorCode.F00_NotAcceptedError, "BTP SendData operation timed-out!");
+        }
+    );
+
+    if (this.pendingResponses.putIfAbsent(requestId, pendingResponse) == null) {
+      return pendingResponse;
+    } else {
+      // TODO: Just log an error and ignore?
+      throw new RuntimeException("Encountered BTP message twice!");
+    }
+  }
+
+
+  /**
+   * Join a response from a remote server to a pending response that has been previously returned to a caller who is
+   * waiting for it to be completed or to timeout.
+   *
+   * @param incomingBtpResponse A {@link BtpResponse} from a remote server that should be used to complete a pending
+   *                            response future. Note that this value is never <tt>Optional</tt> because the system
+   *                            either gets a response from a remote BTP connection, or else the pending future
+   *                            times-out.
+   *
+   * @return {@code true} if this invocation caused a pending response to transition to a completed state, else {@code
+   *     false}.
+   */
+  protected boolean joinPendingResponse(final BtpResponse incomingBtpResponse) {
+    Objects.requireNonNull(incomingBtpResponse,
+        "incomingBtpResponse must not be null in order to correlate to a pending response identifier!");
+
+    final CompletableFuture<BtpResponsePacket> pendingResponse = pendingResponses
+        .get(incomingBtpResponse.getRequestId());
+
+    // If there's no pending response, then return empty, and log an error.
+    if (pendingResponse == null) {
+      logger.error("No PendingResponse available to connect to incomingBtpResponse: {}", incomingBtpResponse);
+      return false;
+    } else {
+      // Always connect the `responseToReturn` to a pendingResponse, which has been previously returned to a caller
+      // who is waiting for it to be completed or to timeout. If a pendingResponse exists (getting here implies that it
+      // does exist), then we need to complete the pendingResponse with the value found in `responseToReturn`.
+
+      try {
+        // TODO: Consider acceptEither instead
+        //  (http://www.deadcoderising.com/java8-writing-asynchronous-code-with-completablefuture/)
+
+        // First, call `anyOf` on the pendingResponse and a new CF. If `pendingResponse` has timed-out, it will trigger
+        // this future to return with an error. Otherwise, if `pendingResponse` has not timed-out, then the new CF will
+        // be returned. Note that there is a race-condition here that if both CF's are completed, it's ambiguous which
+        // one will be returned. However, this should rarely occur, and either result is tolerable.
+        anyOf(pendingResponse, CompletableFuture.completedFuture(incomingBtpResponse))
+            .handle((response, error) -> {
+              if (error != null) {
+                logger.error(error.getMessage(), error);
+//               if (error instanceof BtpRuntimeException) {
+//                 final BtpRuntimeException btpRuntimeException = (BtpRuntimeException) error;
+//                 final BtpError btpError = constructBtpError(
+//                     incomingBtpPacket.getRequestId(), btpRuntimeException.getMessage(),
+//                     btpRuntimeException.getTriggeredAt(), btpRuntimeException.getCode()
+//                 );
+//                 return Optional.of(btpPacketToBinaryMessageConverter.convert(btpError));
+//               } else {
+//                 // There was an error processing, so return a BtpError response back to the waiting caller.
+//                 final BtpError btpError = constructBtpError(
+//                     incomingBtpPacket.getRequestId(), error.getMessage(), Instant.now(),
+//                     BtpErrorCode.T00_UnreachableError
+//                 );
+//                 return Optional.of(btpPacketToBinaryMessageConverter.convert(btpError));
+//               }
+                return false;
+              } else {
+                // Pipe the incomingBtpResponse into the pending response so that whatever caller is waiting for it will
+                // receive it.
+                return pendingResponse.complete(incomingBtpResponse);
+              }
+            })
+            // Join is preferable here as opposed to get(timeout) because the anyOf (above) combines a timeout future,
+            // so no need to timeout again...
+            .join();
+
+        return true;
+      } catch (CompletionException e) {
+        if (e.getCause() instanceof BtpRuntimeException) {
+          throw (BtpRuntimeException) e.getCause();
+        } else {
+          throw new RuntimeException(e);
+        }
+      }
+    }
+  }
+
+  protected final BtpError constructBtpError(final long requestId, final String errorData,
+      final Instant triggeredAt, final BtpErrorCode btpErrorCode) {
+    Objects.requireNonNull(errorData);
+
+    // Respond with a BTP Error on the websocket session.
+    return BtpError.builder()
+        .requestId(requestId)
+        .triggeredAt(triggeredAt)
+        .errorCode(btpErrorCode)
+        .errorData(errorData.getBytes(Charset.forName("UTF-8")))
+        .build();
+  }
+
+  public BtpSubProtocolHandlerRegistry getBtpSubProtocolHandlerRegistry() {
+    return btpSubProtocolHandlerRegistry;
+  }
+
+  public BinaryMessageToBtpPacketConverter getBinaryMessageToBtpPacketConverter() {
+    return binaryMessageToBtpPacketConverter;
+  }
+
+  public BtpPacketToBinaryMessageConverter getBtpPacketToBinaryMessageConverter() {
+    return btpPacketToBinaryMessageConverter;
+  }
+
+  ///////////////////
+  // WebSocketHandler
+  ///////////////////
+
+  /**
+   * Invoked after WebSocket negotiation has succeeded and the WebSocket connection is opened and ready for use.
+   *
+   * @param session
+   *
+   * @throws Exception this method can handle or propagate exceptions; see class-level Javadoc for details.
+   */
+  @Override
+  public void afterConnectionEstablished(WebSocketSession session) {
+    logger.debug("Incoming WS Client Connection Established: {}", session);
+
+    // Add a new BtpSession into the WebsocketSession...it will be initialized after the `auth` sub_protocol is
+    // executed.
+    BtpSessionUtils.setBtpSessionIntoWebsocketSession(session, new BtpSession(session.getId()));
+  }
+
+  /**
+   * Invoked when a new incoming WebSocket message arrives.
+   *
+   * @param session
+   * @param message
+   *
+   * @throws Exception this method can handle or propagate exceptions; see class-level Javadoc for details.
+   */
+  @Override
+  public void handleMessage(WebSocketSession session, WebSocketMessage<?> message) {
+    if (message instanceof BinaryMessage) {
+      this.handleBinaryMessage(session, (BinaryMessage) message);
+    } else {
+      throw new IllegalStateException("Unexpected WebSocket message type: " + message);
+    }
+  }
+
+  /**
+   * Handle an error from the underlying WebSocket message transport.
+   *
+   * @param session
+   * @param exception
+   *
+   * @throws Exception this method can handle or propagate exceptions; see class-level Javadoc for details.
+   */
+  @Override
+  public void handleTransportError(WebSocketSession session, Throwable exception) {
+    // Don't premptively close any connections. It's possible this is just a transient error, and we can wait until the
+    // actual connection closes to disconnect this MUX.
+    logger.error(exception.getMessage(), exception);
+  }
+
+  /**
+   * Invoked after the WebSocket connection has been closed by either side, or after a transport error has occurred.
+   * Although the session may technically still be open, depending on the underlying implementation, sending messages at
+   * this point is discouraged and most likely will not succeed.
+   *
+   * @param session
+   * @param closeStatus
+   *
+   * @throws Exception this method can handle or propagate exceptions; see class-level Javadoc for details.
+   */
+  @Override
+  public void afterConnectionClosed(WebSocketSession session, CloseStatus closeStatus) {
+    logger.debug("WS Client Connection Closed: {}", session);
+
+    // BilateralReceivers (typically plugins) aren't aware that they're being MUX'd, so this MUX must disconnect each
+    // one.
+    this.disconnect();
+
+//    final CompletableFuture[] disconnectFutures = this.getBilateralReceivers().values().stream()
+//        .map(BilateralReceiver::disconnect)
+//        .collect(Collectors.toList())
+//        .toArray(new CompletableFuture[0]);
+
+//    // Wait up to 30 seconds for all disconnects to occur...
+//    try {
+//      CompletableFuture.allOf(disconnectFutures).get(30, TimeUnit.SECONDS);
+//    } catch (Exception e) {
+//      throw new RuntimeException(e.getMessage(), e);
+//    }
+  }
+
+  @Override
+  public boolean supportsPartialMessages() {
+    return false;
+  }
+}
Index: ilp-plugin-btp/src/main/java/org/interledger/plugin/lpiv2/btp2/BtpReceiver.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ilp-plugin-btp/src/main/java/org/interledger/plugin/lpiv2/btp2/BtpReceiver.java	(date 1546443365000)
+++ ilp-plugin-btp/src/main/java/org/interledger/plugin/lpiv2/btp2/BtpReceiver.java	(date 1546443365000)
@@ -0,0 +1,25 @@
+package org.interledger.plugin.lpiv2.btp2;
+
+import org.interledger.btp.BtpPacket;
+import org.interledger.btp.BtpResponsePacket;
+import org.interledger.btp.BtpSession;
+
+import java.util.Optional;
+
+/**
+ * Defines the contract that any sender of BTP packets must implement.
+ */
+public interface BtpReceiver {
+
+  /**
+   * Handle an incoming BTP Packet. The payload may be a BTP Request type, or it may be a BTP response type, so
+   * implementations must handle all BTP packet types approporiately.
+   *
+   * @param btpSession        The {@link BtpSession} associated with the incoming packet.
+   * @param incomingBtpPacket A {@link BtpPacket} sent from the bilateral BTP peer.
+   *
+   * @return An optionally-present response of type {@link BtpResponsePacket}.
+   */
+  Optional<BtpResponsePacket> handleBtpPacket(BtpSession btpSession, BtpPacket incomingBtpPacket);
+
+}
Index: ilp-plugin-btp-springws/src/main/java/org/interledger/plugin/lpiv2/btp2/spring/AbstractBtpPlugin.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ilp-plugin-btp-springws/src/main/java/org/interledger/plugin/lpiv2/btp2/spring/AbstractBtpPlugin.java	(date 1546465587000)
+++ ilp-plugin-btp-springws/src/main/java/org/interledger/plugin/lpiv2/btp2/spring/AbstractBtpPlugin.java	(date 1546465587000)
@@ -0,0 +1,617 @@
+package org.interledger.plugin.lpiv2.btp2.spring;
+
+import static java.util.concurrent.CompletableFuture.anyOf;
+import static org.interledger.plugin.lpiv2.btp2.subprotocols.BtpSubProtocolHandlerRegistry.BTP_SUB_PROTOCOL_AUTH;
+import static org.interledger.plugin.lpiv2.btp2.subprotocols.BtpSubProtocolHandlerRegistry.BTP_SUB_PROTOCOL_AUTH_TOKEN;
+import static org.interledger.plugin.lpiv2.btp2.subprotocols.BtpSubProtocolHandlerRegistry.BTP_SUB_PROTOCOL_AUTH_USERNAME;
+
+import org.interledger.btp.BtpError;
+import org.interledger.btp.BtpErrorCode;
+import org.interledger.btp.BtpMessage;
+import org.interledger.btp.BtpPacket;
+import org.interledger.btp.BtpPacketMapper;
+import org.interledger.btp.BtpResponse;
+import org.interledger.btp.BtpResponsePacket;
+import org.interledger.btp.BtpRuntimeException;
+import org.interledger.btp.BtpSession;
+import org.interledger.btp.BtpSessionCredentials;
+import org.interledger.btp.BtpSubProtocol;
+import org.interledger.btp.BtpSubProtocol.ContentType;
+import org.interledger.btp.BtpSubProtocols;
+import org.interledger.btp.BtpTransfer;
+import org.interledger.plugin.lpiv2.AbstractPlugin;
+import org.interledger.plugin.lpiv2.btp2.BtpPluginSettings;
+import org.interledger.plugin.lpiv2.btp2.BtpReceiver;
+import org.interledger.plugin.lpiv2.btp2.BtpSender;
+import org.interledger.plugin.lpiv2.btp2.spring.converters.BinaryMessageToBtpPacketConverter;
+import org.interledger.plugin.lpiv2.btp2.spring.converters.BtpConversionException;
+import org.interledger.plugin.lpiv2.btp2.spring.converters.BtpPacketToBinaryMessageConverter;
+import org.interledger.plugin.lpiv2.btp2.subprotocols.AbstractBtpSubProtocolHandler;
+import org.interledger.plugin.lpiv2.btp2.subprotocols.BtpSubProtocolHandlerRegistry;
+
+import com.google.common.collect.Maps;
+import org.springframework.web.socket.BinaryMessage;
+import org.springframework.web.socket.WebSocketMessage;
+import org.springframework.web.socket.WebSocketSession;
+
+import java.io.IOException;
+import java.nio.charset.Charset;
+import java.nio.charset.StandardCharsets;
+import java.security.SecureRandom;
+import java.time.Instant;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Optional;
+import java.util.Random;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.CompletionException;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.locks.LockSupport;
+
+public abstract class AbstractBtpPlugin<PS extends BtpPluginSettings> extends AbstractPlugin<PS> implements
+    BtpSender, BtpReceiver {
+
+  // TODO: Use WeakHashMap?
+  // When the client sends a request out to a peer, it will wait for an async response from that peer. When that
+  // response comes back, it will be combined with a pending response.
+  protected final Map<Long, CompletableFuture<BtpResponsePacket>> pendingResponses;
+
+  private final BinaryMessageToBtpPacketConverter binaryMessageToBtpPacketConverter;
+  private final BtpPacketToBinaryMessageConverter btpPacketToBinaryMessageConverter;
+  private final BtpSubProtocolHandlerRegistry btpSubProtocolHandlerRegistry;
+
+  private final Random random;
+
+  /**
+   * Required-args Constructor.
+   */
+  public AbstractBtpPlugin(
+      final PS pluginSettings,
+      final BinaryMessageToBtpPacketConverter binaryMessageToBtpPacketConverter,
+      final BtpPacketToBinaryMessageConverter btpPacketToBinaryMessageConverter,
+      final BtpSubProtocolHandlerRegistry btpSubProtocolHandlerRegistry
+  ) {
+    super(pluginSettings);
+
+    this.binaryMessageToBtpPacketConverter = Objects.requireNonNull(binaryMessageToBtpPacketConverter);
+    this.btpPacketToBinaryMessageConverter = Objects.requireNonNull(btpPacketToBinaryMessageConverter);
+    this.btpSubProtocolHandlerRegistry = Objects.requireNonNull(btpSubProtocolHandlerRegistry);
+
+    this.pendingResponses = Maps.newConcurrentMap();
+    this.random = new SecureRandom();
+  }
+
+//  ////////////////////
+//  // BtpSender Methods
+//  ////////////////////
+//
+//  /**
+//   * Converts {@code btpMessage} into the proper binary format and then sends the payload out over the websocket,
+//   * waiting for a response.
+//   */
+//  @Override
+//  public CompletableFuture<BtpResponsePacket> sendBtpMessage(final BtpMessage btpMessage) {
+//    Objects.requireNonNull(btpMessage);
+//
+//    // Translate the btpMessage to a BinaryMessage, and send out using the WebSocketSession.
+//    return this.webSocketSession
+//        .map(wss -> {
+//          final BinaryMessage binaryMessage = this.btpPacketToBinaryMessageConverter.convert(btpMessage);
+//          final long requestId = nextRequestId();
+//          return this.sendMessageWithPendingRepsonse(requestId, wss, binaryMessage)
+//              .handle((response, error) -> {
+//                if (error != null) {
+//                  // the pending response timed out or otherwise had a problem...
+//                  throw new RuntimeException(error.getMessage(), error);
+//                } else {
+//                  // Might be an error or a response`
+//                  return response;
+//                }
+//              });
+//        }).orElseThrow(() -> new RuntimeException("No WebSocket session!"));
+//  }
+//
+//  @Override
+//  public CompletableFuture<BtpResponsePacket> sendBtpTransfer(BtpTransfer btpTransfer) {
+//    throw new RuntimeException("FIXME!");
+//    //return CompletableFuture.completedFuture(null);
+//  }
+
+  //////////////////////
+  // BtpReceiver Methods
+  //////////////////////
+
+  /**
+   * Handle an incoming BTP Packet. The payload may be a BTP Request type, or it may be a BTP response type, so
+   * implementations must handle all BTP packet types approporiately.
+   *
+   * @param incomingBtpPacket A {@link BtpPacket} sent from the bilateral BTP peer.
+   *
+   * @return An optionally-present response of type {@link BtpResponsePacket}.
+   */
+  @Override
+  public Optional<BtpResponsePacket> handleBtpPacket(final BtpSession btpSession, final BtpPacket incomingBtpPacket) {
+    Objects.requireNonNull(btpSession, "BtpSession is required!");
+    Objects.requireNonNull(incomingBtpPacket);
+
+    try {
+      // If incomingBtpMessage is a BTPResponse, we need to connect it to a pending sendData. If this is a
+      // BtpMessage, we can simply handle it...
+      return new BtpPacketMapper<Optional<BtpResponsePacket>>() {
+        @Override
+        protected Optional<BtpResponsePacket> mapBtpMessage(final BtpMessage incomingBtpMessage) {
+          Objects.requireNonNull(incomingBtpMessage);
+          logger.trace("incomingBtpMessage: {}", incomingBtpMessage);
+
+          // A WebSocketSession always has a BtpSession, but it may not be authenticated...
+          final BtpResponse btpResponse = handleIncomingBtpMessage(btpSession, incomingBtpMessage);
+          return Optional.of(btpResponse);
+        }
+
+        @Override
+        protected Optional<BtpResponsePacket> mapBtpTransfer(final BtpTransfer incomingBtpTransfer) {
+          Objects.requireNonNull(incomingBtpTransfer);
+          logger.trace("incomingBtpMessage: {}", incomingBtpTransfer);
+          throw new RuntimeException("Not yet implemented!");
+        }
+
+        @Override
+        protected Optional<BtpResponsePacket> mapBtpError(BtpError incomingBtpError) {
+          Objects.requireNonNull(incomingBtpError);
+          logger.error(
+              "Incoming BtpError from `{}` with message `{}`",
+              btpSession.getBtpSessionCredentials().get(), new String(incomingBtpError.getErrorData())
+          );
+
+          // The incoming message was a BtpError, so don't return a response to the peer.
+          return Optional.empty();
+        }
+
+        @Override
+        protected Optional<BtpResponsePacket> mapBtpResponse(final BtpResponse incomingBtpResponse) {
+          Objects.requireNonNull(incomingBtpResponse);
+
+          logger.trace("IncomingBtpResponse: {} ", incomingBtpResponse);
+
+          // Generally, BTP always returns a response to the caller, even under error conditions. There are two
+          // exceptions, however, listed as "tricky cases" in the BTP specification:
+          //
+          // 1. An unexpected BTP packet is received
+          // 2. An unreadable BTP packet is received
+          //
+          // If the packet was unreadable, then this method will have never been called, so we can ignore this
+          // case here. However, if an unexpected packet is encountered, we need to emit this error, but then return
+          // null to the caller of this method so that no response is returned to the BTP peer.
+
+          // TODO: If auth fails on the server, we might need to send a response from the join....otherwise, just
+          // return Optional.empty();
+          if (joinPendingResponse(incomingBtpResponse)) {
+            return Optional.empty();
+          } else {
+            return Optional.empty();
+          }
+        }
+      }.map(incomingBtpPacket);
+    } catch (BtpRuntimeException e) {
+      logger.error(e.getMessage(), e);
+      // If anything throws a BTP Exception, then return a BTP Error on the channel...
+      final BtpError btpError = e.toBtpError(incomingBtpPacket.getRequestId());
+      return Optional.of(btpError);
+    }
+  }
+
+  /**
+   * Handle an incoming BinaryMessage from a Websocket by converting it into a {@link BtpMessage} and forwarding it to
+   * the appropriate receiver (i.e., plugin).
+   *
+   * @param webSocketSession
+   * @param incomingBinaryMessage
+   *
+   * @return A {@link BinaryMessage} that can immediately be returned to the caller (this response will contain
+   *     everything required to be eligible as a BTP response), or nothing if the response is {@link Optional#empty()}.
+   */
+  public void handleBinaryMessage(
+      final WebSocketSession webSocketSession, final BinaryMessage incomingBinaryMessage
+  ) {
+    Objects.requireNonNull(webSocketSession);
+    Objects.requireNonNull(incomingBinaryMessage);
+
+    // The first message in a WebSocketSession MUST be the auth protocol. Thus, as long as the BtpSession is not
+    // authenticated, then we should attempt to perform the auth sub_protocol.
+    final BtpSession btpSession = BtpSessionUtils.getBtpSessionFromWebSocketSession(webSocketSession)
+        .orElseThrow(() -> new RuntimeException("BtpSession is required!"));
+
+    final Optional<BinaryMessage> response;
+    if (!btpSession.isAuthenticated()) {
+      // Do Auth. This will merely initialize the credentials into the BTPSession and return an Ack.
+      response = this.handleBinaryAuthMessage(webSocketSession, incomingBinaryMessage)
+          .map(foo -> btpPacketToBinaryMessageConverter.convert(foo));
+//
+//       This functionality needs to be different between client and server...
+//      client should never echo responses back to the server, so response MUSt always be empty.
+      // A client response will
+//      if(btpResponse.get().getSubProtocols().size() == 0){
+//
+//      }
+
+      //On the client, we need to rejoin the pending response...
+
+      // On the client, a pendingResponse will be waiting to complete the auth properly....we need to join the empty response to it.
+      //.map(btpResponse -> this.joinPendingResponse(btpResponse))
+      //.map($ -> Optional.<BinaryMessage>empty())
+      //.orElse(Optional.empty());
+    } else {
+      // If the auth subprotocol completes successfully, then we'll end up here with an authenticated Websocket Session.
+      try {
+        // If there's a problem de-serializing the BtpPacket from the BinaryMessage, then close the connection and
+        // return empty. This is one of the "tricky cases" as defined in the BTP spec where we don't want to get into
+        // an infinite loop.
+        final BtpPacket incomingBtpPacket = this.binaryMessageToBtpPacketConverter.convert(incomingBinaryMessage);
+        final Optional<BtpResponsePacket> btpResponse = this.handleBtpPacket(btpSession, incomingBtpPacket);
+        if (btpResponse.isPresent()) {
+          response = Optional.of(btpPacketToBinaryMessageConverter.convert(btpResponse.get()));
+        } else {
+          response = Optional.empty();
+        }
+      } catch (BtpConversionException btpConversionException) {
+        logger.error("Unable to deserialize BtpPacket from incomingBinaryMessage: {}", btpConversionException);
+        this.disconnect().join();
+        return;
+      }
+    }
+
+    // Return the response to the caller, if there is a response.
+    response.ifPresent($ -> {
+      try {
+        // TODO: What does the other side of the WebSocket see if there's an exception here?
+        webSocketSession.sendMessage($);
+      } catch (IOException e) {
+        throw new RuntimeException(e);
+      }
+    });
+
+  }
+
+  /**
+   * Handle an incoming BinaryMessage from a Websocket, assuming it's a BTP Auth message.
+   *
+   * @param webSocketSession
+   * @param incomingBinaryMessage
+   *
+   * @return A {@link BinaryMessage} that can immediately be returned to the caller (this response will contain
+   *     everything required to be eligible as a BTP response), or nothing if the response is {@link Optional#empty()}.
+   */
+  public Optional<BtpResponse> handleBinaryAuthMessage(
+      final WebSocketSession webSocketSession, final BinaryMessage incomingBinaryMessage
+  ) {
+    Objects.requireNonNull(webSocketSession);
+    Objects.requireNonNull(incomingBinaryMessage);
+
+    final AbstractBtpSubProtocolHandler btpAuthSubprotocolHandler = this.btpSubProtocolHandlerRegistry
+        .getHandler(BTP_SUB_PROTOCOL_AUTH, ContentType.MIME_APPLICATION_OCTET_STREAM)
+        .orElseThrow(() -> new RuntimeException("No Auth Subprotocol Handler registered!"));
+
+    // If there's a problem de-serializing the BtpPacket from the BinaryMessage, then close the connection and
+    // return empty. This is one of the "tricky cases" as defined in the BTP spec where we don't want to get into
+    // an infinite loop.
+    final BtpPacket incomingBtpPacket;
+    try {
+      incomingBtpPacket = this.binaryMessageToBtpPacketConverter.convert(incomingBinaryMessage);
+      final BtpSession btpSession = BtpSessionUtils.getBtpSessionFromWebSocketSession(webSocketSession)
+          .orElseThrow(() -> new RuntimeException("BtpSession is required!"));
+      return btpAuthSubprotocolHandler.handleSubprotocolMessage(btpSession, incomingBtpPacket)
+          .thenApply(btpSubProtocol -> btpSubProtocol
+              .map($ -> {
+                // If there's no exception, then reaching here means the btp_auth SubProtocol succeeded.
+                // Ack the response, but only if
+                final BtpSubProtocols responses = new BtpSubProtocols();
+                responses.add($);
+                final BtpResponse response = BtpResponse.builder()
+                    .requestId(incomingBtpPacket.getRequestId())
+                    .subProtocols(responses)
+                    .build();
+                return response;
+              })
+              //.map(btpPacketToBinaryMessageConverter::convert)
+              .map(Optional::of)
+              // If there is no sub-protocol to return, then return empty so no response is sent back over the connection.
+              .orElse(Optional.empty())
+          )
+          .join();
+    } catch (BtpConversionException btpConversionException) {
+      logger.error(btpConversionException.getMessage(), btpConversionException);
+      throw btpConversionException;
+    }
+  }
+
+  /**
+   * <p>Handles an incoming {@link BtpMessage} by delegating it to a registered handler.</p>
+   *
+   * <p>There are also a couple of tricky cases to handle:</p>
+   *
+   * <ul>
+   * <li>If an unexpected BTP packet is received, no response should be sent. An unexpected BTP packet is a
+   * response for which a request was not sent, or a response for a request which has already been responded to.</li>
+   * <li>If an unreadable BTP packet is received, no response should be sent. An unreadable BTP packet is one which
+   * is structurally invalid, i.e. terminates before length prefixes dictate or contains illegal characters.</li>
+   * </ul>
+   *
+   * <p>Incoming BTP messages can be either requests or responses, so sub-classes should be careful to handle both
+   * types of message, especially when bridging to synchronous API contracts, where it may become confusing as to
+   * whether an incoming message corresponds to the input our output portion of a particular synchronous method.</p>
+   *
+   * @param btpSession
+   * @param incomingBtpMessage
+   *
+   * @return
+   */
+  // TODO: Use future?
+  public BtpResponse handleIncomingBtpMessage(final BtpSession btpSession, final BtpMessage incomingBtpMessage)
+      throws BtpRuntimeException {
+
+    Objects.requireNonNull(btpSession);
+    Objects.requireNonNull(incomingBtpMessage);
+
+    try {
+      final BtpSubProtocols responses = new BtpSubProtocols();
+
+      // Only the primary sub-protocol should be handled. The secondary sub-protocols should not request additional
+      // actions or information. If multiple actions or pieces of information are required, multiple separate Messages
+      // should be sent. The secondary sub-protocols should only modify the request made in the primary sub-protocol, or
+      // provide additional contextual data which can be consumed in a readonly way (without affecting the result).
+      final BtpSubProtocol primarySubprotocol = incomingBtpMessage.getPrimarySubProtocol();
+      final AbstractBtpSubProtocolHandler handler =
+          this.btpSubProtocolHandlerRegistry
+              .getHandler(primarySubprotocol.getProtocolName(), primarySubprotocol.getContentType())
+              .orElseThrow(() -> new BtpRuntimeException(
+                  BtpErrorCode.F00_NotAcceptedError,
+                  String.format("No BTP Handler registered for BTP SubProtocol: %s",
+                      primarySubprotocol.getProtocolName()))
+              );
+
+      final CompletableFuture<Optional<BtpSubProtocol>> btpSubProtocolResponse = handler
+          .handleSubprotocolMessage(btpSession, incomingBtpMessage);
+
+      // Add the response, but only if it's present.
+      btpSubProtocolResponse.get().ifPresent(responses::add);
+
+      // Now that there's a proper response, send it back to the connected client...
+      return BtpResponse.builder()
+          .requestId(incomingBtpMessage.getRequestId())
+          .subProtocols(responses)
+          .build();
+    } catch (Exception e) {
+      throw new BtpRuntimeException(BtpErrorCode.T00_UnreachableError, e.getMessage(), e);
+    }
+  }
+
+  /**
+   * Returns the next random request id using a PRNG.
+   */
+  protected long nextRequestId() {
+    return Math.abs(random.nextInt());
+  }
+
+  /**
+   * An authentication message must have as its primary <tt>protocolData</tt> entry must have the name of 'auth',
+   * content type <tt>MIME_APPLICATION_OCTET_STREAM</tt>, and empty data, and among the secondary entries, there MUST be
+   * a UTF-8 'auth_token' entry.
+   *
+   * @return
+   */
+  public BtpMessage constructAuthMessage(
+      final long requestId, final BtpSessionCredentials btpSessionCredentials
+  ) {
+    Objects.requireNonNull(btpSessionCredentials);
+
+    final BtpSubProtocol authSubProtocol = BtpSubProtocol.builder()
+        .protocolName(BTP_SUB_PROTOCOL_AUTH)
+        .contentType(BtpSubProtocol.ContentType.MIME_APPLICATION_OCTET_STREAM)
+        .build();
+    final BtpSubProtocols btpSubProtocols = BtpSubProtocols.fromPrimarySubProtocol(authSubProtocol);
+
+    // In situations where no authentication is needed, the 'auth_token' data can be set to the empty string,
+    // but it cannot be omitted.
+    final BtpSubProtocol authTokenSubprotocol = BtpSubProtocol.builder()
+        .protocolName(BTP_SUB_PROTOCOL_AUTH_TOKEN)
+        .contentType(BtpSubProtocol.ContentType.MIME_APPLICATION_OCTET_STREAM)
+        .data(btpSessionCredentials.getAuthToken().getBytes(StandardCharsets.UTF_8))
+        .build();
+    btpSubProtocols.add(authTokenSubprotocol);
+
+    btpSessionCredentials.getAuthUsername().ifPresent($ -> {
+      final BtpSubProtocol authUsernameSubprotocol = BtpSubProtocol.builder()
+          .protocolName(BTP_SUB_PROTOCOL_AUTH_USERNAME)
+          .contentType(BtpSubProtocol.ContentType.MIME_APPLICATION_OCTET_STREAM)
+          .data($.getBytes(StandardCharsets.UTF_8))
+          .build();
+      btpSubProtocols.add(authUsernameSubprotocol);
+    });
+
+    return BtpMessage.builder()
+        .requestId(requestId)
+        .subProtocols(btpSubProtocols)
+        .build();
+  }
+
+  protected CompletableFuture<BtpResponsePacket> sendMessageWithPendingRepsonse(
+      final long requestId, final WebSocketSession webSocketSession, final WebSocketMessage webSocketMessage
+  ) {
+    Objects.requireNonNull(webSocketMessage);
+    try {
+      // Register the pending response first, just in-cae the Websocket returns faster than this method can complete.
+      final CompletableFuture<BtpResponsePacket> pendingResponse = registerPendingResponse(requestId);
+      webSocketSession.sendMessage(webSocketMessage);
+      return pendingResponse;
+    } catch (IOException e) {
+      try {
+        this.disconnect().get();
+      } catch (Exception e1) {
+        throw new RuntimeException(e1);
+      }
+      throw new RuntimeException(e);
+    }
+  }
+
+  /**
+   * <p>Register and return a "pending response", mapping it to the supplied {@code requestId}. This mechanism works by
+   * returning a completed future to a caller, who then waits for the future to be completed. The receiver processes the
+   * request, and eventually returns a response by completing the appropriate <tt>pending respsonse</tt>.</p>
+   *
+   * <p>The following diagram illustrates this flow:</p>
+   *
+   * <pre>
+   * ┌──────────┐                                              ┌──────────┐
+   * │          │────────────Request (Object)─────────────────▷│          │
+   * │          │                                              │          │
+   * │          │             Response (Uncompleted            │          │
+   * │          │◁─────────────CompletableFuture)───△──────────┤          │
+   * │          │                                   │          │          │
+   * │          │                                   │          │          │
+   * │          │                                   │          │          │
+   * │          │                                   │          │          │
+   * │  Sender  │                                   │ Complete │ Receiver │
+   * │          │                                   └or Timeout┤          │
+   * │          │                                              │          │
+   * │          │                                              │          │
+   * │          │                                              │          │
+   * │          │                                              │          │
+   * │          │                                              │          │
+   * │          │                                              │          │
+   * │          │                                              │          │
+   * └──────────┘                                              └──────────┘
+   * </pre>
+   *
+   * @param requestId The unique identifier of the request that should receive a response, but only once that response
+   *                  can be returned.
+   *
+   * @return
+   */
+  protected final CompletableFuture<BtpResponsePacket> registerPendingResponse(final long requestId) {
+
+    // TODO: Use WeakReferences here to prevent memory leaks...
+
+    // This response will expire in the alotted time (see below). This response is immediately returned to the caller,
+    // but nothing happens until this CF expires, or the CF is completed from a different thread (by passing-in an
+    // incoming message, which is actually a response).
+    final CompletableFuture<BtpResponsePacket> pendingResponse = CompletableFuture.supplyAsync(
+        () -> {
+          // TODO: Configure this amount as a property.
+          // TODO: Move back to seconds and set a default of 15.
+          LockSupport.parkNanos(TimeUnit.MINUTES.toNanos(15));
+          throw new BtpRuntimeException(BtpErrorCode.F00_NotAcceptedError, "BTP SendData operation timed-out!");
+        }
+    );
+
+    if (this.pendingResponses.putIfAbsent(requestId, pendingResponse) == null) {
+      return pendingResponse;
+    } else {
+      // TODO: Just log an error and ignore?
+      throw new RuntimeException("Encountered BTP message twice!");
+    }
+  }
+
+
+  /**
+   * Join a response from a remote server to a pending response that has been previously returned to a caller who is
+   * waiting for it to be completed or to timeout.
+   *
+   * @param incomingBtpResponse A {@link BtpResponse} from a remote server that should be used to complete a pending
+   *                            response future. Note that this value is never <tt>Optional</tt> because the system
+   *                            either gets a response from a remote BTP connection, or else the pending future
+   *                            times-out.
+   *
+   * @return {@code true} if this invocation caused a pending response to transition to a completed state, else {@code
+   *     false}.
+   */
+  protected boolean joinPendingResponse(final BtpResponse incomingBtpResponse) {
+    Objects.requireNonNull(incomingBtpResponse,
+        "incomingBtpResponse must not be null in order to correlate to a pending response identifier!");
+
+    final CompletableFuture<BtpResponsePacket> pendingResponse = pendingResponses
+        .get(incomingBtpResponse.getRequestId());
+
+    // If there's no pending response, then return empty, and log an error.
+    if (pendingResponse == null) {
+      logger.error("No PendingResponse available to connect to incomingBtpResponse: {}", incomingBtpResponse);
+      return false;
+    } else {
+      // Always connect the `responseToReturn` to a pendingResponse, which has been previously returned to a caller
+      // who is waiting for it to be completed or to timeout. If a pendingResponse exists (getting here implies that it
+      // does exist), then we need to complete the pendingResponse with the value found in `responseToReturn`.
+
+      try {
+        // TODO: Consider acceptEither instead
+        //  (http://www.deadcoderising.com/java8-writing-asynchronous-code-with-completablefuture/)
+
+        // First, call `anyOf` on the pendingResponse and a new CF. If `pendingResponse` has timed-out, it will trigger
+        // this future to return with an error. Otherwise, if `pendingResponse` has not timed-out, then the new CF will
+        // be returned. Note that there is a race-condition here that if both CF's are completed, it's ambiguous which
+        // one will be returned. However, this should rarely occur, and either result is tolerable.
+        anyOf(pendingResponse, CompletableFuture.completedFuture(incomingBtpResponse))
+            .handle((response, error) -> {
+              if (error != null) {
+                logger.error(error.getMessage(), error);
+//               if (error instanceof BtpRuntimeException) {
+//                 final BtpRuntimeException btpRuntimeException = (BtpRuntimeException) error;
+//                 final BtpError btpError = constructBtpError(
+//                     incomingBtpPacket.getRequestId(), btpRuntimeException.getMessage(),
+//                     btpRuntimeException.getTriggeredAt(), btpRuntimeException.getCode()
+//                 );
+//                 return Optional.of(btpPacketToBinaryMessageConverter.convert(btpError));
+//               } else {
+//                 // There was an error processing, so return a BtpError response back to the waiting caller.
+//                 final BtpError btpError = constructBtpError(
+//                     incomingBtpPacket.getRequestId(), error.getMessage(), Instant.now(),
+//                     BtpErrorCode.T00_UnreachableError
+//                 );
+//                 return Optional.of(btpPacketToBinaryMessageConverter.convert(btpError));
+//               }
+                return false;
+              } else {
+                // Pipe the incomingBtpResponse into the pending response so that whatever caller is waiting for it will
+                // receive it.
+                return pendingResponse.complete(incomingBtpResponse);
+              }
+            })
+            // Join is preferable here as opposed to get(timeout) because the anyOf (above) combines a timeout future,
+            // so no need to timeout again...
+            .join();
+
+        return true;
+      } catch (CompletionException e) {
+        if (e.getCause() instanceof BtpRuntimeException) {
+          throw (BtpRuntimeException) e.getCause();
+        } else {
+          throw new RuntimeException(e);
+        }
+      }
+    }
+  }
+
+  protected final BtpError constructBtpError(final long requestId, final String errorData,
+      final Instant triggeredAt, final BtpErrorCode btpErrorCode) {
+    Objects.requireNonNull(errorData);
+
+    // Respond with a BTP Error on the websocket session.
+    return BtpError.builder()
+        .requestId(requestId)
+        .triggeredAt(triggeredAt)
+        .errorCode(btpErrorCode)
+        .errorData(errorData.getBytes(Charset.forName("UTF-8")))
+        .build();
+  }
+
+  public BtpSubProtocolHandlerRegistry getBtpSubProtocolHandlerRegistry() {
+    return btpSubProtocolHandlerRegistry;
+  }
+
+  public BinaryMessageToBtpPacketConverter getBinaryMessageToBtpPacketConverter() {
+    return binaryMessageToBtpPacketConverter;
+  }
+
+  public BtpPacketToBinaryMessageConverter getBtpPacketToBinaryMessageConverter() {
+    return btpPacketToBinaryMessageConverter;
+  }
+
+}
Index: ilp-plugin-core/src/main/java/org/interledger/plugin/ClientPlugin.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ilp-plugin-core/src/main/java/org/interledger/plugin/ClientPlugin.java	(date 1546192099000)
+++ ilp-plugin-core/src/main/java/org/interledger/plugin/ClientPlugin.java	(date 1546192099000)
@@ -0,0 +1,53 @@
+package org.interledger.plugin;
+
+import org.interledger.core.InterledgerPreparePacket;
+import org.interledger.core.InterledgerResponsePacket;
+import org.interledger.plugin.lpiv2.AbstractPlugin;
+import org.interledger.plugin.lpiv2.Plugin;
+import org.interledger.plugin.lpiv2.PluginSettings;
+
+import java.util.Optional;
+import java.util.concurrent.CompletableFuture;
+
+public class ClientPlugin extends AbstractPlugin<PluginSettings> implements Plugin<PluginSettings> {
+
+  //private final BilateralSenderMux
+  protected ClientPlugin(PluginSettings pluginSettings) {
+    super(pluginSettings);
+
+    this.registerDataSender(new DataSender() {
+      @Override
+      public CompletableFuture<Optional<InterledgerResponsePacket>> sendData(InterledgerPreparePacket preparePacket) {
+
+        // In order to send-data, this client needs to connect to a web-socket, and send packets on that connection, as well as
+        // listen for incoming packets on that connection.
+
+        // Sending data looks different inside of the connector vs outside. Inside, there is a connection+mux, and
+        // when an incoming message comes in via BTP, the message is translated into an ILP packet, and forwarded to
+        // the SwitchingFabric. In there, a plugin is obtained that will then have its sendData called, and this will
+        // need to locate the MUX, and send data via that.
+
+        // Outside of the connector, the sendData method needs to put a message onto a WebSocket connection. The DataHandler
+        // needs to do something in-response to an incoming sendData (which for a client is probably a no-op).
+
+        throw new RuntimeException("WHHAA?");
+      }
+    });
+  }
+
+  /**
+   * Perform the logic of actually connecting to the remote peer.
+   */
+  @Override
+  public CompletableFuture<Void> doConnect() {
+    return null;
+  }
+
+  /**
+   * Perform the logic of disconnecting from the remote peer.
+   */
+  @Override
+  public CompletableFuture<Void> doDisconnect() {
+    return null;
+  }
+}
Index: ilp-plugin-grpc/src/test/java/org/interledger/plugin/mux/grpc/GrpcIOStreamUtilsTest.java
===================================================================
--- ilp-plugin-grpc/src/test/java/org/interledger/plugin/mux/grpc/GrpcIOStreamUtilsTest.java	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
+++ ilp-plugin-bpp-grpc/src/test/java/org/interledger/plugin/lpiv2/bpp/grpc/connection/mux/GrpcIOStreamUtilsTest.java	(date 1545322353000)
@@ -1,4 +1,4 @@
-package org.interledger.plugin.mux.grpc;
+package org.interledger.plugin.lpiv2.bpp.grpc.connection.mux;
 
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.core.Is.is;
@@ -7,8 +7,8 @@
 import static org.interledger.TestArtifacts.PREPARE_PACKET;
 import static org.interledger.TestArtifacts.REJECT_PACKET;
 
-import org.interledger.plugin.mux.grpc.GrpcIOStreamUtils;
 import org.interledger.core.InterledgerPacket;
+import org.interledger.plugin.lpiv2.bpp.grpc.connection.mux.GrpcIOStreamUtils;
 
 import com.google.protobuf.ByteString;
 import org.junit.Test;
Index: ilp-plugin-grpc/src/main/java/org/interledger/plugin/mux/grpc/GrpcIOStreamUtils.java
===================================================================
--- ilp-plugin-grpc/src/main/java/org/interledger/plugin/mux/grpc/GrpcIOStreamUtils.java	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
+++ ilp-plugin-bpp-grpc/src/main/java/org/interledger/plugin/lpiv2/bpp/grpc/connection/mux/GrpcIOStreamUtils.java	(date 1545319920000)
@@ -1,4 +1,4 @@
-package org.interledger.plugin.mux.grpc;
+package org.interledger.plugin.lpiv2.bpp.grpc.connection.mux;
 
 import org.interledger.core.InterledgerPacket;
 import org.interledger.encoding.asn.framework.CodecContext;
@@ -66,7 +66,8 @@
   }
 
   /**
-   * TODO
+   * Convert a Protobuf {@link ByteString} into an {@link InterledgerPacket} by reading the bytes from the protobuf and
+   * pushing them through an instance of {@link CodecContext} that can translate ILP OER encoded bytes.
    *
    * @param ilpCodecContext
    * @param byteString
@@ -98,8 +99,8 @@
 //  }
 
   /**
-   * An inputstream that wraps a {@link ByteBuffer}, which is provided by gRPC. This implementation avoids a second
-   * array copy of bytes to improve packet (de)serialization performance between gRPC, Java, and OER.
+   * An {@link InputStream} that wraps a {@link ByteBuffer} (which is gRPC primitive). This implementation avoids a
+   * second array copy of bytes to improve packet (de)serialization performance between gRPC, Java, and OER.
    */
   public static class ByteBufferBackedInputStream extends InputStream {
 
Index: ilp-plugin-grpc/src/test/java/org/interledger/TestArtifacts.java
===================================================================
--- ilp-plugin-grpc/src/test/java/org/interledger/TestArtifacts.java	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
+++ ilp-plugin-bpp-grpc/src/test/java/org/interledger/TestArtifacts.java	(date 1544458482000)
@@ -1,0 +1,0 @@
Index: ilp-plugin-btp-springws/src/test/java/org/interledger/plugin/lpiv2/btp2/spring/connection/TestHelpers.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ilp-plugin-btp-springws/src/test/java/org/interledger/plugin/lpiv2/btp2/spring/connection/TestHelpers.java	(date 1546390907000)
+++ ilp-plugin-btp-springws/src/test/java/org/interledger/plugin/lpiv2/btp2/spring/connection/TestHelpers.java	(date 1546390907000)
@@ -0,0 +1,106 @@
+package org.interledger.plugin.lpiv2.btp2.spring.connection;
+
+
+import org.interledger.core.InterledgerAddress;
+import org.interledger.core.InterledgerFulfillPacket;
+import org.interledger.core.InterledgerFulfillment;
+import org.interledger.core.InterledgerPreparePacket;
+
+import java.math.BigInteger;
+import java.time.Instant;
+
+/**
+ * An abstract class that provides a common test functionality for any plugins defined in this project.
+ */
+public class TestHelpers {
+
+  public static final byte[] PREIMAGE = "Roads? Where we're going we dont".getBytes();
+  public static final InterledgerFulfillment FULFILLMENT = InterledgerFulfillment.of(PREIMAGE);
+//  public static final byte[] ALTERNATE_PREIMAGE = "11inquagintaquadringentilliard11".getBytes();
+//  public static final InterledgerFulfillment ALTERNATE_FULFILLMENT = InterledgerFulfillment.of(ALTERNATE_PREIMAGE);
+
+  protected static final InterledgerAddress LOCAL_NODE_ADDRESS = InterledgerAddress.of("test1.foo");
+  protected static final InterledgerAddress PEER_ACCOUNT = InterledgerAddress.of("test1.b");
+
+  /*public static ExtendedPluginSettings newPluginSettings() {
+    return new ExtendedPluginSettings() {
+
+      @Override
+      public PluginType getPluginType() {
+        return PluginType.of("ilp-plugin-mock");
+      }
+
+      *//**
+   * The ILP Address for remote peer account this Plugin is connecting to...
+   *//*
+      @Override
+      public InterledgerAddress getAccountAddress() {
+        return PEER_ACCOUNT;
+      }
+
+      *//**
+   * The ILP address of the ILP Node operating this plugin.
+   *//*
+      @Override
+      public InterledgerAddress getLocalNodeAddress() {
+        return LOCAL_NODE_ADDRESS;
+      }
+
+      */
+
+  /**
+   * Additional, custom settings that any plugin can define.
+   *//*
+      @Override
+      public Map<String, Object> getCustomSettings() {
+        return Maps.newConcurrentMap();
+      }
+
+      @Override
+      public String getPassword() {
+        return "password";
+      }
+    };
+  }
+*/
+  public static final InterledgerPreparePacket constructSendDataPreparePacket(
+      final InterledgerAddress destinationAddress
+  ) {
+    return InterledgerPreparePacket.builder()
+        .amount(BigInteger.TEN)
+        .executionCondition(FULFILLMENT.getCondition())
+        .expiresAt(Instant.MAX)
+        .destination(destinationAddress)
+        // Used by Loopback Plugin...
+        .data(PREIMAGE)
+        .build();
+  }
+
+  public static final InterledgerFulfillPacket constructSendDataFulfillPacket() {
+    return InterledgerFulfillPacket.builder()
+        .fulfillment(FULFILLMENT)
+        .data(new byte[32])
+        .build();
+  }
+//
+//  public static final InterledgerRejectPacket getSendDataRejectPacket() {
+//    return InterledgerRejectPacket.builder()
+//        .triggeredBy(PEER_ACCOUNT)
+//        .code(InterledgerErrorCode.F00_BAD_REQUEST)
+//        .message("Handle SendData failed!")
+//        .data(new byte[32])
+//        .build();
+//  }
+
+//  /**
+//   * An example of how to configure custom, though typed, configuration for a plugin.
+//   */
+//  @Immutable
+//  public interface ExtendedPluginSettings extends PluginSettings {
+
+//    /**
+//     * The password for the connector account on the ledger.
+//     */
+//    String getPassword();
+//  }
+}
\ No newline at end of file
Index: ilp-plugin-grpc/src/main/proto/attic/ilpv4.proto
===================================================================
--- ilp-plugin-grpc/src/main/proto/attic/ilpv4.proto	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
+++ ilp-plugin-bpp-grpc/src/main/proto/attic/ilpv4.proto	(date 1545319046000)
@@ -1,7 +1,7 @@
 syntax = "proto3";
 
 option java_multiple_files = false;
-option java_package = "org.interledger.plugin.lpiv2.grpc";
+option java_package = "org.interledger.plugin.lpiv2.bpp.grpc";
 option java_outer_classname = "PluginProto";
 option objc_class_prefix = "LPI";
 
Index: ilp-plugin-grpc/src/main/java/org/interledger/plugin/mux/grpc/bpp/GrpcPushBilateralConnection.java
===================================================================
--- ilp-plugin-grpc/src/main/java/org/interledger/plugin/mux/grpc/bpp/GrpcPushBilateralConnection.java	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
+++ ilp-plugin-bpp-grpc/src/main/java/org/interledger/plugin/lpiv2/bpp/grpc/connection/BppConnection.java	(date 1545321455000)
@@ -1,16 +1,20 @@
-package org.interledger.plugin.mux.grpc.bpp;
+package org.interledger.plugin.lpiv2.bpp.grpc.connection;
 
 import org.interledger.core.InterledgerAddress;
 import org.interledger.plugin.connections.AbstractBilateralConnection;
+import org.interledger.plugin.lpiv2.bpp.grpc.connection.mux.GrpcBppClientMux;
+import org.interledger.plugin.lpiv2.bpp.grpc.connection.mux.GrpcBppServerMux;
 
 /**
- * <p>An extension of {@link AbstractBilateralConnection} that support gRPC Bilateral Push Protocol, which uses two
- * unary gRPC mux to support incoming and outgoing mux without having to support request/response correlation (i.e.,
- * gRPC handles which response corresponds to which request).</p>
+ * <p>An extension of {@link AbstractBilateralConnection} that support the Bilateral Push Protocol (BPP), which uses
+ * two unary gRPC muxes to support incoming and outgoing messages without having to re-implement request/response
+ * correlation (i.e., Unary gRPC handles which response corresponds to which request).</p>
  * <p/>
  * <p>This protocol is meant to be used between two ILSP nodes, such as two Connectors, or wherever it is possible to
- * establish bidirectional connectivity between two nodes (as an example, this setup would likely not work if one of the
- * participants is a Browser, due to firewall constraints).</p>
+ * establish bidirectional connectivity between two nodes. As an example, this setup would likely not work if one of the
+ * participants is a Browser, due to firewall constraints.</p>
+ *
+ * <p>The following diagram illustrates how this bilateral connection would look like between two nodes:</p>
  *
  * <pre>
  *                 ┌───────────┬───────────┐                 ┌───────────┬───────────┐      ┌─────────┐
@@ -30,23 +34,22 @@
  *                 └───────────┘                                         └───────────┘
  * </pre>
  */
-public class GrpcPushBilateralConnection { //extends
-    //AbstractBilateralConnection<GrinterledgerBppClient, GrinterledgerBppServer> {
+public class BppConnection extends AbstractBilateralConnection<GrpcBppClientMux, GrpcBppServerMux> {
 
-//  /**
-//   * Required-args Constructor.
-//   *
-//   * @param operatorAddress        The {@link InterledgerAddress} of the node operating this MUX.
-//   * @param grinterledgerBppClient The client used to send requests to the gRPC server on the other side of this
-//   *                               org.interledger.bilateral connection.
-//   * @param grinterledgerBppServer The sever used to receive requests from the gRPC server on the other side of this
-//   *                               org.interledger.bilateral connection.
-//   */
-//  public GrpcPushBilateralConnection(
-//      final InterledgerAddress operatorAddress,
-//      final GrinterledgerBppClient grinterledgerBppClient,
-//      final GrinterledgerBppServer grinterledgerBppServer
-//  ) {
-//    super(operatorAddress, grinterledgerBppClient, grinterledgerBppServer);
-//  }
+  /**
+   * Required-args Constructor.
+   *
+   * @param operatorAddress        The {@link InterledgerAddress} of the node operating this MUX.
+   * @param grinterledgerBppClient The client used to send requests to the gRPC server on the other side of this
+   *                               org.interledger.bilateral connection.
+   * @param grinterledgerBppServer The sever used to receive requests from the gRPC server on the other side of this
+   *                               org.interledger.bilateral connection.
+   */
+  public BppConnection(
+      final InterledgerAddress operatorAddress,
+      final GrpcBppClientMux grinterledgerBppClient,
+      final GrpcBppServerMux grinterledgerBppServer
+  ) {
+    super(operatorAddress, grinterledgerBppClient, grinterledgerBppServer);
+  }
 }
Index: ilp-plugin-grpc/src/test/java/org/interledger/plugin/mux/grpc/GrpcIOStreamUtilsTimingTest.java
===================================================================
--- ilp-plugin-grpc/src/test/java/org/interledger/plugin/mux/grpc/GrpcIOStreamUtilsTimingTest.java	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
+++ ilp-plugin-bpp-grpc/src/test/java/org/interledger/plugin/lpiv2/bpp/grpc/connection/mux/GrpcIOStreamUtilsTimingTest.java	(date 1545322353000)
@@ -1,14 +1,13 @@
-package org.interledger.plugin.mux.grpc;
+package org.interledger.plugin.lpiv2.bpp.grpc.connection.mux;
 
 
 import static org.interledger.TestArtifacts.CODEC_CONTEXT;
-import static org.interledger.TestArtifacts.FULFILL_PACKET;
 import static org.interledger.TestArtifacts.FULFILL_PACKET_RND;
 import static org.interledger.TestArtifacts.PREPARE_PACKET_RND;
-import static org.interledger.TestArtifacts.REJECT_PACKET;
 import static org.interledger.TestArtifacts.REJECT_PACKET_RND;
 
 import org.interledger.core.InterledgerPacket;
+import org.interledger.plugin.lpiv2.bpp.grpc.connection.mux.GrpcIOStreamUtils;
 
 import com.google.protobuf.ByteString;
 import org.junit.FixMethodOrder;
Index: ilp-plugin-connections/src/main/java/org/interledger/plugin/connections/settings/BilateralConnectionSettings.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ilp-plugin-connections/src/main/java/org/interledger/plugin/connections/settings/BilateralConnectionSettings.java	(date 1546447243000)
+++ ilp-plugin-connections/src/main/java/org/interledger/plugin/connections/settings/BilateralConnectionSettings.java	(date 1546447243000)
@@ -0,0 +1,50 @@
+package org.interledger.plugin.connections.settings;
+
+import org.interledger.core.InterledgerAddress;
+import org.interledger.plugin.connections.BilateralConnection;
+import org.interledger.plugin.connections.BilateralConnectionType;
+
+import org.immutables.value.Value.Immutable;
+
+import java.util.Map;
+
+/**
+ * Configuration information relating to a {@link BilateralConnection}.
+ */
+public interface BilateralConnectionSettings {
+
+  /**
+   * The type of this ledger plugin.
+   */
+  BilateralConnectionType getBilateralConnectionType();
+
+  /**
+   * Accessor for the {@link InterledgerAddress} of the operator of this mux.
+   *
+   * @return An instance of {@link InterledgerAddress}.
+   */
+  InterledgerAddress getOperatorAddress();
+
+  /**
+   * The {@link InterledgerAddress} of the remote node that this bilateral connection is connecting to.
+   *
+   * @return An instance of {@link InterledgerAddress}.
+   */
+  InterledgerAddress getRemoteAddress();
+
+  /**
+   * A plaintext description of this connection.
+   */
+  String getDescription();
+
+  /**
+   * Additional, custom settings that any plugin can define.
+   */
+  Map<String, Object> getCustomSettings();
+
+  @Immutable
+  abstract class AbstractBilateralConnectionSettings implements BilateralConnectionSettings {
+
+  }
+
+}
Index: ilp-plugin-connections/src/main/java/org/interledger/plugin/connections/BilateralConnectionSettings.java
===================================================================
--- ilp-plugin-connections/src/main/java/org/interledger/plugin/connections/BilateralConnectionSettings.java	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
+++ ilp-plugin-connections/src/main/java/org/interledger/plugin/connections/mux/MuxSettings.java	(date 1545323195000)
@@ -1,27 +1,14 @@
-package org.interledger.plugin.connections;
-
-import org.immutables.value.Value.Immutable;
+package org.interledger.plugin.connections.mux;
 
 import java.util.Map;
 
 /**
- * Configuration information relating to a {@link BilateralConnection}.
+ * Configuration information relating to a Mux.
  */
-public interface BilateralConnectionSettings {
-
-  /**
-   * The type of this ledger plugin.
-   */
-  BilateralConnectionType getBilateralConnectionType();
+public interface MuxSettings {
 
   /**
    * Additional, custom settings that any plugin can define.
    */
   Map<String, Object> getCustomSettings();
-
-  @Immutable
-  abstract class AbstractBilateralConnectionSettings implements BilateralConnectionSettings {
-
-  }
-
 }
Index: ilp-plugin-core/pom.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ilp-plugin-core/pom.xml	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
+++ ilp-plugin-core/pom.xml	(date 1545318048000)
@@ -12,7 +12,7 @@
   <artifactId>ilp-plugin-core</artifactId>
 
   <name>ILP Plugin Core</name>
-  <description>Java implementation of a ILP Plugin Core Interface</description>
+  <description>Java implementation of the ILP Plugin v2 Core Interface</description>
 
   <dependencies>
 
Index: ilp-plugin-connections/src/main/java/org/interledger/plugin/connections/PluginConnectionManager.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ilp-plugin-connections/src/main/java/org/interledger/plugin/connections/PluginConnectionManager.java	(date 1546461494000)
+++ ilp-plugin-connections/src/main/java/org/interledger/plugin/connections/PluginConnectionManager.java	(date 1546461494000)
@@ -0,0 +1,22 @@
+package org.interledger.plugin.connections;
+
+import org.interledger.core.InterledgerAddress;
+import org.interledger.plugin.lpiv2.Plugin;
+
+import java.util.Optional;
+
+/**
+ * Tracks multiple plugins over a single network transport.
+ */
+public interface PluginConnectionManager {
+
+  /**
+   * Accessor for an optionally-present Plugin that support the specified account address.
+   *
+   * @param accountAddress
+   *
+   * @return An optionally-present {@link Plugin}.
+   */
+  Optional<Plugin<?>> getPlugin(InterledgerAddress accountAddress);
+
+}
Index: ilp-plugin-btp-springws/src/main/java/org/interledger/plugin/lpiv2/btp2/spring/connection/AbstractBtpConnection.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ilp-plugin-btp-springws/src/main/java/org/interledger/plugin/lpiv2/btp2/spring/connection/AbstractBtpConnection.java	(date 1546458517000)
+++ ilp-plugin-btp-springws/src/main/java/org/interledger/plugin/lpiv2/btp2/spring/connection/AbstractBtpConnection.java	(date 1546458517000)
@@ -0,0 +1,628 @@
+package org.interledger.plugin.lpiv2.btp2.spring.connection;
+
+import static java.util.concurrent.CompletableFuture.anyOf;
+import static org.interledger.plugin.lpiv2.btp2.subprotocols.BtpSubProtocolHandlerRegistry.BTP_SUB_PROTOCOL_AUTH;
+import static org.interledger.plugin.lpiv2.btp2.subprotocols.BtpSubProtocolHandlerRegistry.BTP_SUB_PROTOCOL_AUTH_TOKEN;
+import static org.interledger.plugin.lpiv2.btp2.subprotocols.BtpSubProtocolHandlerRegistry.BTP_SUB_PROTOCOL_AUTH_USERNAME;
+
+import org.interledger.btp.BtpError;
+import org.interledger.btp.BtpErrorCode;
+import org.interledger.btp.BtpMessage;
+import org.interledger.btp.BtpPacket;
+import org.interledger.btp.BtpPacketMapper;
+import org.interledger.btp.BtpResponse;
+import org.interledger.btp.BtpResponsePacket;
+import org.interledger.btp.BtpRuntimeException;
+import org.interledger.btp.BtpSession;
+import org.interledger.btp.BtpSessionCredentials;
+import org.interledger.btp.BtpSubProtocol;
+import org.interledger.btp.BtpSubProtocol.ContentType;
+import org.interledger.btp.BtpSubProtocols;
+import org.interledger.btp.BtpTransfer;
+import org.interledger.plugin.connections.AbstractBilateralConnection;
+import org.interledger.plugin.connections.BilateralConnection;
+import org.interledger.plugin.connections.PluginFactory;
+import org.interledger.plugin.connections.settings.BilateralConnectionSettings;
+import org.interledger.plugin.lpiv2.btp2.BtpReceiver;
+import org.interledger.plugin.lpiv2.btp2.BtpSender;
+import org.interledger.plugin.lpiv2.btp2.spring.BtpSessionUtils;
+import org.interledger.plugin.lpiv2.btp2.spring.converters.BinaryMessageToBtpPacketConverter;
+import org.interledger.plugin.lpiv2.btp2.spring.converters.BtpConversionException;
+import org.interledger.plugin.lpiv2.btp2.spring.converters.BtpPacketToBinaryMessageConverter;
+import org.interledger.plugin.lpiv2.btp2.subprotocols.AbstractBtpSubProtocolHandler;
+import org.interledger.plugin.lpiv2.btp2.subprotocols.BtpSubProtocolHandlerRegistry;
+
+import com.google.common.collect.Maps;
+import org.springframework.web.socket.BinaryMessage;
+import org.springframework.web.socket.WebSocketMessage;
+import org.springframework.web.socket.WebSocketSession;
+
+import java.io.IOException;
+import java.nio.charset.Charset;
+import java.nio.charset.StandardCharsets;
+import java.security.SecureRandom;
+import java.time.Instant;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Optional;
+import java.util.Random;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.CompletionException;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.locks.LockSupport;
+
+/**
+ * A {@link BilateralConnection} that uses vanilla BTP specified in IL-RFC-23, meaning that this implementation only
+ * supports a single account per Websocket connection (i.e., only the `auth_token` is considered when accepting an
+ * incoming connection, thus limiting this implementation to a single Account).
+ */
+public abstract class AbstractBtpConnection<CS extends BilateralConnectionSettings>
+    extends AbstractBilateralConnection<CS> implements BtpSender, BtpReceiver {
+
+  protected final BinaryMessageToBtpPacketConverter binaryMessageToBtpPacketConverter;
+  protected final BtpPacketToBinaryMessageConverter btpPacketToBinaryMessageConverter;
+
+  // TODO: Use WeakHashMap?
+  // When the client sends a request out to a peer, it will wait for an async response from that peer. When that
+  // response comes back, it will be combined with a pending response.
+  protected final Map<Long, CompletableFuture<BtpResponsePacket>> pendingResponses;
+
+  private final BtpSubProtocolHandlerRegistry btpSubProtocolHandlerRegistry;
+
+  private final Random random;
+
+  /**
+   * Required-args Constructor.
+   *
+   * @param connectionSettings A {@link BilateralConnectionSettings}.
+   */
+  public AbstractBtpConnection(
+      final CS connectionSettings,
+      final PluginFactory pluginFactory,
+      final BinaryMessageToBtpPacketConverter binaryMessageToBtpPacketConverter,
+      final BtpPacketToBinaryMessageConverter btpPacketToBinaryMessageConverter,
+      final BtpSubProtocolHandlerRegistry btpSubProtocolHandlerRegistry
+  ) {
+    super(connectionSettings, pluginFactory);
+
+    this.binaryMessageToBtpPacketConverter = Objects.requireNonNull(binaryMessageToBtpPacketConverter);
+    this.btpPacketToBinaryMessageConverter = Objects.requireNonNull(btpPacketToBinaryMessageConverter);
+    this.btpSubProtocolHandlerRegistry = Objects.requireNonNull(btpSubProtocolHandlerRegistry);
+
+    this.pendingResponses = Maps.newConcurrentMap();
+    this.random = new SecureRandom();
+  }
+
+//  ////////////////////
+//  // BtpSender Methods
+//  ////////////////////
+//
+//  /**
+//   * Converts {@code btpMessage} into the proper binary format and then sends the payload out over the websocket,
+//   * waiting for a response.
+//   */
+//  @Override
+//  public CompletableFuture<BtpResponsePacket> sendBtpMessage(final BtpMessage btpMessage) {
+//    Objects.requireNonNull(btpMessage);
+//
+//    // Translate the btpMessage to a BinaryMessage, and send out using the WebSocketSession.
+//    return this.webSocketSession
+//        .map(wss -> {
+//          final BinaryMessage binaryMessage = this.btpPacketToBinaryMessageConverter.convert(btpMessage);
+//          final long requestId = nextRequestId();
+//          return this.sendMessageWithPendingRepsonse(requestId, wss, binaryMessage)
+//              .handle((response, error) -> {
+//                if (error != null) {
+//                  // the pending response timed out or otherwise had a problem...
+//                  throw new RuntimeException(error.getMessage(), error);
+//                } else {
+//                  // Might be an error or a response`
+//                  return response;
+//                }
+//              });
+//        }).orElseThrow(() -> new RuntimeException("No WebSocket session!"));
+//  }
+//
+//  @Override
+//  public CompletableFuture<BtpResponsePacket> sendBtpTransfer(BtpTransfer btpTransfer) {
+//    throw new RuntimeException("FIXME!");
+//    //return CompletableFuture.completedFuture(null);
+//  }
+
+  //////////////////////
+  // BtpReceiver Methods
+  //////////////////////
+
+  /**
+   * Handle an incoming BTP Packet. The payload may be a BTP Request type, or it may be a BTP response type, so
+   * implementations must handle all BTP packet types approporiately.
+   *
+   * @param incomingBtpPacket A {@link BtpPacket} sent from the bilateral BTP peer.
+   *
+   * @return An optionally-present response of type {@link BtpResponsePacket}.
+   */
+  @Override
+  public Optional<BtpResponsePacket> handleBtpPacket(final BtpSession btpSession, final BtpPacket incomingBtpPacket) {
+    Objects.requireNonNull(btpSession, "BtpSession is required!");
+    Objects.requireNonNull(incomingBtpPacket);
+
+    try {
+      // If incomingBtpMessage is a BTPResponse, we need to connect it to a pending sendData. If this is a
+      // BtpMessage, we can simply handle it...
+      return new BtpPacketMapper<Optional<BtpResponsePacket>>() {
+        @Override
+        protected Optional<BtpResponsePacket> mapBtpMessage(final BtpMessage incomingBtpMessage) {
+          Objects.requireNonNull(incomingBtpMessage);
+          logger.trace("incomingBtpMessage: {}", incomingBtpMessage);
+
+          // A WebSocketSession always has a BtpSession, but it may not be authenticated...
+          final BtpResponse btpResponse = handleIncomingBtpMessage(btpSession, incomingBtpMessage);
+          return Optional.of(btpResponse);
+        }
+
+        @Override
+        protected Optional<BtpResponsePacket> mapBtpTransfer(final BtpTransfer incomingBtpTransfer) {
+          Objects.requireNonNull(incomingBtpTransfer);
+          logger.trace("incomingBtpMessage: {}", incomingBtpTransfer);
+          throw new RuntimeException("Not yet implemented!");
+        }
+
+        @Override
+        protected Optional<BtpResponsePacket> mapBtpError(BtpError incomingBtpError) {
+          Objects.requireNonNull(incomingBtpError);
+          logger.error(
+              "Incoming BtpError from `{}` with message `{}`",
+              btpSession.getBtpSessionCredentials().get(), new String(incomingBtpError.getErrorData())
+          );
+
+          // The incoming message was a BtpError, so don't return a response to the peer.
+          return Optional.empty();
+        }
+
+        @Override
+        protected Optional<BtpResponsePacket> mapBtpResponse(final BtpResponse incomingBtpResponse) {
+          Objects.requireNonNull(incomingBtpResponse);
+
+          logger.trace("IncomingBtpResponse: {} ", incomingBtpResponse);
+
+          // Generally, BTP always returns a response to the caller, even under error conditions. There are two
+          // exceptions, however, listed as "tricky cases" in the BTP specification:
+          //
+          // 1. An unexpected BTP packet is received
+          // 2. An unreadable BTP packet is received
+          //
+          // If the packet was unreadable, then this method will have never been called, so we can ignore this
+          // case here. However, if an unexpected packet is encountered, we need to emit this error, but then return
+          // null to the caller of this method so that no response is returned to the BTP peer.
+
+          // TODO: If auth fails on the server, we might need to send a response from the join....otherwise, just
+          // return Optional.empty();
+          if (joinPendingResponse(incomingBtpResponse)) {
+            return Optional.empty();
+          } else {
+            return Optional.empty();
+          }
+        }
+      }.map(incomingBtpPacket);
+    } catch (BtpRuntimeException e) {
+      logger.error(e.getMessage(), e);
+      // If anything throws a BTP Exception, then return a BTP Error on the channel...
+      final BtpError btpError = e.toBtpError(incomingBtpPacket.getRequestId());
+      return Optional.of(btpError);
+    }
+  }
+
+  /**
+   * Handle an incoming BinaryMessage from a Websocket by converting it into a {@link BtpMessage} and forwarding it to
+   * the appropriate receiver (i.e., plugin).
+   *
+   * @param webSocketSession
+   * @param incomingBinaryMessage
+   *
+   * @return A {@link BinaryMessage} that can immediately be returned to the caller (this response will contain
+   *     everything required to be eligible as a BTP response), or nothing if the response is {@link Optional#empty()}.
+   */
+  public void handleBinaryMessage(
+      final WebSocketSession webSocketSession, final BinaryMessage incomingBinaryMessage
+  ) {
+    Objects.requireNonNull(webSocketSession);
+    Objects.requireNonNull(incomingBinaryMessage);
+
+    // The first message in a WebSocketSession MUST be the auth protocol. Thus, as long as the BtpSession is not
+    // authenticated, then we should attempt to perform the auth sub_protocol.
+    final BtpSession btpSession = BtpSessionUtils.getBtpSessionFromWebSocketSession(webSocketSession)
+        .orElseThrow(() -> new RuntimeException("BtpSession is required!"));
+
+    final Optional<BinaryMessage> response;
+    if (!btpSession.isAuthenticated()) {
+      // Do Auth. This will merely initialize the credentials into the BTPSession and return an Ack.
+      response = this.handleBinaryAuthMessage(webSocketSession, incomingBinaryMessage)
+          .map(foo -> btpPacketToBinaryMessageConverter.convert(foo));
+//
+//       This functionality needs to be different between client and server...
+//      client should never echo responses back to the server, so response MUSt always be empty.
+      // A client response will
+//      if(btpResponse.get().getSubProtocols().size() == 0){
+//
+//      }
+
+      //On the client, we need to rejoin the pending response...
+
+      // On the client, a pendingResponse will be waiting to complete the auth properly....we need to join the empty response to it.
+      //.map(btpResponse -> this.joinPendingResponse(btpResponse))
+      //.map($ -> Optional.<BinaryMessage>empty())
+      //.orElse(Optional.empty());
+    } else {
+      // If the auth subprotocol completes successfully, then we'll end up here with an authenticated Websocket Session.
+      try {
+        // If there's a problem de-serializing the BtpPacket from the BinaryMessage, then close the connection and
+        // return empty. This is one of the "tricky cases" as defined in the BTP spec where we don't want to get into
+        // an infinite loop.
+        final BtpPacket incomingBtpPacket = this.binaryMessageToBtpPacketConverter.convert(incomingBinaryMessage);
+        final Optional<BtpResponsePacket> btpResponse = this.handleBtpPacket(btpSession, incomingBtpPacket);
+        if (btpResponse.isPresent()) {
+          response = Optional.of(btpPacketToBinaryMessageConverter.convert(btpResponse.get()));
+        } else {
+          response = Optional.empty();
+        }
+      } catch (BtpConversionException btpConversionException) {
+        logger.error("Unable to deserialize BtpPacket from incomingBinaryMessage: {}", btpConversionException);
+        this.disconnect().join();
+        return;
+      }
+    }
+
+    // Return the response to the caller, if there is a response.
+    response.ifPresent($ -> {
+      try {
+        // TODO: What does the other side of the WebSocket see if there's an exception here?
+        webSocketSession.sendMessage($);
+      } catch (IOException e) {
+        throw new RuntimeException(e);
+      }
+    });
+
+  }
+
+  /**
+   * Handle an incoming BinaryMessage from a Websocket, assuming it's a BTP Auth message.
+   *
+   * @param webSocketSession
+   * @param incomingBinaryMessage
+   *
+   * @return A {@link BinaryMessage} that can immediately be returned to the caller (this response will contain
+   *     everything required to be eligible as a BTP response), or nothing if the response is {@link Optional#empty()}.
+   */
+  public Optional<BtpResponse> handleBinaryAuthMessage(
+      final WebSocketSession webSocketSession, final BinaryMessage incomingBinaryMessage
+  ) {
+    Objects.requireNonNull(webSocketSession);
+    Objects.requireNonNull(incomingBinaryMessage);
+
+    final AbstractBtpSubProtocolHandler btpAuthSubprotocolHandler = this.btpSubProtocolHandlerRegistry
+        .getHandler(BTP_SUB_PROTOCOL_AUTH, ContentType.MIME_APPLICATION_OCTET_STREAM)
+        .orElseThrow(() -> new RuntimeException("No Auth Subprotocol Handler registered!"));
+
+    // If there's a problem de-serializing the BtpPacket from the BinaryMessage, then close the connection and
+    // return empty. This is one of the "tricky cases" as defined in the BTP spec where we don't want to get into
+    // an infinite loop.
+    final BtpPacket incomingBtpPacket;
+    try {
+      incomingBtpPacket = this.binaryMessageToBtpPacketConverter.convert(incomingBinaryMessage);
+      final BtpSession btpSession = BtpSessionUtils.getBtpSessionFromWebSocketSession(webSocketSession)
+          .orElseThrow(() -> new RuntimeException("BtpSession is required!"));
+      return btpAuthSubprotocolHandler.handleSubprotocolMessage(btpSession, incomingBtpPacket)
+          .thenApply(btpSubProtocol -> btpSubProtocol
+              .map($ -> {
+                // If there's no exception, then reaching here means the btp_auth SubProtocol succeeded.
+                // Ack the response, but only if
+                final BtpSubProtocols responses = new BtpSubProtocols();
+                responses.add($);
+                final BtpResponse response = BtpResponse.builder()
+                    .requestId(incomingBtpPacket.getRequestId())
+                    .subProtocols(responses)
+                    .build();
+                return response;
+              })
+              //.map(btpPacketToBinaryMessageConverter::convert)
+              .map(Optional::of)
+              // If there is no sub-protocol to return, then return empty so no response is sent back over the connection.
+              .orElse(Optional.empty())
+          )
+          .join();
+    } catch (BtpConversionException btpConversionException) {
+      logger.error(btpConversionException.getMessage(), btpConversionException);
+      throw btpConversionException;
+    }
+  }
+
+  /**
+   * <p>Handles an incoming {@link BtpMessage} by delegating it to a registered handler.</p>
+   *
+   * <p>There are also a couple of tricky cases to handle:</p>
+   *
+   * <ul>
+   * <li>If an unexpected BTP packet is received, no response should be sent. An unexpected BTP packet is a
+   * response for which a request was not sent, or a response for a request which has already been responded to.</li>
+   * <li>If an unreadable BTP packet is received, no response should be sent. An unreadable BTP packet is one which
+   * is structurally invalid, i.e. terminates before length prefixes dictate or contains illegal characters.</li>
+   * </ul>
+   *
+   * <p>Incoming BTP messages can be either requests or responses, so sub-classes should be careful to handle both
+   * types of message, especially when bridging to synchronous API contracts, where it may become confusing as to
+   * whether an incoming message corresponds to the input our output portion of a particular synchronous method.</p>
+   *
+   * @param btpSession
+   * @param incomingBtpMessage
+   *
+   * @return
+   */
+  // TODO: Use future?
+  public BtpResponse handleIncomingBtpMessage(final BtpSession btpSession, final BtpMessage incomingBtpMessage)
+      throws BtpRuntimeException {
+
+    Objects.requireNonNull(btpSession);
+    Objects.requireNonNull(incomingBtpMessage);
+
+    try {
+      final BtpSubProtocols responses = new BtpSubProtocols();
+
+      // Only the primary sub-protocol should be handled. The secondary sub-protocols should not request additional
+      // actions or information. If multiple actions or pieces of information are required, multiple separate Messages
+      // should be sent. The secondary sub-protocols should only modify the request made in the primary sub-protocol, or
+      // provide additional contextual data which can be consumed in a readonly way (without affecting the result).
+      final BtpSubProtocol primarySubprotocol = incomingBtpMessage.getPrimarySubProtocol();
+      final AbstractBtpSubProtocolHandler handler =
+          this.btpSubProtocolHandlerRegistry
+              .getHandler(primarySubprotocol.getProtocolName(), primarySubprotocol.getContentType())
+              .orElseThrow(() -> new BtpRuntimeException(
+                  BtpErrorCode.F00_NotAcceptedError,
+                  String.format("No BTP Handler registered for BTP SubProtocol: %s",
+                      primarySubprotocol.getProtocolName()))
+              );
+
+      final CompletableFuture<Optional<BtpSubProtocol>> btpSubProtocolResponse = handler
+          .handleSubprotocolMessage(btpSession, incomingBtpMessage);
+
+      // Add the response, but only if it's present.
+      btpSubProtocolResponse.get().ifPresent(responses::add);
+
+      // Now that there's a proper response, send it back to the connected client...
+      return BtpResponse.builder()
+          .requestId(incomingBtpMessage.getRequestId())
+          .subProtocols(responses)
+          .build();
+    } catch (Exception e) {
+      throw new BtpRuntimeException(BtpErrorCode.T00_UnreachableError, e.getMessage(), e);
+    }
+  }
+
+  /**
+   * Returns the next random request id using a PRNG.
+   */
+  protected long nextRequestId() {
+    return Math.abs(random.nextInt());
+  }
+
+  /**
+   * An authentication message must have as its primary <tt>protocolData</tt> entry must have the name of 'auth',
+   * content type <tt>MIME_APPLICATION_OCTET_STREAM</tt>, and empty data, and among the secondary entries, there MUST be
+   * a UTF-8 'auth_token' entry.
+   *
+   * @return
+   */
+  public BtpMessage constructAuthMessage(
+      final long requestId, final BtpSessionCredentials btpSessionCredentials
+  ) {
+    Objects.requireNonNull(btpSessionCredentials);
+
+    final BtpSubProtocol authSubProtocol = BtpSubProtocol.builder()
+        .protocolName(BTP_SUB_PROTOCOL_AUTH)
+        .contentType(BtpSubProtocol.ContentType.MIME_APPLICATION_OCTET_STREAM)
+        .build();
+    final BtpSubProtocols btpSubProtocols = BtpSubProtocols.fromPrimarySubProtocol(authSubProtocol);
+
+    // In situations where no authentication is needed, the 'auth_token' data can be set to the empty string,
+    // but it cannot be omitted.
+    final BtpSubProtocol authTokenSubprotocol = BtpSubProtocol.builder()
+        .protocolName(BTP_SUB_PROTOCOL_AUTH_TOKEN)
+        .contentType(BtpSubProtocol.ContentType.MIME_APPLICATION_OCTET_STREAM)
+        .data(btpSessionCredentials.getAuthToken().getBytes(StandardCharsets.UTF_8))
+        .build();
+    btpSubProtocols.add(authTokenSubprotocol);
+
+    btpSessionCredentials.getAuthUsername().ifPresent($ -> {
+      final BtpSubProtocol authUsernameSubprotocol = BtpSubProtocol.builder()
+          .protocolName(BTP_SUB_PROTOCOL_AUTH_USERNAME)
+          .contentType(BtpSubProtocol.ContentType.MIME_APPLICATION_OCTET_STREAM)
+          .data($.getBytes(StandardCharsets.UTF_8))
+          .build();
+      btpSubProtocols.add(authUsernameSubprotocol);
+    });
+
+    return BtpMessage.builder()
+        .requestId(requestId)
+        .subProtocols(btpSubProtocols)
+        .build();
+  }
+
+  protected CompletableFuture<BtpResponsePacket> sendMessageWithPendingRepsonse(
+      final long requestId, final WebSocketSession webSocketSession, final WebSocketMessage webSocketMessage
+  ) {
+    Objects.requireNonNull(webSocketMessage);
+    try {
+      // Register the pending response first, just in-cae the Websocket returns faster than this method can complete.
+      final CompletableFuture<BtpResponsePacket> pendingResponse = registerPendingResponse(requestId);
+      webSocketSession.sendMessage(webSocketMessage);
+      return pendingResponse;
+    } catch (IOException e) {
+      try {
+        this.disconnect().get();
+      } catch (Exception e1) {
+        throw new RuntimeException(e1);
+      }
+      throw new RuntimeException(e);
+    }
+  }
+
+  /**
+   * <p>Register and return a "pending response", mapping it to the supplied {@code requestId}. This mechanism works by
+   * returning a completed future to a caller, who then waits for the future to be completed. The receiver processes the
+   * request, and eventually returns a response by completing the appropriate <tt>pending respsonse</tt>.</p>
+   *
+   * <p>The following diagram illustrates this flow:</p>
+   *
+   * <pre>
+   * ┌──────────┐                                              ┌──────────┐
+   * │          │────────────Request (Object)─────────────────▷│          │
+   * │          │                                              │          │
+   * │          │             Response (Uncompleted            │          │
+   * │          │◁─────────────CompletableFuture)───△──────────┤          │
+   * │          │                                   │          │          │
+   * │          │                                   │          │          │
+   * │          │                                   │          │          │
+   * │          │                                   │          │          │
+   * │  Sender  │                                   │ Complete │ Receiver │
+   * │          │                                   └or Timeout┤          │
+   * │          │                                              │          │
+   * │          │                                              │          │
+   * │          │                                              │          │
+   * │          │                                              │          │
+   * │          │                                              │          │
+   * │          │                                              │          │
+   * │          │                                              │          │
+   * └──────────┘                                              └──────────┘
+   * </pre>
+   *
+   * @param requestId The unique identifier of the request that should receive a response, but only once that response
+   *                  can be returned.
+   *
+   * @return
+   */
+  protected final CompletableFuture<BtpResponsePacket> registerPendingResponse(final long requestId) {
+
+    // TODO: Use WeakReferences here to prevent memory leaks...
+
+    // This response will expire in the alotted time (see below). This response is immediately returned to the caller,
+    // but nothing happens until this CF expires, or the CF is completed from a different thread (by passing-in an
+    // incoming message, which is actually a response).
+    final CompletableFuture<BtpResponsePacket> pendingResponse = CompletableFuture.supplyAsync(
+        () -> {
+          // TODO: Configure this amount as a property.
+          // TODO: Move back to seconds and set a default of 15.
+          LockSupport.parkNanos(TimeUnit.MINUTES.toNanos(15));
+          throw new BtpRuntimeException(BtpErrorCode.F00_NotAcceptedError, "BTP SendData operation timed-out!");
+        }
+    );
+
+    if (this.pendingResponses.putIfAbsent(requestId, pendingResponse) == null) {
+      return pendingResponse;
+    } else {
+      // TODO: Just log an error and ignore?
+      throw new RuntimeException("Encountered BTP message twice!");
+    }
+  }
+
+
+  /**
+   * Join a response from a remote server to a pending response that has been previously returned to a caller who is
+   * waiting for it to be completed or to timeout.
+   *
+   * @param incomingBtpResponse A {@link BtpResponse} from a remote server that should be used to complete a pending
+   *                            response future. Note that this value is never <tt>Optional</tt> because the system
+   *                            either gets a response from a remote BTP connection, or else the pending future
+   *                            times-out.
+   *
+   * @return {@code true} if this invocation caused a pending response to transition to a completed state, else {@code
+   *     false}.
+   */
+  protected boolean joinPendingResponse(final BtpResponse incomingBtpResponse) {
+    Objects.requireNonNull(incomingBtpResponse,
+        "incomingBtpResponse must not be null in order to correlate to a pending response identifier!");
+
+    final CompletableFuture<BtpResponsePacket> pendingResponse = pendingResponses
+        .get(incomingBtpResponse.getRequestId());
+
+    // If there's no pending response, then return empty, and log an error.
+    if (pendingResponse == null) {
+      logger.error("No PendingResponse available to connect to incomingBtpResponse: {}", incomingBtpResponse);
+      return false;
+    } else {
+      // Always connect the `responseToReturn` to a pendingResponse, which has been previously returned to a caller
+      // who is waiting for it to be completed or to timeout. If a pendingResponse exists (getting here implies that it
+      // does exist), then we need to complete the pendingResponse with the value found in `responseToReturn`.
+
+      try {
+        // TODO: Consider acceptEither instead
+        //  (http://www.deadcoderising.com/java8-writing-asynchronous-code-with-completablefuture/)
+
+        // First, call `anyOf` on the pendingResponse and a new CF. If `pendingResponse` has timed-out, it will trigger
+        // this future to return with an error. Otherwise, if `pendingResponse` has not timed-out, then the new CF will
+        // be returned. Note that there is a race-condition here that if both CF's are completed, it's ambiguous which
+        // one will be returned. However, this should rarely occur, and either result is tolerable.
+        anyOf(pendingResponse, CompletableFuture.completedFuture(incomingBtpResponse))
+            .handle((response, error) -> {
+              if (error != null) {
+                logger.error(error.getMessage(), error);
+//               if (error instanceof BtpRuntimeException) {
+//                 final BtpRuntimeException btpRuntimeException = (BtpRuntimeException) error;
+//                 final BtpError btpError = constructBtpError(
+//                     incomingBtpPacket.getRequestId(), btpRuntimeException.getMessage(),
+//                     btpRuntimeException.getTriggeredAt(), btpRuntimeException.getCode()
+//                 );
+//                 return Optional.of(btpPacketToBinaryMessageConverter.convert(btpError));
+//               } else {
+//                 // There was an error processing, so return a BtpError response back to the waiting caller.
+//                 final BtpError btpError = constructBtpError(
+//                     incomingBtpPacket.getRequestId(), error.getMessage(), Instant.now(),
+//                     BtpErrorCode.T00_UnreachableError
+//                 );
+//                 return Optional.of(btpPacketToBinaryMessageConverter.convert(btpError));
+//               }
+                return false;
+              } else {
+                // Pipe the incomingBtpResponse into the pending response so that whatever caller is waiting for it will
+                // receive it.
+                return pendingResponse.complete(incomingBtpResponse);
+              }
+            })
+            // Join is preferable here as opposed to get(timeout) because the anyOf (above) combines a timeout future,
+            // so no need to timeout again...
+            .join();
+
+        return true;
+      } catch (CompletionException e) {
+        if (e.getCause() instanceof BtpRuntimeException) {
+          throw (BtpRuntimeException) e.getCause();
+        } else {
+          throw new RuntimeException(e);
+        }
+      }
+    }
+  }
+
+  protected final BtpError constructBtpError(final long requestId, final String errorData,
+      final Instant triggeredAt, final BtpErrorCode btpErrorCode) {
+    Objects.requireNonNull(errorData);
+
+    // Respond with a BTP Error on the websocket session.
+    return BtpError.builder()
+        .requestId(requestId)
+        .triggeredAt(triggeredAt)
+        .errorCode(btpErrorCode)
+        .errorData(errorData.getBytes(Charset.forName("UTF-8")))
+        .build();
+  }
+
+  public BtpSubProtocolHandlerRegistry getBtpSubProtocolHandlerRegistry() {
+    return btpSubProtocolHandlerRegistry;
+  }
+
+  public BinaryMessageToBtpPacketConverter getBinaryMessageToBtpPacketConverter() {
+    return binaryMessageToBtpPacketConverter;
+  }
+
+  public BtpPacketToBinaryMessageConverter getBtpPacketToBinaryMessageConverter() {
+    return btpPacketToBinaryMessageConverter;
+  }
+}
Index: ilp-plugin-btp-springws/src/main/java/org/interledger/plugin/lpiv2/btp2/spring/connection/SingleAccountConnectionSettings.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ilp-plugin-btp-springws/src/main/java/org/interledger/plugin/lpiv2/btp2/spring/connection/SingleAccountConnectionSettings.java	(date 1546450645000)
+++ ilp-plugin-btp-springws/src/main/java/org/interledger/plugin/lpiv2/btp2/spring/connection/SingleAccountConnectionSettings.java	(date 1546450645000)
@@ -0,0 +1,28 @@
+package org.interledger.plugin.lpiv2.btp2.spring.connection;
+
+import org.interledger.core.InterledgerAddress;
+import org.interledger.plugin.connections.settings.BilateralConnectionSettings;
+import org.interledger.plugin.lpiv2.PluginSettings;
+
+/**
+ * An extension of {@link BilateralConnectionSettings} that supports only a single account.
+ */
+public interface SingleAccountConnectionSettings extends BilateralConnectionSettings {
+
+  /**
+   * Accessor for the account supported by this connection.
+   *
+   * @return An {@link InterledgerAddress}.
+   */
+  InterledgerAddress getAccountAddress();
+
+  /**
+   * The BTP `auth_token` value that this connection requires.
+   *
+   * @deprecated This value will go away in a future release, and will be replaced with a BTP authentication provider.
+   */
+  @Deprecated
+  String getAuthToken();
+
+  PluginSettings getPluginSettings();
+}
Index: ilp-plugin-btp/src/main/java/org/interledger/plugin/lpiv2/btp2/BtpResponsePacketMapper.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ilp-plugin-btp/src/main/java/org/interledger/plugin/lpiv2/btp2/BtpResponsePacketMapper.java	(date 1546455284000)
+++ ilp-plugin-btp/src/main/java/org/interledger/plugin/lpiv2/btp2/BtpResponsePacketMapper.java	(date 1546455284000)
@@ -0,0 +1,47 @@
+package org.interledger.plugin.lpiv2.btp2;
+
+import org.interledger.btp.BtpError;
+import org.interledger.btp.BtpPacket;
+import org.interledger.btp.BtpResponse;
+import org.interledger.core.InterledgerResponsePacket;
+
+import java.util.Objects;
+
+/**
+ * A helper class for mapping polymorphic BTP responses to their proper type.
+ */
+public abstract class BtpResponsePacketMapper<T> {
+
+  /**
+   * Handle the supplied {@code btpResponse} in a type-safe manner.
+   *
+   * @param btpResponse The generic {@link InterledgerResponsePacket} to be mapped in a type-safe manner.
+   */
+  public final T map(final BtpPacket btpResponse) {
+    Objects.requireNonNull(btpResponse);
+
+    if (BtpError.class.isAssignableFrom(btpResponse.getClass())) {
+      return handleBtpError((BtpError) btpResponse);
+    } else if (BtpResponse.class.isAssignableFrom(btpResponse.getClass())) {
+      return handleBtpResponse((BtpResponse) btpResponse);
+    } else {
+      throw new RuntimeException(String.format("Unsupported BtpResponse Type: %s", btpResponse.getClass()));
+    }
+
+  }
+
+  /**
+   * Handle the packet as an {@link BtpPacket}.
+   *
+   * @param btpError A {@link BtpError}.
+   */
+  protected abstract T handleBtpError(final BtpError btpError);
+
+  /**
+   * Handle the packet as an {@link BtpPacket}.
+   *
+   * @param btpResponse A {@link BtpResponse}.
+   */
+  protected abstract T handleBtpResponse(final BtpResponse btpResponse);
+
+}
Index: ilp-plugin-btp/src/main/java/org/interledger/plugin/lpiv2/btp2/subprotocols/BtpMultiAuthenticator.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ilp-plugin-btp/src/main/java/org/interledger/plugin/lpiv2/btp2/subprotocols/BtpMultiAuthenticator.java	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
+++ ilp-plugin-btp/src/main/java/org/interledger/plugin/lpiv2/btp2/subprotocols/BtpMultiAuthenticator.java	(date 1545854141000)
@@ -3,6 +3,7 @@
 import org.interledger.core.InterledgerAddress;
 import org.interledger.plugin.lpiv2.btp2.subprotocols.BtpAuthenticator.AlwaysAllowedBtpAuthenticator;
 
+import java.util.Objects;
 import java.util.Optional;
 
 /**
@@ -14,29 +15,44 @@
   /**
    * Return the BTP Authenticator for the specified account.
    *
+   * @param authUsername The `auth_username` supplied as part of the BTP Auth protocol.
+   *
    * @return A {@link BtpAuthenticator}.
    */
-  Optional<BtpAuthenticator> getBtpAuthenticator(InterledgerAddress accountAddress);
-
-  /**
-   * Transform the username into an {@link InterledgerAddress}.
-   *
-   * @return A {@link InterledgerAddress}.
-   */
-  default InterledgerAddress usernameToIlpAddress(String username) {
-    return InterledgerAddress.of("test.alwaysauthenticated").with(username);
-  }
+  Optional<BtpAuthenticator> getBtpAuthenticator(String authUsername);
 
   /**
    * No-op implementation of {@link BtpAuthenticator} that always returns {@code true} to simulate valid BTP messages.
    */
   class AlwaysAllowedBtpMultiAuthenticator implements BtpMultiAuthenticator {
 
+    // An ILP address of this node to root all child accounts under.
+    private final InterledgerAddress nodeIlpAddress;
+
+    public AlwaysAllowedBtpMultiAuthenticator(final InterledgerAddress nodeIlpAddress) {
+      Objects.requireNonNull(nodeIlpAddress);
+      this.nodeIlpAddress = Objects.requireNonNull(nodeIlpAddress);
+    }
+
     @Override
-    public Optional<BtpAuthenticator> getBtpAuthenticator(final InterledgerAddress accountAddress) {
+    public Optional<BtpAuthenticator> getBtpAuthenticator(final String username) {
+      Objects.requireNonNull(username);
+
+      final InterledgerAddress accountAddress = this.usernameToIlpAddress(username);
       return Optional.of(new AlwaysAllowedBtpAuthenticator(accountAddress));
     }
 
-  }
+    /**
+     * Create a child-account for this connector using the supplied username.
+     *
+     * @param username A username source from the `auth_username` via the BTP Auth protocol.
+     *
+     * @return
+     */
+    private InterledgerAddress usernameToIlpAddress(final String username) {
+      Objects.requireNonNull(username);
+      return this.nodeIlpAddress.with(username);
+    }
 
+  }
 }
Index: ilp-plugin-btp/src/main/java/org/interledger/plugin/lpiv2/btp2/AbstractBtpPlugin.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ilp-plugin-btp/src/main/java/org/interledger/plugin/lpiv2/btp2/AbstractBtpPlugin.java	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
+++ ilp-plugin-btp/src/main/java/org/interledger/plugin/lpiv2/btp2/AbstractBtpPlugin.java	(date 1546456178000)
@@ -1,43 +1,10 @@
 package org.interledger.plugin.lpiv2.btp2;
 
-import static org.interledger.btp.BtpSubProtocol.ContentType.MIME_APPLICATION_OCTET_STREAM;
-import static org.interledger.plugin.lpiv2.btp2.subprotocols.BtpSubProtocolHandlerRegistry.BTP_SUB_PROTOCOL_AUTH;
-import static org.interledger.plugin.lpiv2.btp2.subprotocols.BtpSubProtocolHandlerRegistry.BTP_SUB_PROTOCOL_AUTH_TOKEN;
-import static org.interledger.plugin.lpiv2.btp2.subprotocols.BtpSubProtocolHandlerRegistry.BTP_SUB_PROTOCOL_AUTH_USERNAME;
-import static org.interledger.plugin.lpiv2.btp2.subprotocols.BtpSubProtocolHandlerRegistry.BTP_SUB_PROTOCOL_ILP;
-
-import org.interledger.btp.BtpErrorCode;
-import org.interledger.btp.BtpMessage;
-import org.interledger.btp.BtpPacket;
-import org.interledger.btp.BtpResponse;
-import org.interledger.btp.BtpRuntimeException;
-import org.interledger.btp.BtpSession;
-import org.interledger.btp.BtpSubProtocol;
-import org.interledger.btp.BtpSubProtocols;
-import org.interledger.core.InterledgerErrorCode;
-import org.interledger.core.InterledgerFulfillPacket;
-import org.interledger.core.InterledgerPacket;
-import org.interledger.core.InterledgerProtocolException;
-import org.interledger.core.InterledgerRejectPacket;
-import org.interledger.core.InterledgerResponsePacket;
-import org.interledger.encoding.asn.framework.CodecContext;
 import org.interledger.plugin.lpiv2.AbstractPlugin;
-import org.interledger.plugin.lpiv2.Plugin;
-import org.interledger.plugin.lpiv2.btp2.subprotocols.AbstractBtpSubProtocolHandler;
-import org.interledger.plugin.lpiv2.btp2.subprotocols.BtpSubProtocolHandlerRegistry;
-import org.interledger.plugin.lpiv2.btp2.subprotocols.ilp.IlpBtpSubprotocolHandler;
-import org.interledger.plugin.lpiv2.exceptions.DataHandlerAlreadyRegisteredException;
-
-import java.nio.charset.StandardCharsets;
-import java.security.SecureRandom;
-import java.util.Objects;
-import java.util.Optional;
-import java.util.Random;
-import java.util.concurrent.CompletableFuture;
 
 /**
  * <p>An extension of {@link AbstractPlugin} that is capable of representing a data channel with no money involved.
- * This class takes care of most of the work translating between BTP and the ledger plugin interface (LPI), and will
+ * This class takes care of most of the work of translating between BTP and the ledger plugin interface (LPI), and will
  * send BTP messages with no knowledge of the data within, so it can be used for ILP packets. The implementation
  * returned by {@link #getMoneySender()} is a no-op because, by default, there is no system involved in handling money
  * with BTP.</p>
@@ -47,331 +14,330 @@
  * <tt>TRANSFER</tt> call. The second method is {@link #getMoneyHandler()}, which is called
  * on an incoming BTP <tt>TRANSFER</tt> message.</p>
  *
- * <p>
- * BtpSubProtocol
- * </p>
- *
  * <p>The main use of this Plugin, however, is as a building block for plugins that _do_ have an underlying ledger.</p>
  */
-public abstract class AbstractBtpPlugin<T extends BtpPluginSettings> extends AbstractPlugin<T> implements Plugin<T> {
-
-  private final CodecContext ilpCodecContext;
-  private final CodecContext btpCodecContext;
-  private final Random random;
-  private final BtpSubProtocolHandlerRegistry btpSubProtocolHandlerRegistry;
-
-  /**
-   * Required-args Constructor.
-   */
-  public AbstractBtpPlugin(
-      final T pluginSettings,
-      final CodecContext ilpCodecContext,
-      final CodecContext btpCodecContext,
-      final BtpSubProtocolHandlerRegistry btpSubProtocolHandlerRegistry
-  ) {
-    super(pluginSettings);
-    this.ilpCodecContext = Objects.requireNonNull(ilpCodecContext);
-    this.btpCodecContext = Objects.requireNonNull(btpCodecContext);
-    this.btpSubProtocolHandlerRegistry = btpSubProtocolHandlerRegistry;
-    this.random = new SecureRandom();
-
-    // No need to do anything with the data-handler becuase it's overridden below.
-    // Peg the dataSender to this class's implementation so that it always translates to BTP in order to send.
-    super.registerDataSender(this::sendData);
-
-    // No-op because there is no money-handling in default BTP.
-    super.registerMoneyHandler((amount) -> CompletableFuture.completedFuture(null));
-    super.registerMoneySender((amount) -> CompletableFuture.completedFuture(null));
-  }
-
-  /**
-   * <p>Handles an incoming {@link BtpMessage} by delegating it to a registered handler.</p>
-   *
-   * <p>There are also a couple of tricky cases to handle:</p>
-   *
-   * <ul>
-   * <li>If an unexpected BTP packet is received, no response should be sent. An unexpected BTP packet is a
-   * response for which a request was not sent, or a response for a request which has already been responded to.</li>
-   * <li>If an unreadable BTP packet is received, no response should be sent. An unreadable BTP packet is one which
-   * is structurally invalid, i.e. terminates before length prefixes dictate or contains illegal characters.</li>
-   * </ul>
-   *
-   * <p>Incoming BTP messages can be either requests or responses, so sub-classes should be careful to handle both
-   * types of message, especially when bridging to synchronous API contracts, where it may become confusing as to
-   * whether an incoming message corresponds to the input our output portion of a particular synchronous method.</p>
-   *
-   * @param btpSession
-   * @param incomingBtpMessage
-   *
-   * @return
-   */
-  // TODO: Use future?
-  public BtpResponse onIncomingBtpMessage(final BtpSession btpSession, final BtpMessage incomingBtpMessage)
-      throws BtpRuntimeException {
-
-    Objects.requireNonNull(btpSession);
-    Objects.requireNonNull(incomingBtpMessage);
 
-    try {
-      final BtpSubProtocols responses = new BtpSubProtocols();
+// TODO: Push-up any shared BTP logic into this Plugin.
 
-      // Only the primary sub-protocol should be handled. The secondary sub-protocols should not request additional
-      // actions or information. If multiple actions or pieces of information are required, multiple separate Messages
-      // should be sent. The secondary sub-protocols should only modify the request made in the primary sub-protocol, or
-      // provide additional contextual data which can be consumed in a readonly way (without affecting the result).
-      final BtpSubProtocol primarySubprotocol = incomingBtpMessage.getPrimarySubProtocol();
-      final AbstractBtpSubProtocolHandler handler =
-          this.btpSubProtocolHandlerRegistry
-              .getHandler(primarySubprotocol.getProtocolName(), primarySubprotocol.getContentType())
-              .orElseThrow(() -> new BtpRuntimeException(
-                  BtpErrorCode.F00_NotAcceptedError,
-                  String.format("No BTP Handler registered for BTP SubProtocol: %s",
-                      primarySubprotocol.getProtocolName()))
-              );
-
-      final CompletableFuture<Optional<BtpSubProtocol>> btpSubProtocolResponse = handler
-          .handleSubprotocolMessage(btpSession, incomingBtpMessage);
-
-      // Add the response, but only if it's present.
-      btpSubProtocolResponse.get().ifPresent(responses::add);
-
-      // Now that there's a proper response, send it back to the connected client...
-      return BtpResponse.builder()
-          .requestId(incomingBtpMessage.getRequestId())
-          .subProtocols(responses)
-          .build();
-    } catch (Exception e) {
-      throw new BtpRuntimeException(BtpErrorCode.T00_UnreachableError, e.getMessage(), e);
-    }
-  }
-
-  /**
-   * Allows a sub-class to implement the actual logic of sending a {@link BtpPacket} over the appropriate mux, such we
-   * Websockets.
-   *
-   * @param btpMessage A {@link BtpMessage}.
-   *
-   * @return A {@link CompletableFuture} that yields a {@link BtpResponse}.
-   */
-  protected abstract CompletableFuture<Optional<BtpResponse>> doSendDataOverBtp(final BtpPacket btpMessage)
-      throws BtpRuntimeException;
-
-  protected CodecContext getIlpCodecContext() {
-    return ilpCodecContext;
-  }
-
-  protected CodecContext getBtpCodecContext() {
-    return btpCodecContext;
-  }
-
-  /**
-   * Returns the next random request id using a PRNG.
-   */
-  protected long nextRequestId() {
-    return Math.abs(random.nextInt());
-  }
-
-  /**
-   * An authentication message must have as its primary <tt>protocolData</tt> entry must have the name of 'auth',
-   * content type <tt>MIME_APPLICATION_OCTET_STREAM</tt>, and empty data, and among the secondary entries, there MUST be
-   * a UTF-8 'auth_token' entry.
-   *
-   * @return
-   */
-  public BtpMessage constructAuthMessage(
-      final long requestId, final String authToken, final Optional<String> authUserName
-  ) {
-    Objects.requireNonNull(authToken);
-    Objects.requireNonNull(authUserName);
-
-    final BtpSubProtocol authSubProtocol = BtpSubProtocol.builder()
-        .protocolName(BTP_SUB_PROTOCOL_AUTH)
-        .contentType(BtpSubProtocol.ContentType.MIME_APPLICATION_OCTET_STREAM)
-        .build();
-    final BtpSubProtocols btpSubProtocols = BtpSubProtocols.fromPrimarySubProtocol(authSubProtocol);
-
-    // In situations where no authentication is needed, the 'auth_token' data can be set to the empty string,
-    // but it cannot be omitted.
-    final BtpSubProtocol authTokenSubprotocol = BtpSubProtocol.builder()
-        .protocolName(BTP_SUB_PROTOCOL_AUTH_TOKEN)
-        .contentType(BtpSubProtocol.ContentType.MIME_APPLICATION_OCTET_STREAM)
-        .data(authToken.getBytes(StandardCharsets.UTF_8))
-        .build();
-    btpSubProtocols.add(authTokenSubprotocol);
-
-    authUserName.ifPresent($ -> {
-      final BtpSubProtocol authUsernameSubprotocol = BtpSubProtocol.builder()
-          .protocolName(BTP_SUB_PROTOCOL_AUTH_USERNAME)
-          .contentType(BtpSubProtocol.ContentType.MIME_APPLICATION_OCTET_STREAM)
-          .data($.getBytes(StandardCharsets.UTF_8))
-          .build();
-      btpSubProtocols.add(authUsernameSubprotocol);
-    });
-
-    return BtpMessage.builder()
-        .requestId(requestId)
-        .subProtocols(btpSubProtocols)
-        .build();
-  }
-
-//  private BtpError constructBtpError(final long requestId, final BtpRuntimeException btpRuntimeException) {
-//    Objects.requireNonNull(btpRuntimeException);
-//    return BtpError.builder()
-//        .requestId(requestId)
-//        .errorCode(btpRuntimeException.getCode())
-//        .triggeredAt(btpRuntimeException.getTriggeredAt())
-//        .errorData(btpRuntimeException.getMessage().getBytes(Charset.forName("UTF-8")))
+public abstract class AbstractBtpPlugin<T extends BtpPluginSettings> { //extends AbstractPlugin<T> implements Plugin<T> {
+//
+////  private final CodecContext ilpCodecContext;
+////  private final CodecContext btpCodecContext;
+////  private final Random random;
+//  private final BtpSubProtocolHandlerRegistry btpSubProtocolHandlerRegistry;
+//
+//  /**
+//   * Required-args Constructor.
+//   */
+//  public AbstractBtpPlugin(
+//      final T pluginSettings,
+////      final CodecContext ilpCodecContext,
+////      final CodecContext btpCodecContext,
+//      final BtpSubProtocolHandlerRegistry btpSubProtocolHandlerRegistry
+//  ) {
+//    super(pluginSettings);
+////    this.ilpCodecContext = Objects.requireNonNull(ilpCodecContext);
+////    this.btpCodecContext = Objects.requireNonNull(btpCodecContext);
+//    this.btpSubProtocolHandlerRegistry = btpSubProtocolHandlerRegistry;
+////    this.random = new SecureRandom();
+//
+//    // No need to do anything with the data-handler because it's overridden below.
+//    // Peg the dataSender to this class's implementation so that it always translates to BTP in order to send.
+//    //super.registerDataSender(this::sendData);
+//
+//    // No-op because there is no money-handling in default BTP.
+//    //super.registerMoneyHandler((amount) -> CompletableFuture.completedFuture(null));
+//    //super.registerMoneySender((amount) -> CompletableFuture.completedFuture(null));
+//  }
+//
+//  /**
+//   * <p>Handles an incoming {@link BtpMessage} by delegating it to a registered handler.</p>
+//   *
+//   * <p>There are also a couple of tricky cases to handle:</p>
+//   *
+//   * <ul>
+//   * <li>If an unexpected BTP packet is received, no response should be sent. An unexpected BTP packet is a
+//   * response for which a request was not sent, or a response for a request which has already been responded to.</li>
+//   * <li>If an unreadable BTP packet is received, no response should be sent. An unreadable BTP packet is one which
+//   * is structurally invalid, i.e. terminates before length prefixes dictate or contains illegal characters.</li>
+//   * </ul>
+//   *
+//   * <p>Incoming BTP messages can be either requests or responses, so sub-classes should be careful to handle both
+//   * types of message, especially when bridging to synchronous API contracts, where it may become confusing as to
+//   * whether an incoming message corresponds to the input our output portion of a particular synchronous method.</p>
+//   *
+//   * @param btpSession
+//   * @param incomingBtpMessage
+//   *
+//   * @return
+//   */
+//  // TODO: Use future?
+//  public BtpResponse onIncomingBtpMessage(final BtpSession btpSession, final BtpMessage incomingBtpMessage)
+//      throws BtpRuntimeException {
+//
+//    Objects.requireNonNull(btpSession);
+//    Objects.requireNonNull(incomingBtpMessage);
+//
+//    try {
+//      final BtpSubProtocols responses = new BtpSubProtocols();
+//
+//      // Only the primary sub-protocol should be handled. The secondary sub-protocols should not request additional
+//      // actions or information. If multiple actions or pieces of information are required, multiple separate Messages
+//      // should be sent. The secondary sub-protocols should only modify the request made in the primary sub-protocol, or
+//      // provide additional contextual data which can be consumed in a readonly way (without affecting the result).
+//      final BtpSubProtocol primarySubprotocol = incomingBtpMessage.getPrimarySubProtocol();
+//      final AbstractBtpSubProtocolHandler handler =
+//          this.btpSubProtocolHandlerRegistry
+//              .getHandler(primarySubprotocol.getProtocolName(), primarySubprotocol.getContentType())
+//              .orElseThrow(() -> new BtpRuntimeException(
+//                  BtpErrorCode.F00_NotAcceptedError,
+//                  String.format("No BTP Handler registered for BTP SubProtocol: %s",
+//                      primarySubprotocol.getProtocolName()))
+//              );
+//
+//      final CompletableFuture<Optional<BtpSubProtocol>> btpSubProtocolResponse = handler
+//          .handleSubprotocolMessage(btpSession, incomingBtpMessage);
+//
+//      // Add the response, but only if it's present.
+//      btpSubProtocolResponse.get().ifPresent(responses::add);
+//
+//      // Now that there's a proper response, send it back to the connected client...
+//      return BtpResponse.builder()
+//          .requestId(incomingBtpMessage.getRequestId())
+//          .subProtocols(responses)
+//          .build();
+//    } catch (Exception e) {
+//      throw new BtpRuntimeException(BtpErrorCode.T00_UnreachableError, e.getMessage(), e);
+//    }
+//  }
+//
+//  /**
+//   * Allows a sub-class to implement the actual logic of sending a {@link BtpPacket} over the appropriate mux, such we
+//   * Websockets.
+//   *
+//   * @param btpMessage A {@link BtpMessage}.
+//   *
+//   * @return A {@link CompletableFuture} that yields a {@link BtpResponse}.
+//   */
+//  protected abstract CompletableFuture<Optional<BtpResponse>> doSendDataOverBtp(final BtpPacket btpMessage)
+//      throws BtpRuntimeException;
+//
+//  protected CodecContext getIlpCodecContext() {
+//    return ilpCodecContext;
+//  }
+//
+//  protected CodecContext getBtpCodecContext() {
+//    return btpCodecContext;
+//  }
+//
+//  /**
+//   * Returns the next random request id using a PRNG.
+//   */
+//  protected long nextRequestId() {
+//    return Math.abs(random.nextInt());
+//  }
+//
+//  /**
+//   * An authentication message must have as its primary <tt>protocolData</tt> entry must have the name of 'auth',
+//   * content type <tt>MIME_APPLICATION_OCTET_STREAM</tt>, and empty data, and among the secondary entries, there MUST be
+//   * a UTF-8 'auth_token' entry.
+//   *
+//   * @return
+//   */
+//  public BtpMessage constructAuthMessage(
+//      final long requestId, final String authToken, final Optional<String> authUserName
+//  ) {
+//    Objects.requireNonNull(authToken);
+//    Objects.requireNonNull(authUserName);
+//
+//    final BtpSubProtocol authSubProtocol = BtpSubProtocol.builder()
+//        .protocolName(BTP_SUB_PROTOCOL_AUTH)
+//        .contentType(BtpSubProtocol.ContentType.MIME_APPLICATION_OCTET_STREAM)
 //        .build();
-//  }
-
-  //////////////////////
-  // Helper Methods
-  //////////////////////
-
-//  protected final BtpError constructBtpError(final long requestId, final String errorData) {
-//    Objects.requireNonNull(errorData);
+//    final BtpSubProtocols btpSubProtocols = BtpSubProtocols.fromPrimarySubProtocol(authSubProtocol);
+//
+//    // In situations where no authentication is needed, the 'auth_token' data can be set to the empty string,
+//    // but it cannot be omitted.
+//    final BtpSubProtocol authTokenSubprotocol = BtpSubProtocol.builder()
+//        .protocolName(BTP_SUB_PROTOCOL_AUTH_TOKEN)
+//        .contentType(BtpSubProtocol.ContentType.MIME_APPLICATION_OCTET_STREAM)
+//        .data(authToken.getBytes(StandardCharsets.UTF_8))
+//        .build();
+//    btpSubProtocols.add(authTokenSubprotocol);
+//
+//    authUserName.ifPresent($ -> {
+//      final BtpSubProtocol authUsernameSubprotocol = BtpSubProtocol.builder()
+//          .protocolName(BTP_SUB_PROTOCOL_AUTH_USERNAME)
+//          .contentType(BtpSubProtocol.ContentType.MIME_APPLICATION_OCTET_STREAM)
+//          .data($.getBytes(StandardCharsets.UTF_8))
+//          .build();
+//      btpSubProtocols.add(authUsernameSubprotocol);
+//    });
 //
-//    // Respond with a BTP Error on the websocket session.
-//    return this.constructBtpError(requestId, errorData, Instant.now(), BtpErrorCode.F00_NotAcceptedError);
-//  }
-
-//  protected final BtpError constructBtpError(final long requestId, final String errorData,
-//      final Instant triggeredAt, final BtpErrorCode btpErrorCode) {
-//    Objects.requireNonNull(errorData);
-//
-//    // Respond with a BTP Error on the websocket session.
-//    return BtpError.builder()
+//    return BtpMessage.builder()
 //        .requestId(requestId)
-//        .triggeredAt(triggeredAt)
-//        .errorCode(btpErrorCode)
-//        .errorData(errorData.getBytes(Charset.forName("UTF-8")))
+//        .subProtocols(btpSubProtocols)
 //        .build();
 //  }
-
-  public BtpSubProtocolHandlerRegistry getBtpSubProtocolHandlerRegistry() {
-    return btpSubProtocolHandlerRegistry;
-  }
-
-  // All BTP Plugins forward to the BtpSubprotocol registry to handle data.
-  @Override
-  public Optional<DataHandler> getDataHandler() {
-    // When this plugin receives a new DataHandler, it must be connected to the BtpSubProtocol registered in the registry,
-    // so we always just return that handler, if present.
-    return this.getBtpSubProtocolHandlerRegistry()
-        .getHandler(BTP_SUB_PROTOCOL_ILP, MIME_APPLICATION_OCTET_STREAM)
-        .map(ilpHandler -> (IlpBtpSubprotocolHandler) ilpHandler)
-        .map(IlpBtpSubprotocolHandler::getDataHandler);
-  }
-
-  // All BTP Plugins forward to the BtpSubprotocol registry to handle data.
-  @Override
-  public void unregisterDataHandler() {
-    final IlpBtpSubprotocolHandler handler = this.getBtpSubProtocolHandlerRegistry()
-        .getHandler(BTP_SUB_PROTOCOL_ILP, MIME_APPLICATION_OCTET_STREAM)
-        .map(abstractHandler -> (IlpBtpSubprotocolHandler) abstractHandler)
-        .orElseThrow(() -> new RuntimeException(
-            String.format("BTP subprotocol handler with name `%s` MUST be registered!", BTP_SUB_PROTOCOL_ILP)));
-
-    handler.unregisterDataHandler();
-  }
-
-  // All BTP Plugins forward to the BtpSubprotocol registry to handle data.
-  @Override
-  public void registerDataHandler(final DataHandler ilpDataHandler) throws DataHandlerAlreadyRegisteredException {
-    // The BilateralDataHandler for Btp Plugins is always the ILP handler registered with the BtpProtocolRegistry, so setting
-    // a handler here should overwrite the handler there.
-
-    final IlpBtpSubprotocolHandler handler = this.getBtpSubProtocolHandlerRegistry()
-        .getHandler(BTP_SUB_PROTOCOL_ILP, MIME_APPLICATION_OCTET_STREAM)
-        .map(abstractHandler -> (IlpBtpSubprotocolHandler) abstractHandler)
-        .orElseThrow(() -> new RuntimeException(
-            String.format("BTP subprotocol handler with name `%s` MUST be registered!", BTP_SUB_PROTOCOL_ILP)));
-
-    handler.registerDataHandler(getPluginSettings().getLocalNodeAddress(), ilpDataHandler);
-  }
-
-  /**
-   * Translates an ILP Prepare Packet into BTP for further processing.
-   *
-   * @param preparePacket
-   *
-   * @return
-   */
-  private final CompletableFuture<Optional<InterledgerResponsePacket>> sendData(final InterledgerPacket preparePacket) {
-
-    Objects.requireNonNull(preparePacket);
-
-    // TODO: Implement re-connection logic, but only if this is a BTP Client. Servers simply have to wait to be
-    // connected...
-    // If the plugin is not connected, then throw an exception...
-    if (!this.isConnected()) {
-      throw new InterledgerProtocolException(
-          InterledgerRejectPacket.builder()
-              .message("Plugin not connected!")
-              .triggeredBy(getPluginSettings().getLocalNodeAddress())
-              .code(InterledgerErrorCode.T01_LEDGER_UNREACHABLE)
-              .build()
-      );
-    }
-
-    //if(this.get)
-
-    // From JS...
-    //      type: BtpPacket.TYPE_MESSAGE,
-    //        requestId: await _requestId(),
-    //      data: { protocolData: [{
-    //      protocolName: 'ilp',
-    //        contentType: BtpPacket.MIME_APPLICATION_OCTET_STREAM,
-    //        data: buffer
-    //    }] }
-    //    }
-
-    // This is just a translation layer. Transmit the above `preparePacket` to a remote peer via BTP.
-    final BtpSubProtocol ilpSubProtocol = IlpBtpSubprotocolHandler
-        .toBtpSubprotocol(preparePacket, ilpCodecContext);
-    final BtpMessage btpMessage = BtpMessage.builder()
-        .requestId(nextRequestId())
-        .subProtocols(BtpSubProtocols.fromPrimarySubProtocol(ilpSubProtocol))
-        .build();
-
-    // This is synchronized by the Map...
-    //    if (this.acknowledgedRequests.putIfAbsent(btpMessage.getRequestId(), false) == false) {
-    //      // The request is already pending, so throw an exception.
-    //      throw new RuntimeException(
-    //        String.format("Encountered duplicate requestId: `%s`", btpMessage.getRequestId()));
-    //    }
-
-    // TODO: FIXME per https://stackoverflow.com/questions/33913193/completablefuture-waiting-for-first-one-normally-return
-
-    final CompletableFuture<Optional<InterledgerResponsePacket>> response = this.doSendDataOverBtp(btpMessage)
-        .thenApply(btpResponse -> btpResponse
-            .map($ -> IlpBtpSubprotocolHandler.toIlpPacket($, ilpCodecContext))
-            .map(Optional::of)
-            .orElse(Optional.empty())
-        )
-        .thenApply(ilpPacket -> ilpPacket
-            .map(p -> {
-              // Convert the ilpPacket into either a fulfill or an exception.
-              // TODO Use InterlederPacketHandler if this sticks around...
-              if (InterledgerFulfillPacket.class.isAssignableFrom(p.getClass())) {
-                return (InterledgerFulfillPacket) p;
-              } else {
-                return (InterledgerRejectPacket) p;
-              }
-            })
-            .map(Optional::of)
-            .orElse(Optional.empty())
-        );
-
-    // NOTE: Request/Response matching is a function of Websockets and being able to
-    return response;
-  }
-
-  @Override
-  public final void registerDataSender(final DataSender dataSender) throws DataHandlerAlreadyRegisteredException {
-    throw new RuntimeException(
-        "BTP Plugins may not register a customer DataSender because all send operations flow over BTP!");
-  }
+//
+////  private BtpError constructBtpError(final long requestId, final BtpRuntimeException btpRuntimeException) {
+////    Objects.requireNonNull(btpRuntimeException);
+////    return BtpError.builder()
+////        .requestId(requestId)
+////        .errorCode(btpRuntimeException.getCode())
+////        .triggeredAt(btpRuntimeException.getTriggeredAt())
+////        .errorData(btpRuntimeException.getMessage().getBytes(Charset.forName("UTF-8")))
+////        .build();
+////  }
+//
+//  //////////////////////
+//  // Helper Methods
+//  //////////////////////
+//
+////  protected final BtpError constructBtpError(final long requestId, final String errorData) {
+////    Objects.requireNonNull(errorData);
+////
+////    // Respond with a BTP Error on the websocket session.
+////    return this.constructBtpError(requestId, errorData, Instant.now(), BtpErrorCode.F00_NotAcceptedError);
+////  }
+//
+////  protected final BtpError constructBtpError(final long requestId, final String errorData,
+////      final Instant triggeredAt, final BtpErrorCode btpErrorCode) {
+////    Objects.requireNonNull(errorData);
+////
+////    // Respond with a BTP Error on the websocket session.
+////    return BtpError.builder()
+////        .requestId(requestId)
+////        .triggeredAt(triggeredAt)
+////        .errorCode(btpErrorCode)
+////        .errorData(errorData.getBytes(Charset.forName("UTF-8")))
+////        .build();
+////  }
+//
+//  public BtpSubProtocolHandlerRegistry getBtpSubProtocolHandlerRegistry() {
+//    return btpSubProtocolHandlerRegistry;
+//  }
+//
+//  // All BTP Plugins forward to the BtpSubprotocol registry to handle data.
+//  @Override
+//  public Optional<DataHandler> getDataHandler() {
+//    // When this plugin receives a new DataHandler, it must be connected to the BtpSubProtocol registered in the registry,
+//    // so we always just return that handler, if present.
+//    return this.getBtpSubProtocolHandlerRegistry()
+//        .getHandler(BTP_SUB_PROTOCOL_ILP, MIME_APPLICATION_OCTET_STREAM)
+//        .map(ilpHandler -> (IlpBtpSubprotocolHandler) ilpHandler)
+//        .map(IlpBtpSubprotocolHandler::getDataHandler);
+//  }
+//
+//  // All BTP Plugins forward to the BtpSubprotocol registry to handle data.
+//  @Override
+//  public void unregisterDataHandler() {
+//    final IlpBtpSubprotocolHandler handler = this.getBtpSubProtocolHandlerRegistry()
+//        .getHandler(BTP_SUB_PROTOCOL_ILP, MIME_APPLICATION_OCTET_STREAM)
+//        .map(abstractHandler -> (IlpBtpSubprotocolHandler) abstractHandler)
+//        .orElseThrow(() -> new RuntimeException(
+//            String.format("BTP subprotocol handler with name `%s` MUST be registered!", BTP_SUB_PROTOCOL_ILP)));
+//
+//    handler.unregisterDataHandler();
+//  }
+//
+//  // All BTP Plugins forward to the BtpSubprotocol registry to handle data.
+//  @Override
+//  public void registerDataHandler(final DataHandler ilpDataHandler) throws DataHandlerAlreadyRegisteredException {
+//    // The BilateralDataHandler for Btp Plugins is always the ILP handler registered with the BtpProtocolRegistry, so setting
+//    // a handler here should overwrite the handler there.
+//
+//    final IlpBtpSubprotocolHandler handler = this.getBtpSubProtocolHandlerRegistry()
+//        .getHandler(BTP_SUB_PROTOCOL_ILP, MIME_APPLICATION_OCTET_STREAM)
+//        .map(abstractHandler -> (IlpBtpSubprotocolHandler) abstractHandler)
+//        .orElseThrow(() -> new RuntimeException(
+//            String.format("BTP subprotocol handler with name `%s` MUST be registered!", BTP_SUB_PROTOCOL_ILP)));
+//
+//    handler.registerDataHandler(getPluginSettings().getLocalNodeAddress(), ilpDataHandler);
+//  }
+//
+//  /**
+//   * Translates an ILP Prepare Packet into BTP for further processing.
+//   *
+//   * @param preparePacket
+//   *
+//   * @return
+//   */
+//  private final CompletableFuture<Optional<InterledgerResponsePacket>> sendData(final InterledgerPacket preparePacket) {
+//
+//    Objects.requireNonNull(preparePacket);
+//
+//    // TODO: Implement re-connection logic, but only if this is a BTP Client. Servers simply have to wait to be
+//    // connected...
+//    // If the plugin is not connected, then throw an exception...
+//    if (!this.isConnected()) {
+//      throw new InterledgerProtocolException(
+//          InterledgerRejectPacket.builder()
+//              .message("Plugin not connected!")
+//              .triggeredBy(getPluginSettings().getLocalNodeAddress())
+//              .code(InterledgerErrorCode.T01_LEDGER_UNREACHABLE)
+//              .build()
+//      );
+//    }
+//
+//    //if(this.get)
+//
+//    // From JS...
+//    //      type: BtpPacket.TYPE_MESSAGE,
+//    //        requestId: await _requestId(),
+//    //      data: { protocolData: [{
+//    //      protocolName: 'ilp',
+//    //        contentType: BtpPacket.MIME_APPLICATION_OCTET_STREAM,
+//    //        data: buffer
+//    //    }] }
+//    //    }
+//
+//    // This is just a translation layer. Transmit the above `preparePacket` to a remote peer via BTP.
+//    final BtpSubProtocol ilpSubProtocol = IlpBtpSubprotocolHandler
+//        .toBtpSubprotocol(preparePacket, ilpCodecContext);
+//    final BtpMessage btpMessage = BtpMessage.builder()
+//        .requestId(nextRequestId())
+//        .subProtocols(BtpSubProtocols.fromPrimarySubProtocol(ilpSubProtocol))
+//        .build();
+//
+//    // This is synchronized by the Map...
+//    //    if (this.acknowledgedRequests.putIfAbsent(btpMessage.getRequestId(), false) == false) {
+//    //      // The request is already pending, so throw an exception.
+//    //      throw new RuntimeException(
+//    //        String.format("Encountered duplicate requestId: `%s`", btpMessage.getRequestId()));
+//    //    }
+//
+//    // TODO: FIXME per https://stackoverflow.com/questions/33913193/completablefuture-waiting-for-first-one-normally-return
+//
+//    final CompletableFuture<Optional<InterledgerResponsePacket>> response = this.doSendDataOverBtp(btpMessage)
+//        .thenApply(btpResponse -> btpResponse
+//            .map($ -> IlpBtpSubprotocolHandler.toIlpPacket($, ilpCodecContext))
+//            .map(Optional::of)
+//            .orElse(Optional.empty())
+//        )
+//        .thenApply(ilpPacket -> ilpPacket
+//            .map(p -> {
+//              // Convert the ilpPacket into either a fulfill or an exception.
+//              // TODO Use InterlederPacketHandler if this sticks around...
+//              if (InterledgerFulfillPacket.class.isAssignableFrom(p.getClass())) {
+//                return (InterledgerFulfillPacket) p;
+//              } else {
+//                return (InterledgerRejectPacket) p;
+//              }
+//            })
+//            .map(Optional::of)
+//            .orElse(Optional.empty())
+//        );
+//
+//    // NOTE: Request/Response matching is a function of Websockets and being able to
+//    return response;
+//  }
+//
+//  @Override
+//  public final void registerDataSender(final DataSender dataSender) throws DataHandlerAlreadyRegisteredException {
+//    throw new RuntimeException(
+//        "BTP Plugins may not register a customer DataSender because all send operations flow over BTP!");
+//  }
 
 
 }
Index: ilp-plugin-btp-springws/src/main/java/org/interledger/plugin/lpiv2/btp2/spring/connection/MultiAccountBtpServerConnection.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ilp-plugin-btp-springws/src/main/java/org/interledger/plugin/lpiv2/btp2/spring/connection/MultiAccountBtpServerConnection.java	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
+++ ilp-plugin-btp-springws/src/main/java/org/interledger/plugin/lpiv2/btp2/spring/connection/MultiAccountBtpServerConnection.java	(date 1546464713000)
@@ -1,181 +1,191 @@
 package org.interledger.plugin.lpiv2.btp2.spring.connection;
 
+import org.interledger.btp.BtpMessage;
+import org.interledger.btp.BtpResponsePacket;
+import org.interledger.btp.BtpSession;
+import org.interledger.btp.BtpTransfer;
 import org.interledger.core.InterledgerAddress;
 import org.interledger.plugin.connections.BilateralConnection;
-import org.interledger.plugin.lpiv2.btp2.spring.connection.mux.ServerBtpWebsocketMux;
+import org.interledger.plugin.connections.PluginFactory;
+import org.interledger.plugin.lpiv2.Plugin;
+import org.interledger.plugin.lpiv2.btp2.spring.BtpSessionUtils;
+import org.interledger.plugin.lpiv2.btp2.spring.converters.BinaryMessageToBtpPacketConverter;
+import org.interledger.plugin.lpiv2.btp2.spring.converters.BtpPacketToBinaryMessageConverter;
+import org.interledger.plugin.lpiv2.btp2.subprotocols.BtpSubProtocolHandlerRegistry;
 
+import org.springframework.web.socket.BinaryMessage;
 import org.springframework.web.socket.CloseStatus;
 import org.springframework.web.socket.WebSocketHandler;
 import org.springframework.web.socket.WebSocketMessage;
 import org.springframework.web.socket.WebSocketSession;
 
+import java.util.Objects;
+import java.util.concurrent.CompletableFuture;
+
 /**
  * A {@link AbstractMultiAccountBtpConnection} that uses a Websocket Server to communicate with a bilateral peer. A
- * {@link BilateralConnection} allows for the sender and receiver to be different things entirely (e.g., BPP). However,
- * this implementation uses the same WebSocket session to both send and receive on.
+ * {@link BilateralConnection} allows for the sender and receiver to be different things entirely (e.g., BPP uses a gRPC
+ * client for sending, and a gRPC server for receiving). However, this implementation uses the same WebSocket session to
+ * both send and receive on.
  */
-public final class MultiAccountBtpServerConnection extends AbstractMultiAccountBtpConnection<ServerBtpWebsocketMux>
-    implements WebSocketHandler {
+public final class MultiAccountBtpServerConnection extends
+    AbstractMultiAccountBtpConnection<MultiAccountConnectionSettings> implements WebSocketHandler {
 
   /**
    * Required-args Constructor.
-   *
-   * @param operatorAddress       The {@link InterledgerAddress} of the operator of this connection.
-   * @param serverBtpWebsocketMux An {@link ServerBtpWebsocketMux} that provides both sender and receiver
    */
   public MultiAccountBtpServerConnection(
-      final InterledgerAddress operatorAddress, final ServerBtpWebsocketMux serverBtpWebsocketMux
-  ) {
-    super(operatorAddress, serverBtpWebsocketMux);
+      MultiAccountConnectionSettings connectionSettings, PluginFactory pluginFactory,
+      BinaryMessageToBtpPacketConverter binaryMessageToBtpPacketConverter,
+      BtpPacketToBinaryMessageConverter btpPacketToBinaryMessageConverter,
+      BtpSubProtocolHandlerRegistry btpSubProtocolHandlerRegistry) {
+    super(connectionSettings, pluginFactory, binaryMessageToBtpPacketConverter, btpPacketToBinaryMessageConverter,
+        btpSubProtocolHandlerRegistry);
+  }
+
+  /**
+   * Perform the logic of connecting the actual transport(s) supporting this bilateral connection.
+   */
+  @Override
+  public CompletableFuture<Void> doConnectTransport() {
+    // No-op. The WebSocket server starts-up when the runtime initiates.
+    return CompletableFuture.completedFuture(null);
   }
+
+  /**
+   * Perform the logic of disconnecting the actual transport(s) supporting this bilateral connection.
+   */
+  @Override
+  public CompletableFuture<Void> doDisconnectTransport() {
+    // No-op. The WebSocket server disconnects when the runtime shuts down.
+    return CompletableFuture.completedFuture(null);
+  }
+
+  @Override
+  public Plugin<?> getPlugin(InterledgerAddress accountAddress) {
+
+    //
+
+  }
+
+//  /**
+//   * Converts {@code btpMessage} into the proper binary format and then sends the payload out over the websocket,
+//   * waiting for a response.
+//   */
+//  @Override
+//  public CompletableFuture<BtpResponsePacket> sendBtpMessage(final BtpMessage btpMessage) {
+//    Objects.requireNonNull(btpMessage);
+//
+//    // Translate the btpMessage to a BinaryMessage, and send out using the WebSocketSession.
+//    return this.webSocketSession
+//        .map(wss -> {
+//          final BinaryMessage binaryMessage = this.btpPacketToBinaryMessageConverter.convert(btpMessage);
+//          final long requestId = nextRequestId();
+//          return this.sendMessageWithPendingRepsonse(requestId, wss, binaryMessage)
+//              .handle((response, error) -> {
+//                if (error != null) {
+//                  // the pending response timed out or otherwise had a problem...
+//                  throw new RuntimeException(error.getMessage(), error);
+//                } else {
+//                  // Might be an error or a response`
+//                  return response;
+//                }
+//              });
+//        }).orElseThrow(() -> new RuntimeException("No WebSocket session!"));
+//  }
+//
+//  @Override
+//  public CompletableFuture<BtpResponsePacket> sendBtpTransfer(BtpTransfer btpTransfer) {
+//    throw new RuntimeException("FIXME!");
+//    //return CompletableFuture.completedFuture(null);
+//  }
 
   ///////////////////
   // WebSocketHandler
   ///////////////////
 
   /**
-   * Forward to the combo mux, which is the actual {@link WebSocketHandler}.
+   * Invoked after WebSocket negotiation has succeeded and the WebSocket connection is opened and ready for use.
+   *
+   * @param session
+   *
+   * @throws Exception this method can handle or propagate exceptions; see class-level Javadoc for details.
    */
   @Override
   public void afterConnectionEstablished(WebSocketSession session) {
-    this.getComboMux().afterConnectionEstablished(session);
+    logger.debug("Incoming WS Client Connection Established: {}", session);
+
+    // Add a new BtpSession into the WebsocketSession...it will be initialized after the `auth` sub_protocol is
+    // executed.
+    BtpSessionUtils.setBtpSessionIntoWebsocketSession(session, new BtpSession(session.getId()));
   }
 
   /**
-   * Forward to the combo mux, which is the actual {@link WebSocketHandler}.
+   * Invoked when a new incoming WebSocket message arrives.
+   *
+   * @param session
+   * @param message
+   *
+   * @throws Exception this method can handle or propagate exceptions; see class-level Javadoc for details.
    */
   @Override
   public void handleMessage(WebSocketSession session, WebSocketMessage<?> message) {
-    this.getComboMux().handleMessage(session, message);
+    if (message instanceof BinaryMessage) {
+      this.handleBinaryMessage(session, (BinaryMessage) message);
+    } else {
+      throw new IllegalStateException("Unexpected WebSocket message type: " + message);
+    }
   }
 
   /**
-   * Forward to the combo mux, which is the actual {@link WebSocketHandler}.
+   * Handle an error from the underlying WebSocket message transport.
+   *
+   * @param session
+   * @param exception
+   *
+   * @throws Exception this method can handle or propagate exceptions; see class-level Javadoc for details.
    */
   @Override
   public void handleTransportError(WebSocketSession session, Throwable exception) {
-    this.getComboMux().handleTransportError(session, exception);
+    // Don't premptively close any connections. It's possible this is just a transient error, and we can wait until the
+    // actual connection closes to disconnect this MUX.
+    logger.error(exception.getMessage(), exception);
   }
 
   /**
-   * Forward to the combo mux, which is the actual {@link WebSocketHandler}.
+   * Invoked after the WebSocket connection has been closed by either side, or after a transport error has occurred.
+   * Although the session may technically still be open, depending on the underlying implementation, sending messages at
+   * this point is discouraged and most likely will not succeed.
+   *
+   * @param session
+   * @param closeStatus
+   *
+   * @throws Exception this method can handle or propagate exceptions; see class-level Javadoc for details.
    */
   @Override
   public void afterConnectionClosed(WebSocketSession session, CloseStatus closeStatus) {
-    this.getComboMux().afterConnectionClosed(session, closeStatus);
+    logger.debug("WS Client Connection Closed: {}", session);
+
+    // BilateralReceivers (typically plugins) aren't aware that they're being MUX'd, so this MUX must disconnect each
+    // one.
+    this.disconnect();
+
+//    final CompletableFuture[] disconnectFutures = this.getBilateralReceivers().values().stream()
+//        .map(BilateralReceiver::disconnect)
+//        .collect(Collectors.toList())
+//        .toArray(new CompletableFuture[0]);
+
+//    // Wait up to 30 seconds for all disconnects to occur...
+//    try {
+//      CompletableFuture.allOf(disconnectFutures).get(30, TimeUnit.SECONDS);
+//    } catch (Exception e) {
+//      throw new RuntimeException(e.getMessage(), e);
+//    }
   }
 
-  /**
-   * Forward to the combo mux, which is the actual {@link WebSocketHandler}.
-   */
   @Override
   public boolean supportsPartialMessages() {
-    return this.getComboMux().supportsPartialMessages();
+    return false;
   }
 
-//  /**
-//   * Handle an incoming {@link BinaryMessage} by translating it into BTP, forwarding to the appropriate plugin, and then
-//   * returning a response on the Websocket.
-//   *
-//   * @param webSocketSession
-//   * @param binaryMessage
-//   */
-//  @VisibleForTesting
-//  protected void handleBinaryMessage(
-//      final WebSocketSession webSocketSession, final BinaryMessage binaryMessage
-//  ) {
-//
-//    Objects.requireNonNull(webSocketSession);
-//    Objects.requireNonNull(binaryMessage);
-//
-//    // The first message in a WebSocketSession MUST be the auth protocol. Thus, as long as the BtpSession is not
-//    // authenticated, then we should attempt to perform the auth sub_protocol.
-//    final BtpSession btpSession = BtpSessionUtils.getBtpSessionFromWebSocketSession(webSocketSession);
-//
-//    final Optional<BinaryMessage> response;
-//    if (!btpSession.isAuthenticated()) {
-//      // Do Auth. This will merely initialize the credentials into the BTPSession and return an Ack.
-//      response = this.onIncomingBinaryAuthMessage(webSocketSession, binaryMessage);
-//    } else {
-//      // The authUsername will not be present in the BtpSession until _after_ the `auth` sub_protocol has completed,
-//      // so we cannot attempt to resolve a Receiver (i.e., a plugin) until the caller is authenticated.
-//      response = btpSession.getBtpSessionCredentials().get()
-//          .map(BtpSessionCredentials::getAuthUsername)
-//          .filter(Optional::isPresent)
-//          .map(Optional::get)
-//          .map(InterledgerAddress::of)
-//          .map(authUserName -> this.getBilateralReceiverMux().handleBinaryMessage(webSocketSession, binaryMessage))
-//          .orElseThrow(() -> new RuntimeException(String
-//              .format("BtpSession `%s` was not authenticated (no auth_username found in credentials)",
-//                  btpSession.getWebsocketSessionId())));
-//    }
-//
-//    // Return the response to the caller, if there is a response.
-//    response.ifPresent($ -> {
-//      try {
-//        // TODO: What does the other side of the WebSocket see if there's an exception here?
-//        webSocketSession.sendMessage($);
-//      } catch (IOException e) {
-//        throw new RuntimeException(e);
-//      }
-//    });
-//  }
-
-//  /**
-//   * Handle an incoming BinaryMessage from a Websocket by assuming it's a BTP Auth message. This method is used
-//   * internally to establish an authenticated BTP session, correlating that to a Websocket Session.
-//   *
-//   * @param webSocketSession
-//   * @param incomingBinaryMessage
-//   *
-//   * @return A {@link BinaryMessage} that can immediately be returned to the caller (this response will contain
-//   *     everything required to be eligible as a BTP response), or nothing if the response is {@link Optional#empty()}.
-//   */
-//  @VisibleForTesting
-//  protected Optional<BinaryMessage> onIncomingBinaryAuthMessage(
-//      final WebSocketSession webSocketSession, final BinaryMessage incomingBinaryMessage
-//  ) {
-//    Objects.requireNonNull(webSocketSession);
-//    Objects.requireNonNull(incomingBinaryMessage);
-//
-//    // If there's a problem de-serializing the BtpPacket from the BinaryMessage, then close the connection and
-//    // return empty. This is one of the "tricky cases" as defined in the BTP spec where we don't want to get into
-//    // an infinite loop.
-//    final BtpPacket incomingBtpPacket;
-//    try {
-//      incomingBtpPacket = this.binaryMessageToBtpPacketConverter.convert(incomingBinaryMessage);
-//      final BtpSession btpSession = BtpSessionUtils.getBtpSessionFromWebSocketSession(webSocketSession);
-//      return serverAuthBtpSubprotocolHandler.handleSubprotocolMessage(btpSession, incomingBtpPacket)
-//          .thenApply(btpSubProtocol -> {
-//            // If there's no exception, then reaching here means the btp_auth SubProtocol succeeded.
-//            // Ack the response...
-//            final BtpSubProtocols responses = new BtpSubProtocols();
-//            btpSubProtocol.ifPresent(responses::add);
-//            final BtpResponse btpResponse = BtpResponse.builder()
-//                .requestId(incomingBtpPacket.getRequestId())
-//                .subProtocols(responses)
-//                .build();
-//            final Optional<BinaryMessage> response = Optional
-//                .of(btpPacketToBinaryMessageConverter.convert(btpResponse));
-//
-//            // If auth succeeded, there will be an Account in the BTP session. If there is no session, or if auth
-//            // did not succeed, then this event will not be propagated, and nothing will happen (i.e., no plugin will
-//            // be registered).
-//            btpSession.getAccountAddress().ifPresent(accountAddress -> {
-//              // Emit this event so any listeners can react to this account connecting on this connection...
-//              this.getEventEmitter().emitEvent(
-//                  ImmutableAccountConnectedEvent.builder().accountAddress(accountAddress).build()
-//              );
-//            });
-//
-//            return response;
-//          })
-//          .join();
-//    } catch (BtpConversionException btpConversionException) {
-//      logger.error(btpConversionException.getMessage(), btpConversionException);
-//      throw btpConversionException;
-//    }
-//  }
-//
-//
 }
Index: ilp-plugin-btp/src/main/java/org/interledger/plugin/lpiv2/btp2/subprotocols/BtpAuthenticator.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ilp-plugin-btp/src/main/java/org/interledger/plugin/lpiv2/btp2/subprotocols/BtpAuthenticator.java	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
+++ ilp-plugin-btp/src/main/java/org/interledger/plugin/lpiv2/btp2/subprotocols/BtpAuthenticator.java	(date 1545853831000)
@@ -4,28 +4,20 @@
 
 import java.util.Objects;
 
+/**
+ * A service for authenticating BTP sessions using an `auth_token` as specified by the BTP protocol.
+ */
 public interface BtpAuthenticator {
 
   /**
    * Checks to see if the provided authentication credentials are valid. This variant is used for BTP Plugins that
    * support only a single counterparty.
    *
-   * @param incomingAuthToken A {@link String} containing an `auth_token` for a BtpSession.
-   *
-   * @return {@code true} if the auth_token is valid; {@code false} otherwise.
-   */
-  boolean isValidAuthToken(String incomingAuthToken);
-
-  /**
-   * Checks to see if the provided authentication credentials are valid. This variant is used for BTP plugins that
-   * support multiple accounts, thus simulating multiple BTP sessions over a single mux.
-   *
-   * @param incomingAuthUsername A {@link String} containing an `auth_username` for a BtpSession.
-   * @param incomingAuthToken    A {@link String} containing an `auth_token` for a BtpSession.
+   * @param authToken A {@link String} containing an `auth_token` for a BtpSession.
    *
    * @return {@code true} if the auth_token is valid; {@code false} otherwise.
    */
-  boolean isValidAuthToken(String incomingAuthUsername, String incomingAuthToken);
+  boolean isValidAuthToken(String authToken);
 
   /**
    * <p>For the supplied {@code authUsername}, attempt to locate the corresponding {@link InterledgerAddress}.
@@ -52,12 +44,7 @@
     }
 
     @Override
-    public boolean isValidAuthToken(String incomingAuthToken) {
-      return true;
-    }
-
-    @Override
-    public boolean isValidAuthToken(String incomingAuthUsername, String incomingAuthToken) {
+    public boolean isValidAuthToken(String authToken) {
       return true;
     }
 
Index: ilp-plugin-grpc/pom.xml
===================================================================
--- ilp-plugin-grpc/pom.xml	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
+++ ilp-plugin-bpp-grpc/pom.xml	(date 1545322972000)
@@ -9,10 +9,10 @@
   </parent>
   <modelVersion>4.0.0</modelVersion>
 
-  <artifactId>ilp-plugin-grpc</artifactId>
+  <artifactId>ilp-plugin-bpp-grpc</artifactId>
 
-  <name>ILP LPIv2 over gRPC</name>
-  <description>Java implementation of a Ledger Plugin Interface (v2) over gRPC</description>
+  <name>ILP Plugin BPP over gRPC</name>
+  <description>Core classes to support the Bilateral Push Protocol (BPP) over gRPC.</description>
 
   <dependencies>
     <dependency>
Index: ilp-plugin-connections/src/main/java/org/interledger/plugin/connections/PluginFactory.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ilp-plugin-connections/src/main/java/org/interledger/plugin/connections/PluginFactory.java	(date 1546448959000)
+++ ilp-plugin-connections/src/main/java/org/interledger/plugin/connections/PluginFactory.java	(date 1546448959000)
@@ -0,0 +1,18 @@
+package org.interledger.plugin.connections;
+
+import org.interledger.plugin.lpiv2.Plugin;
+import org.interledger.plugin.lpiv2.PluginSettings;
+
+/**
+ * An interface that defines how to construct a plugin for a particular account address.
+ */
+public interface PluginFactory {
+
+  /**
+   * Construct a new instance of {@link Plugin} using the supplied inputs.
+   *
+   * @return A newly constructed instance of {@link Plugin}.
+   */
+  Plugin<?> constructPlugin(final PluginSettings pluginSettings);
+
+}
Index: pom.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- pom.xml	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
+++ pom.xml	(date 1546461923000)
@@ -44,7 +44,7 @@
   <properties>
     <jackson-annotations.version>2.8.9</jackson-annotations.version>
     <guava.version>21.0</guava.version>
-    <immutables.version>2.6.3</immutables.version>
+    <immutables.version>2.7.3</immutables.version>
     <ilp-core.version>0.15.0-SNAPSHOT</ilp-core.version>
 
     <maven-checkstyle-plugin.version>2.17</maven-checkstyle-plugin.version>
@@ -74,8 +74,7 @@
     <module>ilp-plugin-connections</module>
     <module>ilp-plugin-btp</module>
     <module>ilp-plugin-btp-springws</module>
-    <!--<module>ilp-plugin-grpc</module>-->
-    <!--<module>ilp-plugin-btp-grpc</module>-->
+    <!--<module>ilp-plugin-bpp-grpc</module>-->
   </modules>
 
   <dependencyManagement>
@@ -98,6 +97,16 @@
       <dependency>
         <groupId>${project.groupId}</groupId>
         <artifactId>ilp-plugin-btp</artifactId>
+        <version>${project.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>${project.groupId}</groupId>
+        <artifactId>ilp-plugin-btp-springws</artifactId>
+        <version>${project.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>${project.groupId}</groupId>
+        <artifactId>ilp-plugin-bpp-grpc</artifactId>
         <version>${project.version}</version>
       </dependency>
       <dependency>
Index: ilp-plugin-connections/src/main/java/org/interledger/plugin/connections/mux/Mux.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ilp-plugin-connections/src/main/java/org/interledger/plugin/connections/mux/Mux.java	(date 1546449500000)
+++ ilp-plugin-connections/src/main/java/org/interledger/plugin/connections/mux/Mux.java	(date 1546449500000)
@@ -0,0 +1,5 @@
+package org.interledger.plugin.connections.mux;
+
+public interface Mux {
+
+}
Index: ilp-plugin-btp/src/main/java/org/interledger/plugin/lpiv2/btp2/subprotocols/ilp/IlpBtpConverter.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ilp-plugin-btp/src/main/java/org/interledger/plugin/lpiv2/btp2/subprotocols/ilp/IlpBtpConverter.java	(date 1546454644000)
+++ ilp-plugin-btp/src/main/java/org/interledger/plugin/lpiv2/btp2/subprotocols/ilp/IlpBtpConverter.java	(date 1546454644000)
@@ -0,0 +1,70 @@
+package org.interledger.plugin.lpiv2.btp2.subprotocols.ilp;
+
+import org.interledger.btp.BtpResponse;
+import org.interledger.btp.BtpSubProtocol;
+import org.interledger.btp.BtpSubProtocols;
+import org.interledger.core.InterledgerPacket;
+import org.interledger.core.InterledgerResponsePacket;
+import org.interledger.encoding.asn.framework.CodecContext;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.util.Objects;
+
+/**
+ * A central place to convert between ILP and BTP packets.
+ */
+public class IlpBtpConverter {
+
+  /**
+   * Construct an {@link InterledgerPacket} using data in the supplied BTP packet.
+   *
+   * @param btpResponse     A {@link BtpResponse} containing fulfill or reject packet.
+   * @param ilpCodecContext A {@link CodecContext} that can read ILP Packets.
+   *
+   * @return An newly constructed {@link InterledgerPacket}.
+   */
+  public static InterledgerResponsePacket toIlpPacket(
+      BtpResponse btpResponse, final CodecContext ilpCodecContext
+  ) {
+    Objects.requireNonNull(btpResponse);
+    Objects.requireNonNull(ilpCodecContext);
+
+    try {
+      final ByteArrayInputStream inputStream =
+          new ByteArrayInputStream(btpResponse.getPrimarySubProtocol().getData());
+      return ilpCodecContext.read(InterledgerResponsePacket.class, inputStream);
+    } catch (Exception e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  /**
+   * Construct a {@link BtpSubProtocol} instance for using the <tt>ILP</tt> packet data.
+   *
+   * @param ilpPacket       An {@link InterledgerPacket} that can be a prepare, fulfill, or error packet.
+   * @param ilpCodecContext A {@link CodecContext} that can operate on ILP primitives.
+   *
+   * @return A {@link BtpSubProtocol}
+   */
+  public static BtpSubProtocol toBtpSubprotocol(
+      final InterledgerPacket ilpPacket, final CodecContext ilpCodecContext
+  ) {
+    Objects.requireNonNull(ilpPacket);
+    Objects.requireNonNull(ilpCodecContext);
+    try {
+      final ByteArrayOutputStream baos = new ByteArrayOutputStream();
+      ilpCodecContext.write(ilpPacket, baos);
+
+      return BtpSubProtocol.builder()
+          .protocolName(BtpSubProtocols.INTERLEDGER)
+          .contentType(BtpSubProtocol.ContentType.MIME_APPLICATION_OCTET_STREAM)
+          .data(baos.toByteArray())
+          .build();
+    } catch (Exception e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+
+}
Index: ilp-plugin-connections/src/main/java/org/interledger/plugin/connections/loopback/LoopbackConnection.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ilp-plugin-connections/src/main/java/org/interledger/plugin/connections/loopback/LoopbackConnection.java	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
+++ ilp-plugin-connections/src/main/java/org/interledger/plugin/connections/loopback/LoopbackConnection.java	(date 1545409959000)
@@ -4,8 +4,6 @@
 import org.interledger.plugin.connections.AbstractBilateralConnection;
 import org.interledger.plugin.connections.BilateralConnection;
 import org.interledger.plugin.connections.BilateralConnectionType;
-import org.interledger.plugin.connections.mux.BilateralReceiverMux;
-import org.interledger.plugin.connections.mux.BilateralSenderMux;
 import org.interledger.plugin.connections.mux.LoopbackReceiverMux;
 import org.interledger.plugin.connections.mux.LoopbackSenderMux;
 
@@ -14,8 +12,8 @@
  * response as-if the connection were connected..
  */
 public class LoopbackConnection
-    extends AbstractBilateralConnection<BilateralSenderMux, BilateralReceiverMux>
-    implements BilateralConnection<BilateralSenderMux, BilateralReceiverMux> {
+    extends AbstractBilateralConnection<LoopbackSenderMux, LoopbackReceiverMux>
+    implements BilateralConnection<LoopbackSenderMux, LoopbackReceiverMux> {
 
   public static final String CONNECTION_TYPE_STRING = "LoopbackConnection";
   public static final BilateralConnectionType CONNECTION_TYPE = BilateralConnectionType.of(CONNECTION_TYPE_STRING);
Index: ilp-plugin-connections/src/main/java/org/interledger/plugin/connections/AbstractBilateralConnection.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ilp-plugin-connections/src/main/java/org/interledger/plugin/connections/AbstractBilateralConnection.java	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
+++ ilp-plugin-connections/src/main/java/org/interledger/plugin/connections/AbstractBilateralConnection.java	(date 1546457589000)
@@ -1,13 +1,14 @@
 package org.interledger.plugin.connections;
 
-import org.interledger.core.InterledgerAddress;
-import org.interledger.plugin.connections.mux.BilateralReceiverMux;
-import org.interledger.plugin.connections.mux.BilateralSenderMux;
+import org.interledger.plugin.connections.settings.BilateralConnectionSettings;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import java.util.Objects;
+import java.util.Optional;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.atomic.AtomicBoolean;
 
 /**
  * <p>An abstract implementation of {@link BilateralConnection}. By default, Connections support multiple
@@ -15,169 +16,34 @@
  * protocols like vanilla BTP, which only supports `auth_token` and assumes only a single account per Websocket
  * connection.</p>
  *
- * <p>Generally, however, this mechanism enables distinct sender and receiver MUXes that can operate on distinct
- * network transports. For example, BPP utilizes different network connections for outgoing data vs incoming data.</p>
- *
- * <p>Note that the actual network transport connection handling always occurs in the MUX level, and never at the
- * Bilateral Connection level. This ensures a uniform design regardless of if a connection has a single underlying
- * transport, or two transports (one in the senderMux and one in the receiverMux).</p>
+ * <p>The actual network transport connections are contained in sub-classes of this class, and are handed-off to
+ * plugins when the plugins are instantiated. This ensures a uniform design regardless of if a connection has a single
+ * underlying transport, or two transports, such as in the BPP protocol.
  */
-public class AbstractBilateralConnection<SM extends BilateralSenderMux, RM extends BilateralReceiverMux>
-    implements BilateralConnection<SM, RM> {
-
-  protected final Logger logger = LoggerFactory.getLogger(this.getClass());
+public abstract class AbstractBilateralConnection<CS extends BilateralConnectionSettings> implements
+    BilateralConnection<CS> {
 
-  //private final UUID bilateralConnectionId = UUID.randomUUID();
-  private final InterledgerAddress operatorAddress;
+  private final AtomicBoolean connected = new AtomicBoolean(NOT_CONNECTED);
+  private final CS connectionSettings;
 
-  // E.g., a gRPC client or server.
-  private final SM bilateralSenderMux;
-  private final RM bilateralReceiverMux;
-
-  //private final BilateralConnectionTracker connectionTracker;
-
-  // NOTE: A Bilateral Connection should emit sender and receiver specific MUX events instead of its own events because
-  // anyone using this BC abstraction will want to be able to tell the difference between the sender and receiver connecting.
-
-  // The emitter used by this plugin.
-  //private BilateralConnectionEventEmitter eventEmitter;
-
-//  /**
-//   * Required-args Constructor.
-//   */
-//  public AbstractBilateralConnection(
-//      final InterledgerAddress operatorAddress, final SM bilateralSenderMux, final RM bilateralReceiverMux
-//  ) {
-//    this(operatorAddress, bilateralSenderMux, bilateralReceiverMux, new SyncBilateralConnectionEventEmitter()
-//    );
-//  }
+  private final PluginFactory pluginFactory;
+  protected Logger logger = LoggerFactory.getLogger(this.getClass());
 
   /**
    * Required-args Constructor.
    */
   public AbstractBilateralConnection(
-      final InterledgerAddress operatorAddress, final SM bilateralSenderMux, final RM bilateralReceiverMux
-      //final BilateralConnectionEventEmitter eventEmitter
+      final CS connectionSettings,
+      final PluginFactory pluginFactory
   ) {
-    this.operatorAddress = Objects.requireNonNull(operatorAddress);
-    this.bilateralSenderMux = Objects.requireNonNull(bilateralSenderMux);
-    this.bilateralReceiverMux = Objects.requireNonNull(bilateralReceiverMux);
-
     // TODO: Use EventBus instead
     //this.eventEmitter = Objects.requireNonNull(eventEmitter);
-  }
-
-  @Override
-  public InterledgerAddress getOperatorAddress() {
-    return this.operatorAddress;
-  }
-
-//  @Override
-//  public final CompletableFuture<Void> connect() {
-//    logger.debug("Connecting BilateralConnection: `{}`...", bilateralConnectionId);
-//    return this.connectionTracker.connect();
-//  }
-//
-//  @Override
-//  public final void close() {
-//    this.disconnect().join();
-//  }
-//
-//  @Override
-//  public final CompletableFuture<Void> disconnect() {
-//    logger.debug("Disconnecting BilateralConnection: `{}`...", bilateralConnectionId);
-//    return this.connectionTracker.disconnect();
-//  }
-
-//  @Override
-//  public final boolean isConnected() {
-//    return this.connectionTracker.isConnected();
-//  }
-
-  @Override
-  public RM getBilateralReceiverMux() {
-    return this.bilateralReceiverMux;
-  }
 
-//  @Override
-//  public void addConnectionEventListener(
-//      final UUID eventListenerId, final BilateralConnectionEventListener eventListener
-//  ) {
-//    Objects.requireNonNull(eventListenerId);
-//    Objects.requireNonNull(eventListener);
-//    this.eventEmitter.addEventListener(eventListenerId, eventListener);
-//  }
-//
-//  @Override
-//  public void removeConnectionEventListener(UUID eventListenerId) {
-//    Objects.requireNonNull(eventListenerId);
-//    this.eventEmitter.removeEventListener(eventListenerId);
-//  }
-
-  @Override
-  public SM getBilateralSenderMux() {
-    return this.bilateralSenderMux;
+    this.connectionSettings = Objects.requireNonNull(connectionSettings);
+    this.pluginFactory = Objects.requireNonNull(pluginFactory);
   }
 
-//  @Override
-//  public void onConnect(final BilateralConnectionConnectedEvent event) {
-//    Objects.requireNonNull(event);
-//    logger.debug("BilateralSenderMuxConnectedEvent: {}", event);
-//
-//    // Each MUX is already listening to BC events, so this is a no-op.
-//  }
-//
-//  @Override
-//  public void onDisconnect(final BilateralConnectionDisconnectedEvent event) {
-//    Objects.requireNonNull(event);
-//    logger.debug("BilateralSenderMuxDisconnectedEvent: {}", event);
-//
-//    // Each MUX is already listening to BC events, so this is a no-op.
-//  }
-
-//  protected BilateralConnectionEventEmitter getEventEmitter() {
-//    return eventEmitter;
-//  }
-//
-//  /**
-//   * Called to handle an {@link BilateralReceiverMuxConnectedEvent}.
-//   *
-//   * @param event A {@link BilateralReceiverMuxConnectedEvent}.
-//   */
-//  @Override
-//  public void onConnect(BilateralReceiverMuxConnectedEvent event) {
-//    throw new RuntimeException("TODO");
-//  }
-//
-//  /**
-//   * Called to handle an {@link BilateralReceiverMuxDisconnectedEvent}.
-//   *
-//   * @param event A {@link BilateralReceiverMuxDisconnectedEvent}.
-//   */
-//  @Override
-//  public void onDisconnect(BilateralReceiverMuxDisconnectedEvent event) {
-//    throw new RuntimeException("TODO");
-//  }
-//
-//  /**
-//   * Called to handle an {@link BilateralSenderMuxConnectedEvent}.
-//   *
-//   * @param event A {@link BilateralSenderMuxConnectedEvent}.
-//   */
-//  @Override
-//  public void onConnect(BilateralSenderMuxConnectedEvent event) {
-//    throw new RuntimeException("TODO");
-//  }
-//
-//  /**
-//   * Called to handle an {@link BilateralSenderMuxDisconnectedEvent}.
-//   *
-//   * @param event A {@link BilateralSenderMuxDisconnectedEvent}.
-//   */
-//  @Override
-//  public void onDisconnect(BilateralSenderMuxDisconnectedEvent event) {
-//    throw new RuntimeException("TODO");
-//  }
+  // TODO: Connection Events!
 
 //  /**
 //   * An example {@link BilateralConnectionEventEmitter} that allows events to be synchronously emitted to any
@@ -226,4 +92,63 @@
 //    }
 //  }
 
+  @Override
+  public boolean isConnected() {
+    return this.connected.get();
+  }
+
+  /**
+   * <p>Connect to the remote peer.</p>
+   */
+  @Override
+  public final CompletableFuture<Void> connect() {
+    // Try to connect, but no-op if already connected.
+    if (this.connected.compareAndSet(NOT_CONNECTED, CONNECTED)) {
+      return this.doConnectTransport().thenApply($ -> {
+        logger.info("Connected to {}.", getConnectionSettings().getRemoteAddress());
+        return null;
+      });
+    } else {
+      logger.warn("Connection already connected to {}!", getConnectionSettings().getRemoteAddress());
+      return CompletableFuture.completedFuture(null);
+    }
+  }
+
+  /**
+   * Perform the logic of connecting the actual transport(s) supporting this bilateral connection.
+   */
+  public abstract CompletableFuture<Void> doConnectTransport();
+
+  /**
+   * Disconnect from the remote peer.
+   */
+  @Override
+  public final CompletableFuture<Void> disconnect() {
+    // Try to disconnect, but no-op if already disconnected.
+    if (this.connected.compareAndSet(CONNECTED, NOT_CONNECTED)) {
+      return this.doDisconnectTransport().thenApply($ -> {
+        logger.info("Disconnected from {}.", getConnectionSettings().getRemoteAddress());
+        return null;
+      });
+    } else {
+      logger.warn("Connection already disconnected from {}!", getConnectionSettings().getRemoteAddress());
+      return CompletableFuture.completedFuture(null);
+    }
+  }
+
+  /**
+   * Perform the logic of disconnecting the actual transport(s) supporting this bilateral connection.
+   */
+  public abstract CompletableFuture<Void> doDisconnectTransport();
+
+  @Override
+  public CS getConnectionSettings() {
+    return this.connectionSettings;
+  }
+
+  public PluginFactory getPluginFactory() {
+    return pluginFactory;
+  }
+
+
 }
Index: ilp-plugin-btp-springws/src/main/java/org/interledger/plugin/lpiv2/btp2/spring/connection/MultiAccountBtpClientConnection.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ilp-plugin-btp-springws/src/main/java/org/interledger/plugin/lpiv2/btp2/spring/connection/MultiAccountBtpClientConnection.java	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
+++ ilp-plugin-btp-springws/src/main/java/org/interledger/plugin/lpiv2/btp2/spring/connection/MultiAccountBtpClientConnection.java	(date 1546459483000)
@@ -1,29 +1,43 @@
 package org.interledger.plugin.lpiv2.btp2.spring.connection;
 
 import org.interledger.core.InterledgerAddress;
-import org.interledger.plugin.lpiv2.btp2.spring.connection.mux.ClientBtpWebsocketMux;
+import org.interledger.plugin.connections.PluginFactory;
+import org.interledger.plugin.lpiv2.Plugin;
+
+import java.util.concurrent.CompletableFuture;
 
 /**
- * A {@link AbstractSingleAccountBtpConnection} that uses a Websocket Client to communicate with a bilateral peer.
+ * A {@link AbstractMultiAccountBtpConnection} that uses a Websocket Server to communicate with potentially many
+ * bilateral peers.
  *
- * @deprecated This class will likely be removed in a future release. It's unclear if this implementation is required.
- *     In general, to support multiple client connections, a Connector should consider simply creating new instances of
- *     a AbstractSingleAccountBtpConnection.
+ * @deprecated This implementation will likely be removed in-favor of simply using multiple single-client BTP Client
+ *     connections via {@link SingleAccountBtpClientConnection}.
  */
 @Deprecated
-public final class MultiAccountBtpClientConnection extends AbstractMultiAccountBtpConnection<ClientBtpWebsocketMux> {
+public final class MultiAccountBtpClientConnection extends
+    AbstractMultiAccountBtpConnection<MultiAccountConnectionSettings> {
 
   /**
    * Required-args Constructor.
-   *
-   * @param operatorAddress    The {@link InterledgerAddress} of the operator of this connection.
-   * @param serverWebsocketMux An {@link ClientBtpWebsocketMux} that provides both sender and receiver functionality
-   *                           using a WebSocket client.
    */
   public MultiAccountBtpClientConnection(
-      final InterledgerAddress operatorAddress,
-      final ClientBtpWebsocketMux serverWebsocketMux
-  ) {
-    super(operatorAddress, serverWebsocketMux);
+      MultiAccountConnectionSettings connectionSettings,
+      PluginFactory pluginFactory) {
+    super(connectionSettings, pluginFactory);
+  }
+
+  @Override
+  public CompletableFuture<Void> doConnectTransport() {
+    throw new RuntimeException("Not yet implemented!");
+  }
+
+  @Override
+  public CompletableFuture<Void> doDisconnectTransport() {
+    throw new RuntimeException("Not yet implemented!");
+  }
+
+  @Override
+  public Plugin<?> getPlugin(InterledgerAddress accountAddress) {
+    throw new RuntimeException("Not yet implemented!");
   }
 }
Index: ilp-plugin-btp-springws/src/test/java/org/interledger/plugin/lpiv2/btp2/spring/connection/SingleAccountBtpConnectionTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ilp-plugin-btp-springws/src/test/java/org/interledger/plugin/lpiv2/btp2/spring/connection/SingleAccountBtpConnectionTest.java	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
+++ ilp-plugin-btp-springws/src/test/java/org/interledger/plugin/lpiv2/btp2/spring/connection/SingleAccountBtpConnectionTest.java	(date 1546391328000)
@@ -2,9 +2,17 @@
 
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.core.Is.is;
+import static org.interledger.plugin.lpiv2.btp2.spring.connection.TestHelpers.FULFILLMENT;
+import static org.junit.Assert.fail;
 
 import org.interledger.btp.asn.framework.BtpCodecContextFactory;
 import org.interledger.core.InterledgerAddress;
+import org.interledger.core.InterledgerFulfillPacket;
+import org.interledger.core.InterledgerPreparePacket;
+import org.interledger.core.InterledgerRejectPacket;
+import org.interledger.core.InterledgerResponsePacket;
+import org.interledger.core.InterledgerResponsePacketHandler;
+import org.interledger.plugin.lpiv2.LoopbackPlugin;
 import org.interledger.plugin.lpiv2.btp2.spring.connection.SingleAccountBtpConnectionTest.TestServerConfig;
 import org.interledger.plugin.lpiv2.btp2.spring.connection.mux.ClientBtpWebsocketMux;
 import org.interledger.plugin.lpiv2.btp2.spring.connection.mux.ServerBtpWebsocketMux;
@@ -41,6 +49,7 @@
 import org.springframework.web.socket.config.annotation.WebSocketConfigurer;
 import org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;
 
+import java.math.BigInteger;
 import java.util.Optional;
 
 /**
@@ -145,6 +154,101 @@
     assertThat(bilateralConnection.getComboMux().isConnected(), is(false));
   }
 
+  @Test
+  public void testDataSender() {
+    // The sender on this connection is the loopback plugin...
+    this.bilateralConnection.getBilateralSenderMux()
+        .registerBilateralSender(ACCOUNT_ADDRESS, new LoopbackPlugin(CLIENT_OPERATOR_ADDRESS));
+
+    // A prepare packet with a data-payload that contains the preimage of FULFILLMENT.
+    final InterledgerPreparePacket PREPARE_PACKET = TestHelpers.constructSendDataPreparePacket(ACCOUNT_ADDRESS);
+
+    final Optional<InterledgerResponsePacket> result = bilateralConnection
+        .getBilateralSenderMux().getBilateralSender(ACCOUNT_ADDRESS).get()
+        .safeGetDataSender()
+        .sendData(PREPARE_PACKET)
+        .join();
+
+    new InterledgerResponsePacketHandler() {
+      @Override
+      protected void handleFulfillPacket(InterledgerFulfillPacket interledgerFulfillPacket) {
+        assertThat(interledgerFulfillPacket.getFulfillment(), is(FULFILLMENT));
+      }
+
+      @Override
+      protected void handleRejectPacket(InterledgerRejectPacket interledgerRejectPacket) {
+        fail("Should not reject!");
+      }
+
+      @Override
+      protected void handleExpiredPacket() {
+        fail("Should not expire!");
+      }
+    }.handle(result);
+
+  }
+
+  @Test
+  public void testMoneySender() {
+    // The sender on this connection is the loopback plugin...
+    this.bilateralConnection.getBilateralSenderMux()
+        .registerBilateralSender(ACCOUNT_ADDRESS, new LoopbackPlugin(CLIENT_OPERATOR_ADDRESS));
+
+    bilateralConnection
+        .getBilateralSenderMux().getBilateralSender(ACCOUNT_ADDRESS).get()
+        .safeGetMoneySender()
+        .sendMoney(BigInteger.TEN)
+        .join();
+  }
+
+  @Test
+  public void testDataReceiver() {
+    // The recei er on this connection is the loopback plugin...
+    this.bilateralConnection.getBilateralReceiverMux()
+        .registerBilateralReceiver(ACCOUNT_ADDRESS, new LoopbackPlugin(CLIENT_OPERATOR_ADDRESS));
+
+    // A prepare packet with a data-payload that contains the preimage of FULFILLMENT.
+    final InterledgerPreparePacket PREPARE_PACKET = TestHelpers.constructSendDataPreparePacket(ACCOUNT_ADDRESS);
+
+    final Optional<InterledgerResponsePacket> result = bilateralConnection
+        .getBilateralReceiverMux().getBilateralReceiver(ACCOUNT_ADDRESS).get()
+        .safeGetDataHandler()
+        .handleIncomingData(PREPARE_PACKET)
+        .join();
+
+    new InterledgerResponsePacketHandler() {
+      @Override
+      protected void handleFulfillPacket(InterledgerFulfillPacket interledgerFulfillPacket) {
+        assertThat(interledgerFulfillPacket.getFulfillment(), is(FULFILLMENT));
+      }
+
+      @Override
+      protected void handleRejectPacket(InterledgerRejectPacket interledgerRejectPacket) {
+        fail("Should not reject!");
+      }
+
+      @Override
+      protected void handleExpiredPacket() {
+        fail("Should not expire!");
+      }
+    }.handle(result);
+
+  }
+
+  @Test
+  public void testMoneyReceiver() {
+    // The sender on this connection is the loopback plugin...
+    this.bilateralConnection.getBilateralReceiverMux()
+        .registerBilateralReceiver(ACCOUNT_ADDRESS, new LoopbackPlugin(CLIENT_OPERATOR_ADDRESS));
+
+    bilateralConnection
+        .getBilateralReceiverMux().getBilateralReceiver(ACCOUNT_ADDRESS).get()
+        .safeGetMoneyHandler()
+        .handleIncomingMoney(BigInteger.TEN)
+        .join();
+  }
+
+
   @Configuration
   @EnableAutoConfiguration
   @EnableWebSocket
Index: ilp-plugin-btp-springws/src/main/java/org/interledger/plugin/lpiv2/btp2/spring/connection/MultiAccountConnectionSettings.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ilp-plugin-btp-springws/src/main/java/org/interledger/plugin/lpiv2/btp2/spring/connection/MultiAccountConnectionSettings.java	(date 1546459068000)
+++ ilp-plugin-btp-springws/src/main/java/org/interledger/plugin/lpiv2/btp2/spring/connection/MultiAccountConnectionSettings.java	(date 1546459068000)
@@ -0,0 +1,12 @@
+package org.interledger.plugin.lpiv2.btp2.spring.connection;
+
+import org.interledger.plugin.connections.settings.BilateralConnectionSettings;
+
+/**
+ * An extension of {@link BilateralConnectionSettings} that supports only a single account.
+ */
+public interface MultiAccountConnectionSettings extends BilateralConnectionSettings {
+
+  DefaultPluginSettings getDefaultPluginSettings();
+
+}
Index: ilp-plugin-btp-springws/src/main/java/org/interledger/plugin/lpiv2/btp2/spring/connection/SingleAccountBtpClientConnection.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ilp-plugin-btp-springws/src/main/java/org/interledger/plugin/lpiv2/btp2/spring/connection/SingleAccountBtpClientConnection.java	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
+++ ilp-plugin-btp-springws/src/main/java/org/interledger/plugin/lpiv2/btp2/spring/connection/SingleAccountBtpClientConnection.java	(date 1546459026000)
@@ -1,27 +1,216 @@
 package org.interledger.plugin.lpiv2.btp2.spring.connection;
 
+import static org.interledger.plugin.lpiv2.btp2.subprotocols.BtpSubProtocolHandlerRegistry.BTP_SUB_PROTOCOL_AUTH;
+import static org.interledger.plugin.lpiv2.btp2.subprotocols.BtpSubProtocolHandlerRegistry.BTP_SUB_PROTOCOL_ILP;
+
+import org.interledger.btp.BtpMessage;
+import org.interledger.btp.BtpPacket;
+import org.interledger.btp.BtpResponse;
+import org.interledger.btp.BtpSession;
+import org.interledger.btp.BtpSubProtocol.ContentType;
 import org.interledger.core.InterledgerAddress;
-import org.interledger.plugin.lpiv2.btp2.spring.connection.mux.ClientBtpWebsocketMux;
+import org.interledger.plugin.connections.PluginFactory;
+import org.interledger.plugin.lpiv2.Plugin;
+import org.interledger.plugin.lpiv2.btp2.spring.BtpSessionUtils;
+import org.interledger.plugin.lpiv2.btp2.spring.ClientWebsocketBtpPlugin;
+import org.interledger.plugin.lpiv2.btp2.spring.converters.BinaryMessageToBtpPacketConverter;
+import org.interledger.plugin.lpiv2.btp2.spring.converters.BtpConversionException;
+import org.interledger.plugin.lpiv2.btp2.spring.converters.BtpPacketToBinaryMessageConverter;
+import org.interledger.plugin.lpiv2.btp2.subprotocols.AbstractBtpSubProtocolHandler;
+import org.interledger.plugin.lpiv2.btp2.subprotocols.BtpSubProtocolHandlerRegistry;
+import org.interledger.plugin.lpiv2.btp2.subprotocols.ilp.IlpBtpSubprotocolHandler;
+
+import com.google.common.io.BaseEncoding;
+import org.springframework.web.socket.BinaryMessage;
+import org.springframework.web.socket.WebSocketSession;
+import org.springframework.web.socket.client.standard.StandardWebSocketClient;
+import org.springframework.web.socket.handler.BinaryWebSocketHandler;
+
+import java.util.Objects;
+import java.util.Optional;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.TimeUnit;
 
 /**
- * A {@link AbstractSingleAccountBtpConnection} that uses a Websocket Client to communicate with a bilateral peer.
+ * An extension of {@link AbstractSingleAccountBtpConnection} that uses a Websocket Client to communicate with a
+ * bilateral peer, supporting only a single account.
  */
-public class SingleAccountBtpClientConnection extends AbstractSingleAccountBtpConnection<ClientBtpWebsocketMux> {
+public class SingleAccountBtpClientConnection extends
+    AbstractSingleAccountBtpConnection<SingleAccountConnectionSettings> {
+
+  // TODO: Consider moving to a single HttpUrl.
+  private final String remotePeerScheme;
+  private final String remotePeerHostname;
+  private final String remotePeerPort;
+
+  // Incoming and outgoing messages are transmitted via this client.
+  private final StandardWebSocketClient wsClient;
+
+  // Must be declared here so that it can contain a reference to this connection...
+  private final Plugin<?> plugin;
 
   /**
    * Required-args Constructor.
-   *
-   * @param operatorAddress       The {@link InterledgerAddress} of the operator of this connection.
-   * @param accountAddress        The {@link InterledgerAddress} of the account that this BTP connection supports.
-   * @param clientBtpWebsocketMux An {@link ClientBtpWebsocketMux} that provides both sender and receiver functionality
-   *                              using a WebSocket server.
    */
   public SingleAccountBtpClientConnection(
-      final InterledgerAddress operatorAddress,
-      final InterledgerAddress accountAddress,
-      final ClientBtpWebsocketMux clientBtpWebsocketMux
+      final SingleAccountConnectionSettings connectionSettings,
+      final PluginFactory pluginFactory,
+      final BinaryMessageToBtpPacketConverter binaryMessageToBtpPacketConverter,
+      final BtpPacketToBinaryMessageConverter btpPacketToBinaryMessageConverter,
+      final BtpSubProtocolHandlerRegistry btpSubProtocolHandlerRegistry,
+      final String remotePeerScheme,
+      final String remotePeerHostname,
+      final String remotePeerPort,
+      final StandardWebSocketClient wsClient
   ) {
-    super(operatorAddress, accountAddress, clientBtpWebsocketMux);
+    super(
+        connectionSettings, pluginFactory, binaryMessageToBtpPacketConverter, btpPacketToBinaryMessageConverter,
+        btpSubProtocolHandlerRegistry
+    );
+
+    this.remotePeerScheme = Objects.requireNonNull(remotePeerScheme);
+    this.remotePeerHostname = Objects.requireNonNull(remotePeerHostname);
+    this.remotePeerPort = Objects.requireNonNull(remotePeerPort);
+
+    this.wsClient = Objects.requireNonNull(wsClient);
+
+    // This constructor connects the plugin's send-data functionality to this connection.
+    this.plugin = new ClientWebsocketBtpPlugin(connectionSettings.getPluginSettings(), this);
+
+    // Make the plugin be the DataHandler for the BtpSubProtocolRegistry.
+    final IlpBtpSubprotocolHandler ilpSubprotocolHandler = this.getBtpSubProtocolHandlerRegistry()
+        .getHandler(BTP_SUB_PROTOCOL_ILP, ContentType.MIME_APPLICATION_OCTET_STREAM)
+        .map(handler -> (IlpBtpSubprotocolHandler) handler)
+        .orElseThrow(() -> new RuntimeException("BtpSubProtocolHandlerRegistry must have an ILP handler!"));
+    ilpSubprotocolHandler.unregisterDataHandler();
+    ilpSubprotocolHandler.registerDataHandler(
+        getConnectionSettings().getAccountAddress(),
+        this.getPlugin(connectionSettings.getAccountAddress()).safeGetDataHandler()
+    );
+  }
+
+  /**
+   * Obtain the {@link Plugin} for the specified {@code accountAddress}.
+   *
+   * @param accountAddress The {@link InterledgerAddress} of the account to retrieve a plugin for.
+   *
+   * @return An instance of {@link Plugin}.
+   */
+  @Override
+  public Plugin<?> getPlugin(InterledgerAddress accountAddress) {
+    //return getPluginFactory().constructPlugin(getConnectionSettings().getPluginSettings());
+
+    // TODO: Construct the plugin here. The connection is the only thing that knows how to do this because the Plugin
+    // interface is not aware of its connection (even though the implementation is).
+    return this.plugin;
   }
 
+  /**
+   * Handle an incoming BinaryMessage from a Websocket, assuming it's a BTP Auth message. This implementation override
+   * the default server-variant because the client must handle Auth differently from the Server.
+   *
+   * @return A {@link BinaryMessage} that can immediately be returned to the caller (this response will contain
+   *     everything required to be eligible as a BTP response), or nothing if the response is {@link Optional#empty()}.
+   */
+  @Override
+  public Optional<BtpResponse> handleBinaryAuthMessage(
+      final WebSocketSession webSocketSession, final BinaryMessage incomingBinaryMessage
+  ) {
+    Objects.requireNonNull(webSocketSession);
+    Objects.requireNonNull(incomingBinaryMessage);
+
+    final AbstractBtpSubProtocolHandler btpAuthSubprotocolHandler = this.getBtpSubProtocolHandlerRegistry()
+        .getHandler(BTP_SUB_PROTOCOL_AUTH, ContentType.MIME_APPLICATION_OCTET_STREAM)
+        .orElseThrow(() -> new RuntimeException("No BTP AuthSubprotocol Handler registered!"));
+
+    // If there's a problem de-serializing the BtpPacket from the BinaryMessage, then close the connection and
+    // return empty. This is one of the "tricky cases" as defined in the BTP spec where we don't want to get into
+    // an infinite loop.
+    final BtpPacket incomingBtpPacket;
+    try {
+      incomingBtpPacket = this.binaryMessageToBtpPacketConverter.convert(incomingBinaryMessage);
+      final BtpSession btpSession = BtpSessionUtils.getBtpSessionFromWebSocketSession(webSocketSession)
+          .orElseThrow(() -> new RuntimeException("BtpSession is required!"));
+      return btpAuthSubprotocolHandler.handleSubprotocolMessage(btpSession, incomingBtpPacket)
+          .thenApply($ -> {
+            // If there's no exception, then reaching here means the btp_auth SubProtocol succeeded, so return an
+            // empty BTP response to a pendingResponse so that an awaiting client can get an ultimate response.
+
+            // Join the response from the AuthHandler back to the pendingResponse.
+            this.joinPendingResponse(
+                BtpResponse.builder()
+                    .requestId(incomingBtpPacket.getRequestId())
+                    .build()
+            );
+
+            // Return empty so that the caller of handleBinaryAuthMessage doesn't return any response back to the sender
+            // of the actual incomingBinaryMessage.
+            return Optional.<BtpResponse>empty();
+          })
+          .join();
+    } catch (BtpConversionException btpConversionException) {
+      logger.error(btpConversionException.getMessage(), btpConversionException);
+      throw btpConversionException;
+    }
+  }
+
+  /**
+   * Perform the logic of connecting the actual transport(s) supporting this bilateral connection.
+   */
+  @Override
+  public CompletableFuture<Void> doConnectTransport() {
+    // Connect and initialize the WebSocketSession...
+    try {
+      final WebSocketSession webSocketSession =
+          wsClient.doHandshake(
+              new BinaryWebSocketHandler() {
+                @Override
+                public void afterConnectionEstablished(WebSocketSession session) {
+                  // Initialize a new BTP Session...
+                  final BtpSession btpSession = new BtpSession(
+                      session.getId(),
+                      getConnectionSettings().getAccountAddress(),
+                      getBtpSessionCredentials()
+                  );
+                  BtpSessionUtils.setBtpSessionIntoWebsocketSession(session, btpSession);
+                }
+
+                @Override
+                protected void handleBinaryMessage(WebSocketSession session, BinaryMessage message) {
+                  SingleAccountBtpClientConnection.this.handleBinaryMessage(session, message);
+                }
+              },
+              "{scheme}://{localhost}:{port}/btp",
+              remotePeerScheme,
+              remotePeerHostname,
+              remotePeerPort)
+              // TODO: Make configurable.
+              .get(5, TimeUnit.SECONDS);
+
+      // AUTH over the new Websocket Session...
+      final long requestId = nextRequestId();
+      final BtpMessage btpAuthMessage = this.constructAuthMessage(requestId, getBtpSessionCredentials());
+      final BinaryMessage binaryAuthMessage = btpPacketToBinaryMessageConverter.convert(btpAuthMessage);
+      logger.debug(
+          "Websocket Auth BinaryMessage Bytes: {}",
+          BaseEncoding.base16().encode(binaryAuthMessage.getPayload().array())
+      );
+
+      return this.sendMessageWithPendingRepsonse(requestId, webSocketSession, binaryAuthMessage)
+          .handle((response, error) -> {
+            if (error != null) {
+              // the pending response timed out or otherwise had a problem...
+              logger.error(error.getMessage(), error);
+            } else {
+              // The pending response completed successfully...
+              logger.debug("Auth completed successfully!");
+            }
+            // To conform to `Void` return type.
+            return null;
+          });
+    } catch (Exception e) {
+      this.disconnect().join();
+      throw new RuntimeException(e.getMessage(), e);
+    }
+  }
 }
Index: ilp-plugin-btp-springws/src/test/java/org/interledger/plugin/lpiv2/btp2/spring/connection/MultiAccountBtpConnectionTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ilp-plugin-btp-springws/src/test/java/org/interledger/plugin/lpiv2/btp2/spring/connection/MultiAccountBtpConnectionTest.java	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
+++ ilp-plugin-btp-springws/src/test/java/org/interledger/plugin/lpiv2/btp2/spring/connection/MultiAccountBtpConnectionTest.java	(date 1545854141000)
@@ -211,12 +211,7 @@
     BtpSubProtocolHandlerRegistry btpSubProtocolHandlerRegistry() {
       final BtpAuthenticator noOpAuthenticator = new BtpAuthenticator() {
         @Override
-        public boolean isValidAuthToken(String incomingAuthToken) {
-          return false;
-        }
-
-        @Override
-        public boolean isValidAuthToken(String incomingAuthUsername, String incomingAuthToken) {
+        public boolean isValidAuthToken(String authToken) {
           return false;
         }
 
@@ -225,7 +220,9 @@
           throw new RuntimeException("This implementation should never be used!");
         }
       };
-      final BtpMultiAuthenticator btpMultiAuthenticator = new AlwaysAllowedBtpMultiAuthenticator();
+      final BtpMultiAuthenticator btpMultiAuthenticator = new AlwaysAllowedBtpMultiAuthenticator(
+          SERVER_OPERATOR_ADDRESS
+      );
       final ServerAuthBtpSubprotocolHandler btpAuthHandler = new ServerAuthBtpSubprotocolHandler(
           noOpAuthenticator, btpMultiAuthenticator
       );
Index: ilp-plugin-btp-springws/src/main/java/org/interledger/plugin/lpiv2/btp2/spring/connection/DefaultPluginSettings.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ilp-plugin-btp-springws/src/main/java/org/interledger/plugin/lpiv2/btp2/spring/connection/DefaultPluginSettings.java	(date 1546458975000)
+++ ilp-plugin-btp-springws/src/main/java/org/interledger/plugin/lpiv2/btp2/spring/connection/DefaultPluginSettings.java	(date 1546458975000)
@@ -0,0 +1,38 @@
+package org.interledger.plugin.lpiv2.btp2.spring.connection;
+
+import org.interledger.plugin.lpiv2.ImmutablePluginSettings;
+import org.interledger.plugin.lpiv2.Plugin;
+import org.interledger.plugin.lpiv2.PluginSettings;
+import org.interledger.plugin.lpiv2.PluginType;
+
+import org.immutables.value.Value.Immutable;
+
+import java.util.Map;
+
+/**
+ * Configuration information relating to the {@link Plugin} that should be used for any account in a particular
+ * connection. This interface tracks default settings, independent of any single plugin, so that new plugins can be
+ * initialized during a connection based upon a pre-configured set of values (e.g., configured in a properties file).
+ */
+public interface DefaultPluginSettings extends PluginSettings {
+
+  static ImmutablePluginSettings.Builder builder() {
+    return ImmutablePluginSettings.builder();
+  }
+
+  /**
+   * The type of this ledger plugin.
+   */
+  PluginType getPluginType();
+
+  /**
+   * Additional, custom settings that any plugin can define.
+   */
+  Map<String, Object> getCustomSettings();
+
+  @Immutable
+  abstract class AbstractDefaultPluginSettings implements DefaultPluginSettings {
+
+  }
+
+}
Index: ilp-plugin-btp-springws/src/main/java/org/interledger/plugin/lpiv2/btp2/spring/connection/SingleAccountBtpServerConnection.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ilp-plugin-btp-springws/src/main/java/org/interledger/plugin/lpiv2/btp2/spring/connection/SingleAccountBtpServerConnection.java	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
+++ ilp-plugin-btp-springws/src/main/java/org/interledger/plugin/lpiv2/btp2/spring/connection/SingleAccountBtpServerConnection.java	(date 1546465103000)
@@ -1,81 +1,79 @@
 package org.interledger.plugin.lpiv2.btp2.spring.connection;
 
+import static org.interledger.plugin.lpiv2.btp2.subprotocols.BtpSubProtocolHandlerRegistry.BTP_SUB_PROTOCOL_ILP;
+
+import org.interledger.btp.BtpSubProtocol.ContentType;
 import org.interledger.core.InterledgerAddress;
-import org.interledger.plugin.lpiv2.btp2.spring.connection.mux.ServerBtpWebsocketMux;
+import org.interledger.plugin.connections.PluginFactory;
+import org.interledger.plugin.lpiv2.Plugin;
+import org.interledger.plugin.lpiv2.btp2.spring.ServerBtpPlugin;
+import org.interledger.plugin.lpiv2.btp2.spring.converters.BinaryMessageToBtpPacketConverter;
+import org.interledger.plugin.lpiv2.btp2.spring.converters.BtpPacketToBinaryMessageConverter;
+import org.interledger.plugin.lpiv2.btp2.subprotocols.BtpSubProtocolHandlerRegistry;
+import org.interledger.plugin.lpiv2.btp2.subprotocols.ilp.IlpBtpSubprotocolHandler;
 
-import org.springframework.web.socket.CloseStatus;
-import org.springframework.web.socket.WebSocketHandler;
-import org.springframework.web.socket.WebSocketMessage;
-import org.springframework.web.socket.WebSocketSession;
+import java.util.concurrent.CompletableFuture;
 
 /**
- * <p>A {@link AbstractSingleAccountBtpConnection} that uses a Websocket server to communicate with a bilateral peer, allowing
- * only a single plugin account to operate over the connection. Because this is a BTP connection, we use a combo-mux,
- * which means the sender and receiver Muxes are the same instance.</p>
- *
- * <p>Even though this class implements {@link WebSocketHandler}, all messages are forwarded to the MUX, which operates
- * the entire network transport.</p>
+ * An extension of {@link AbstractSingleAccountBtpConnection} that uses a Websocket Server to communicate with a
+ * bilateral peer, supporting only a single account.
  */
-public class SingleAccountBtpServerConnection extends AbstractSingleAccountBtpConnection<ServerBtpWebsocketMux>
-    implements WebSocketHandler {
+public class SingleAccountBtpServerConnection extends
+    AbstractSingleAccountBtpConnection<SingleAccountConnectionSettings> {
+
+  // Must be declared here so that it can contain a reference to this connection...
+  private final Plugin<?> plugin;
 
   /**
    * Required-args Constructor.
-   *
-   * @param operatorAddress       The {@link InterledgerAddress} of the operator of this connection.
-   * @param accountAddress        The {@link InterledgerAddress} of the account that this BTP connection supports.
-   * @param serverBtpWebsocketMux An {@link ServerBtpWebsocketMux} that provides both sender and receiver functionality
-   *                              using a WebSocket client.
    */
   public SingleAccountBtpServerConnection(
-      final InterledgerAddress operatorAddress,
-      final InterledgerAddress accountAddress,
-      final ServerBtpWebsocketMux serverBtpWebsocketMux
-  ) {
-    super(operatorAddress, accountAddress, serverBtpWebsocketMux);
-  }
+      SingleAccountConnectionSettings connectionSettings, PluginFactory pluginFactory,
+      BinaryMessageToBtpPacketConverter binaryMessageToBtpPacketConverter,
+      BtpPacketToBinaryMessageConverter btpPacketToBinaryMessageConverter,
+      BtpSubProtocolHandlerRegistry btpSubProtocolHandlerRegistry) {
+    super(
+        connectionSettings, pluginFactory, binaryMessageToBtpPacketConverter, btpPacketToBinaryMessageConverter,
+        btpSubProtocolHandlerRegistry
+    );
 
-  ///////////////////
-  // WebSocketHandler
-  ///////////////////
+    // This constructor connects the plugin's send-data functionality to this connection.
+    this.plugin = new ServerBtpPlugin(connectionSettings.getPluginSettings(), this);
 
-  /**
-   * Forward to the combo mux, which is the actual {@link WebSocketHandler}.
-   */
-  @Override
-  public void afterConnectionEstablished(WebSocketSession session) {
-    this.getComboMux().afterConnectionEstablished(session);
+    // Make the plugin be the DataHandler for the BtpSubProtocolRegistry.
+    final IlpBtpSubprotocolHandler ilpSubprotocolHandler = this.getBtpSubProtocolHandlerRegistry()
+        .getHandler(BTP_SUB_PROTOCOL_ILP, ContentType.MIME_APPLICATION_OCTET_STREAM)
+        .map(handler -> (IlpBtpSubprotocolHandler) handler)
+        .orElseThrow(() -> new RuntimeException("BtpSubProtocolHandlerRegistry must have an ILP handler!"));
+    ilpSubprotocolHandler.unregisterDataHandler();
+    ilpSubprotocolHandler.registerDataHandler(
+        getConnectionSettings().getAccountAddress(),
+        this.getPlugin(connectionSettings.getAccountAddress()).safeGetDataHandler()
+    );
   }
 
   /**
-   * Forward to the combo mux, which is the actual {@link WebSocketHandler}.
+   * Obtain the {@link Plugin} for the specified {@code accountAddress}.
+   *
+   * @param accountAddress The {@link InterledgerAddress} of the account to retrieve a plugin for.
+   *
+   * @return An instance of {@link Plugin}.
    */
   @Override
-  public void handleMessage(WebSocketSession session, WebSocketMessage<?> message) {
-    this.getComboMux().handleMessage(session, message);
+  public Plugin<?> getPlugin(InterledgerAddress accountAddress) {
+    //return getPluginFactory().constructPlugin(getConnectionSettings().getPluginSettings());
+
+    // TODO: Construct the plugin here. The connection is the only thing that knows how to do this because the Plugin
+    // interface is not aware of its connection (even though the implementation is).
+    return this.plugin;
   }
 
   /**
-   * Forward to the combo mux, which is the actual {@link WebSocketHandler}.
+   * Perform the logic of connecting the actual transport(s) supporting this bilateral connection.
    */
   @Override
-  public void handleTransportError(WebSocketSession session, Throwable exception) {
-    this.getComboMux().handleTransportError(session, exception);
-  }
-
-  /**
-   * Forward to the combo mux, which is the actual {@link WebSocketHandler}.
-   */
-  @Override
-  public void afterConnectionClosed(WebSocketSession session, CloseStatus closeStatus) {
-    this.getComboMux().afterConnectionClosed(session, closeStatus);
-  }
-
-  /**
-   * Forward to the combo mux, which is the actual {@link WebSocketHandler}.
-   */
-  @Override
-  public boolean supportsPartialMessages() {
-    return this.getComboMux().supportsPartialMessages();
+  public CompletableFuture<Void> doConnectTransport() {
+    // No-op. All connections are initiated by external callers.
+    return CompletableFuture.completedFuture(null);
   }
 }
Index: ilp-plugin-btp-springws/src/main/java/org/interledger/plugin/lpiv2/btp2/spring/connection/AbstractMultiAccountBtpConnection.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ilp-plugin-btp-springws/src/main/java/org/interledger/plugin/lpiv2/btp2/spring/connection/AbstractMultiAccountBtpConnection.java	(revision b4b6fefbee1d1ea67143f9be734204eab663a643)
+++ ilp-plugin-btp-springws/src/main/java/org/interledger/plugin/lpiv2/btp2/spring/connection/AbstractMultiAccountBtpConnection.java	(date 1546459896000)
@@ -1,38 +1,28 @@
 package org.interledger.plugin.lpiv2.btp2.spring.connection;
 
-import org.interledger.core.InterledgerAddress;
-import org.interledger.plugin.connections.AbstractBilateralConnection;
 import org.interledger.plugin.connections.BilateralConnection;
-import org.interledger.plugin.connections.mux.AbstractBilateralComboMux;
+import org.interledger.plugin.connections.PluginFactory;
+import org.interledger.plugin.lpiv2.btp2.spring.converters.BinaryMessageToBtpPacketConverter;
+import org.interledger.plugin.lpiv2.btp2.spring.converters.BtpPacketToBinaryMessageConverter;
+import org.interledger.plugin.lpiv2.btp2.subprotocols.BtpSubProtocolHandlerRegistry;
 
 /**
  * A {@link BilateralConnection} that uses enhanced BTP to support multiple accounts per Websocket connection (i.e., the
  * `auth_username` is used to identify the account of an incoming connection, and  the `auth_token` is used for
  * authentication).
  */
-public abstract class AbstractMultiAccountBtpConnection<T extends AbstractBilateralComboMux>
-    extends AbstractBilateralConnection<T, T> {
+public abstract class AbstractMultiAccountBtpConnection<CS extends MultiAccountConnectionSettings>
+    extends AbstractBtpConnection<CS> {
 
   /**
    * Required-args Constructor.
-   *
-   * @param operatorAddress The {@link InterledgerAddress} of the operator of this connection.
-   * @param comboMux        An {@link AbstractBilateralComboMux} that provides both sender and receiver functionality.
    */
-  public AbstractMultiAccountBtpConnection(
-      final InterledgerAddress operatorAddress,
-      final T comboMux
-  ) {
-    super(operatorAddress, comboMux, comboMux);
-  }
-
-  /**
-   * For a BTP connections, we know the sender and receiver will be the same instance (i.e., a {@link
-   * AbstractBilateralComboMux}, so we can return either the sender or receiver to conform to this interface.
-   *
-   * @return
-   */
-  T getComboMux() {
-    return this.getBilateralSenderMux();
+  public AbstractMultiAccountBtpConnection(CS connectionSettings,
+      PluginFactory pluginFactory,
+      BinaryMessageToBtpPacketConverter binaryMessageToBtpPacketConverter,
+      BtpPacketToBinaryMessageConverter btpPacketToBinaryMessageConverter,
+      BtpSubProtocolHandlerRegistry btpSubProtocolHandlerRegistry) {
+    super(connectionSettings, pluginFactory, binaryMessageToBtpPacketConverter, btpPacketToBinaryMessageConverter,
+        btpSubProtocolHandlerRegistry);
   }
 }
Index: ilp-plugin-connections/src/main/java/org/interledger/plugin/connections/AbstractPluginConnectionManager.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- ilp-plugin-connections/src/main/java/org/interledger/plugin/connections/AbstractPluginConnectionManager.java	(date 1546464072000)
+++ ilp-plugin-connections/src/main/java/org/interledger/plugin/connections/AbstractPluginConnectionManager.java	(date 1546464072000)
@@ -0,0 +1,26 @@
+package org.interledger.plugin.connections;
+
+import org.interledger.core.InterledgerAddress;
+import org.interledger.plugin.lpiv2.Plugin;
+
+import com.google.common.collect.Maps;
+
+import java.util.Map;
+import java.util.Optional;
+
+/**
+ * An abstract implementation of {@link PluginConnectionManager}.
+ */
+public abstract class AbstractPluginConnectionManager implements PluginConnectionManager {
+
+  private Map<InterledgerAddress, Plugin<?>> connections;
+
+  public AbstractPluginConnectionManager() {
+    this.connections = Maps.newConcurrentMap();
+  }
+
+  @Override
+  public Optional<Plugin<?>> getPlugin(InterledgerAddress accountAddress) {
+    return Optional.of(connections.get(accountAddress));
+  }
+}
